From 712d7d611de7357c1324cce4a19f5f6d6ec48cb7 Mon Sep 17 00:00:00 2001
From: Andrei Gherzan <andrei.gherzan@windriver.com>
Date: Wed, 13 May 2015 16:06:11 +0200
Subject: [PATCH] Add CommonAPI sources generated with CommonAPI 2.1.6 generator

Signed-off-by: Andrei Gherzan <andrei.gherzan@windriver.com>
---
 .../src-gen/org/genivi/NodeStateManager/Consumer.h |   62 +
 .../genivi/NodeStateManager/ConsumerDBusProxy.cpp  |  284 +++
 .../genivi/NodeStateManager/ConsumerDBusProxy.h    |   98 +
 .../NodeStateManager/ConsumerDBusStubAdapter.cpp   |  305 +++
 .../NodeStateManager/ConsumerDBusStubAdapter.h     |  182 ++
 .../org/genivi/NodeStateManager/ConsumerProxy.h    |  627 +++++
 .../genivi/NodeStateManager/ConsumerProxyBase.h    |   95 +
 .../org/genivi/NodeStateManager/ConsumerStub.h     |  152 ++
 .../NodeStateManager/ConsumerStubDefault.cpp       |  239 ++
 .../genivi/NodeStateManager/ConsumerStubDefault.h  |  128 +
 .../genivi/NodeStateManager/LifeCycleConsumer.h    |   62 +
 .../LifeCycleConsumerDBusProxy.cpp                 |   74 +
 .../NodeStateManager/LifeCycleConsumerDBusProxy.h  |   62 +
 .../LifeCycleConsumerDBusStubAdapter.cpp           |  121 +
 .../LifeCycleConsumerDBusStubAdapter.h             |  113 +
 .../NodeStateManager/LifeCycleConsumerProxy.h      |  185 ++
 .../NodeStateManager/LifeCycleConsumerProxyBase.h  |   49 +
 .../NodeStateManager/LifeCycleConsumerStub.h       |   98 +
 .../LifeCycleConsumerStubDefault.cpp               |   46 +
 .../LifeCycleConsumerStubDefault.h                 |   67 +
 .../src-gen/org/genivi/am.cpp                      | 1043 ++++++++
 PluginCommandInterfaceCAPI/src-gen/org/genivi/am.h | 2551 ++++++++++++++++++++
 .../src-gen/org/genivi/am/CommandControl.h         |   67 +
 .../org/genivi/am/CommandControlDBusProxy.cpp      |  651 +++++
 .../org/genivi/am/CommandControlDBusProxy.h        |  266 ++
 .../genivi/am/CommandControlDBusStubAdapter.cpp    | 1096 +++++++++
 .../org/genivi/am/CommandControlDBusStubAdapter.h  |  422 ++++
 .../src-gen/org/genivi/am/CommandControlProxy.h    | 1194 +++++++++
 .../org/genivi/am/CommandControlProxyBase.h        |  348 +++
 .../src-gen/org/genivi/am/CommandControlStub.h     |  492 ++++
 .../org/genivi/am/CommandControlStubDefault.cpp    |  456 ++++
 .../org/genivi/am/CommandControlStubDefault.h      |  336 +++
 .../src-gen/org/genivi/am.cpp                      | 1043 ++++++++
 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.h | 2551 ++++++++++++++++++++
 .../src-gen/org/genivi/am/RoutingControl.h         |   63 +
 .../org/genivi/am/RoutingControlDBusProxy.cpp      |  407 ++++
 .../org/genivi/am/RoutingControlDBusProxy.h        |  157 ++
 .../genivi/am/RoutingControlDBusStubAdapter.cpp    |  477 ++++
 .../org/genivi/am/RoutingControlDBusStubAdapter.h  |  250 ++
 .../src-gen/org/genivi/am/RoutingControlObserver.h |   63 +
 .../genivi/am/RoutingControlObserverDBusProxy.cpp  | 1135 +++++++++
 .../genivi/am/RoutingControlObserverDBusProxy.h    |  357 +++
 .../am/RoutingControlObserverDBusStubAdapter.cpp   | 1244 ++++++++++
 .../am/RoutingControlObserverDBusStubAdapter.h     |  557 +++++
 .../org/genivi/am/RoutingControlObserverProxy.h    | 1921 +++++++++++++++
 .../genivi/am/RoutingControlObserverProxyBase.h    |  401 +++
 .../org/genivi/am/RoutingControlObserverStub.h     |  407 ++++
 .../am/RoutingControlObserverStubDefault.cpp       |  636 +++++
 .../genivi/am/RoutingControlObserverStubDefault.h  |  429 ++++
 .../src-gen/org/genivi/am/RoutingControlProxy.h    |  712 ++++++
 .../org/genivi/am/RoutingControlProxyBase.h        |  163 ++
 .../src-gen/org/genivi/am/RoutingControlStub.h     |  198 ++
 .../org/genivi/am/RoutingControlStubDefault.cpp    |  224 ++
 .../org/genivi/am/RoutingControlStubDefault.h      |  176 ++
 54 files changed, 25542 insertions(+)
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/Consumer.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.cpp
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.cpp
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxy.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxyBase.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStub.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.cpp
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumer.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.cpp
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.cpp
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxy.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxyBase.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStub.h
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.cpp
 create mode 100644 AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.h
 create mode 100644 PluginCommandInterfaceCAPI/src-gen/org/genivi/am.cpp
 create mode 100644 PluginCommandInterfaceCAPI/src-gen/org/genivi/am.h
 create mode 100644 PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControl.h
 create mode 100644 PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.cpp
 create mode 100644 PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.h
 create mode 100644 PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.cpp
 create mode 100644 PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.h
 create mode 100644 PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxy.h
 create mode 100644 PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxyBase.h
 create mode 100644 PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStub.h
 create mode 100644 PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.cpp
 create mode 100644 PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.cpp
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControl.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.cpp
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.cpp
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserver.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.cpp
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.cpp
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxy.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxyBase.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStub.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.cpp
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxy.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxyBase.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStub.h
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.cpp
 create mode 100644 PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.h

diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/Consumer.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/Consumer.h
new file mode 100644
index 0000000..62c8f39
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/Consumer.h
@@ -0,0 +1,62 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Consumer_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Consumer_H_
+
+
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/types.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+class Consumer {
+ public:
+    virtual ~Consumer() { }
+
+    static inline const char* getInterfaceId();
+    static inline CommonAPI::Version getInterfaceVersion();
+};
+
+const char* Consumer::getInterfaceId() {
+    static const char* interfaceId = "org.genivi.NodeStateManager.Consumer";
+    return interfaceId;
+}
+
+CommonAPI::Version Consumer::getInterfaceVersion() {
+    return CommonAPI::Version(1, 0);
+}
+
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+namespace CommonAPI {
+
+}
+
+
+namespace std {
+    //hashes for types
+
+    //hashes for error types
+}
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Consumer_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.cpp b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.cpp
new file mode 100644
index 0000000..6f4139e
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.cpp
@@ -0,0 +1,284 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#include "ConsumerDBusProxy.h"
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+std::shared_ptr<CommonAPI::DBus::DBusProxy> createConsumerDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection) {
+    return std::make_shared<ConsumerDBusProxy>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection);
+}
+
+INITIALIZER(registerConsumerDBusProxy) {
+    CommonAPI::DBus::DBusFactory::registerProxyFactoryMethod(Consumer::getInterfaceId(),
+       &createConsumerDBusProxy);
+}
+
+ConsumerDBusProxy::ConsumerDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection):
+        CommonAPI::DBus::DBusProxy(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyconnection)
+,bootMode_(*this, "i", "getBootModeAttribute"),
+restartReason_(*this, "i", "getRestartReasonAttribute"),
+shutdownReason_(*this, "i", "getShutdownReasonAttribute"),
+wakeUpReason_(*this, "i", "getWakeUpReasonAttribute")
+,        nodeApplicationMode_(*this, "NodeApplicationMode", "i"),
+        sessionStateChanged_(*this, "SessionStateChanged", "sii"),
+        nodeState_(*this, "NodeState", "i")
+    {
+    }
+
+ConsumerDBusProxy::BootModeAttribute& ConsumerDBusProxy::getBootModeAttribute() {
+    return bootMode_;
+}
+ConsumerDBusProxy::RestartReasonAttribute& ConsumerDBusProxy::getRestartReasonAttribute() {
+    return restartReason_;
+}
+ConsumerDBusProxy::ShutdownReasonAttribute& ConsumerDBusProxy::getShutdownReasonAttribute() {
+    return shutdownReason_;
+}
+ConsumerDBusProxy::WakeUpReasonAttribute& ConsumerDBusProxy::getWakeUpReasonAttribute() {
+    return wakeUpReason_;
+}
+
+ConsumerDBusProxy::NodeApplicationModeEvent& ConsumerDBusProxy::getNodeApplicationModeEvent() {
+    return nodeApplicationMode_;
+}
+ConsumerDBusProxy::SessionStateChangedEvent& ConsumerDBusProxy::getSessionStateChangedEvent() {
+    return sessionStateChanged_;
+}
+ConsumerDBusProxy::NodeStateEvent& ConsumerDBusProxy::getNodeStateEvent() {
+    return nodeState_;
+}
+
+void ConsumerDBusProxy::GetAppHealthCount(CommonAPI::CallStatus& callStatus, uint32_t& Count) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<uint32_t> >::callMethodWithReply(
+        *this,
+        "GetAppHealthCount",
+        "",
+        callStatus
+        , Count);
+}
+std::future<CommonAPI::CallStatus> ConsumerDBusProxy::GetAppHealthCountAsync(GetAppHealthCountAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<uint32_t> >::callMethodAsync(
+        *this,
+        "GetAppHealthCount",
+        "",
+        std::move(callback));
+}
+void ConsumerDBusProxy::LifecycleRequestComplete(const uint32_t& RequestId, const int32_t& Status, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<uint32_t, int32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodWithReply(
+        *this,
+        "LifecycleRequestComplete",
+        "ui",
+        RequestId, Status,
+        callStatus
+        , ErrorCode);
+}
+std::future<CommonAPI::CallStatus> ConsumerDBusProxy::LifecycleRequestCompleteAsync(const uint32_t& RequestId, const int32_t& Status, LifecycleRequestCompleteAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<uint32_t, int32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodAsync(
+        *this,
+        "LifecycleRequestComplete",
+        "ui",
+        RequestId, Status, 
+        std::move(callback));
+}
+void ConsumerDBusProxy::GetInterfaceVersion(CommonAPI::CallStatus& callStatus, uint32_t& Version) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<uint32_t> >::callMethodWithReply(
+        *this,
+        "GetInterfaceVersion",
+        "",
+        callStatus
+        , Version);
+}
+std::future<CommonAPI::CallStatus> ConsumerDBusProxy::GetInterfaceVersionAsync(GetInterfaceVersionAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<uint32_t> >::callMethodAsync(
+        *this,
+        "GetInterfaceVersion",
+        "",
+        std::move(callback));
+}
+void ConsumerDBusProxy::GetApplicationMode(CommonAPI::CallStatus& callStatus, int32_t& ErrorCode, int32_t& ApplicationModeId) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t, int32_t> >::callMethodWithReply(
+        *this,
+        "GetApplicationMode",
+        "",
+        callStatus
+        , ErrorCode, ApplicationModeId);
+}
+std::future<CommonAPI::CallStatus> ConsumerDBusProxy::GetApplicationModeAsync(GetApplicationModeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t, int32_t> >::callMethodAsync(
+        *this,
+        "GetApplicationMode",
+        "",
+        std::move(callback));
+}
+void ConsumerDBusProxy::UnRegisterSession(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, std::string, int32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodWithReply(
+        *this,
+        "UnRegisterSession",
+        "ssi",
+        SessionName, SessionOwner, SeatID,
+        callStatus
+        , ErrorCode);
+}
+std::future<CommonAPI::CallStatus> ConsumerDBusProxy::UnRegisterSessionAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, UnRegisterSessionAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, std::string, int32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodAsync(
+        *this,
+        "UnRegisterSession",
+        "ssi",
+        SessionName, SessionOwner, SeatID, 
+        std::move(callback));
+}
+void ConsumerDBusProxy::RegisterSession(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, const int32_t& SessionState, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, std::string, int32_t, int32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodWithReply(
+        *this,
+        "RegisterSession",
+        "ssii",
+        SessionName, SessionOwner, SeatID, SessionState,
+        callStatus
+        , ErrorCode);
+}
+std::future<CommonAPI::CallStatus> ConsumerDBusProxy::RegisterSessionAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, const int32_t& SessionState, RegisterSessionAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, std::string, int32_t, int32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodAsync(
+        *this,
+        "RegisterSession",
+        "ssii",
+        SessionName, SessionOwner, SeatID, SessionState, 
+        std::move(callback));
+}
+void ConsumerDBusProxy::UnRegisterShutdownClient(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, std::string, uint32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodWithReply(
+        *this,
+        "UnRegisterShutdownClient",
+        "ssu",
+        BusName, ObjName, ShutdownMode,
+        callStatus
+        , ErrorCode);
+}
+std::future<CommonAPI::CallStatus> ConsumerDBusProxy::UnRegisterShutdownClientAsync(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, UnRegisterShutdownClientAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, std::string, uint32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodAsync(
+        *this,
+        "UnRegisterShutdownClient",
+        "ssu",
+        BusName, ObjName, ShutdownMode, 
+        std::move(callback));
+}
+void ConsumerDBusProxy::RegisterShutdownClient(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, const uint32_t& TimeoutMs, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, std::string, uint32_t, uint32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodWithReply(
+        *this,
+        "RegisterShutdownClient",
+        "ssuu",
+        BusName, ObjName, ShutdownMode, TimeoutMs,
+        callStatus
+        , ErrorCode);
+}
+std::future<CommonAPI::CallStatus> ConsumerDBusProxy::RegisterShutdownClientAsync(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, const uint32_t& TimeoutMs, RegisterShutdownClientAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, std::string, uint32_t, uint32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodAsync(
+        *this,
+        "RegisterShutdownClient",
+        "ssuu",
+        BusName, ObjName, ShutdownMode, TimeoutMs, 
+        std::move(callback));
+}
+void ConsumerDBusProxy::GetNodeState(CommonAPI::CallStatus& callStatus, int32_t& ErrorCode, int32_t& NodeStateId) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t, int32_t> >::callMethodWithReply(
+        *this,
+        "GetNodeState",
+        "",
+        callStatus
+        , ErrorCode, NodeStateId);
+}
+std::future<CommonAPI::CallStatus> ConsumerDBusProxy::GetNodeStateAsync(GetNodeStateAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t, int32_t> >::callMethodAsync(
+        *this,
+        "GetNodeState",
+        "",
+        std::move(callback));
+}
+void ConsumerDBusProxy::GetSessionState(const std::string& SessionName, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& SessionState, int32_t& ErrorCode) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, int32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t, int32_t> >::callMethodWithReply(
+        *this,
+        "GetSessionState",
+        "si",
+        SessionName, SeatID,
+        callStatus
+        , SessionState, ErrorCode);
+}
+std::future<CommonAPI::CallStatus> ConsumerDBusProxy::GetSessionStateAsync(const std::string& SessionName, const int32_t& SeatID, GetSessionStateAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, int32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t, int32_t> >::callMethodAsync(
+        *this,
+        "GetSessionState",
+        "si",
+        SessionName, SeatID, 
+        std::move(callback));
+}
+void ConsumerDBusProxy::SetSessionState(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SessionState, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, std::string, int32_t, int32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodWithReply(
+        *this,
+        "SetSessionState",
+        "ssii",
+        SessionName, SessionOwner, SessionState, SeatID,
+        callStatus
+        , ErrorCode);
+}
+std::future<CommonAPI::CallStatus> ConsumerDBusProxy::SetSessionStateAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SessionState, const int32_t& SeatID, SetSessionStateAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, std::string, int32_t, int32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodAsync(
+        *this,
+        "SetSessionState",
+        "ssii",
+        SessionName, SessionOwner, SessionState, SeatID, 
+        std::move(callback));
+}
+
+
+
+void ConsumerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
+    ownVersionMajor = 1;
+    ownVersionMinor = 0;
+}
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.h
new file mode 100644
index 0000000..139dd7e
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusProxy.h
@@ -0,0 +1,98 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Consumer_DBUS_PROXY_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Consumer_DBUS_PROXY_H_
+
+#include <org/genivi/NodeStateManager/ConsumerProxyBase.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/DBus/DBusFactory.h>
+#include <CommonAPI/DBus/DBusProxy.h>
+#include <CommonAPI/DBus/DBusAttribute.h>
+#include <CommonAPI/DBus/DBusEvent.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+#include <string>
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+class ConsumerDBusProxy: virtual public ConsumerProxyBase, virtual public CommonAPI::DBus::DBusProxy {
+ public:
+    ConsumerDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection);
+
+    virtual ~ConsumerDBusProxy() { }
+
+    virtual BootModeAttribute& getBootModeAttribute();
+    virtual RestartReasonAttribute& getRestartReasonAttribute();
+    virtual ShutdownReasonAttribute& getShutdownReasonAttribute();
+    virtual WakeUpReasonAttribute& getWakeUpReasonAttribute();
+
+    virtual NodeApplicationModeEvent& getNodeApplicationModeEvent();
+    virtual SessionStateChangedEvent& getSessionStateChangedEvent();
+    virtual NodeStateEvent& getNodeStateEvent();
+
+    virtual void GetAppHealthCount(CommonAPI::CallStatus& callStatus, uint32_t& Count);
+    virtual std::future<CommonAPI::CallStatus> GetAppHealthCountAsync(GetAppHealthCountAsyncCallback callback);
+    virtual void LifecycleRequestComplete(const uint32_t& RequestId, const int32_t& Status, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    virtual std::future<CommonAPI::CallStatus> LifecycleRequestCompleteAsync(const uint32_t& RequestId, const int32_t& Status, LifecycleRequestCompleteAsyncCallback callback);
+    virtual void GetInterfaceVersion(CommonAPI::CallStatus& callStatus, uint32_t& Version);
+    virtual std::future<CommonAPI::CallStatus> GetInterfaceVersionAsync(GetInterfaceVersionAsyncCallback callback);
+    virtual void GetApplicationMode(CommonAPI::CallStatus& callStatus, int32_t& ErrorCode, int32_t& ApplicationModeId);
+    virtual std::future<CommonAPI::CallStatus> GetApplicationModeAsync(GetApplicationModeAsyncCallback callback);
+    virtual void UnRegisterSession(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    virtual std::future<CommonAPI::CallStatus> UnRegisterSessionAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, UnRegisterSessionAsyncCallback callback);
+    virtual void RegisterSession(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, const int32_t& SessionState, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    virtual std::future<CommonAPI::CallStatus> RegisterSessionAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, const int32_t& SessionState, RegisterSessionAsyncCallback callback);
+    virtual void UnRegisterShutdownClient(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    virtual std::future<CommonAPI::CallStatus> UnRegisterShutdownClientAsync(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, UnRegisterShutdownClientAsyncCallback callback);
+    virtual void RegisterShutdownClient(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, const uint32_t& TimeoutMs, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    virtual std::future<CommonAPI::CallStatus> RegisterShutdownClientAsync(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, const uint32_t& TimeoutMs, RegisterShutdownClientAsyncCallback callback);
+    virtual void GetNodeState(CommonAPI::CallStatus& callStatus, int32_t& ErrorCode, int32_t& NodeStateId);
+    virtual std::future<CommonAPI::CallStatus> GetNodeStateAsync(GetNodeStateAsyncCallback callback);
+    virtual void GetSessionState(const std::string& SessionName, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& SessionState, int32_t& ErrorCode);
+    virtual std::future<CommonAPI::CallStatus> GetSessionStateAsync(const std::string& SessionName, const int32_t& SeatID, GetSessionStateAsyncCallback callback);
+    virtual void SetSessionState(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SessionState, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    virtual std::future<CommonAPI::CallStatus> SetSessionStateAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SessionState, const int32_t& SeatID, SetSessionStateAsyncCallback callback);
+
+
+    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;
+
+ private:
+   CommonAPI::DBus::DBusReadonlyAttribute<BootModeAttribute> bootMode_;
+   CommonAPI::DBus::DBusReadonlyAttribute<RestartReasonAttribute> restartReason_;
+   CommonAPI::DBus::DBusReadonlyAttribute<ShutdownReasonAttribute> shutdownReason_;
+   CommonAPI::DBus::DBusReadonlyAttribute<WakeUpReasonAttribute> wakeUpReason_;
+
+    CommonAPI::DBus::DBusEvent<NodeApplicationModeEvent> nodeApplicationMode_;
+    CommonAPI::DBus::DBusEvent<SessionStateChangedEvent> sessionStateChanged_;
+    CommonAPI::DBus::DBusEvent<NodeStateEvent> nodeState_;
+
+};
+
+
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Consumer_DBUS_PROXY_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.cpp b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.cpp
new file mode 100644
index 0000000..1d59a34
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.cpp
@@ -0,0 +1,305 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+#include "ConsumerDBusStubAdapter.h"
+#include <org/genivi/NodeStateManager/Consumer.h>
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createConsumerDBusStubAdapter(
+                   const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                   const std::string& commonApiAddress,
+                   const std::string& interfaceName,
+                   const std::string& busName,
+                   const std::string& objectPath,
+                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection,
+                   const std::shared_ptr<CommonAPI::StubBase>& stubBase) {
+    return std::make_shared<ConsumerDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
+}
+
+INITIALIZER(registerConsumerDBusStubAdapter) {
+    CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(Consumer::getInterfaceId(),
+                                                               &createConsumerDBusStubAdapter);
+}
+
+
+
+ConsumerDBusStubAdapterInternal::~ConsumerDBusStubAdapterInternal() {
+    deactivateManagedInstances();
+    ConsumerDBusStubAdapterHelper::deinit();
+}
+
+void ConsumerDBusStubAdapterInternal::deactivateManagedInstances() {
+
+}
+
+const char* ConsumerDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
+    static const std::string introspectionData =
+        "<method name=\"getInterfaceVersion\">\n"
+            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
+        "</method>\n"
+        "<method name=\"getBootModeAttribute\">\n"
+            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
+        "</method>\n"
+        "<method name=\"getRestartReasonAttribute\">\n"
+            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
+        "</method>\n"
+        "<method name=\"getShutdownReasonAttribute\">\n"
+            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
+        "</method>\n"
+        "<method name=\"getWakeUpReasonAttribute\">\n"
+            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
+        "</method>\n"
+        "<signal name=\"NodeApplicationMode\">\n"
+            "<arg name=\"ApplicationModeId\" type=\"i\" />\n"
+        "</signal>\n"
+        "<signal name=\"SessionStateChanged\">\n"
+            "<arg name=\"SessionStateName\" type=\"s\" />\n"
+            "<arg name=\"SeatID\" type=\"i\" />\n"
+            "<arg name=\"SessionState\" type=\"i\" />\n"
+        "</signal>\n"
+        "<signal name=\"NodeState\">\n"
+            "<arg name=\"NodeState\" type=\"i\" />\n"
+        "</signal>\n"
+        "<method name=\"GetAppHealthCount\">\n"
+            "<arg name=\"Count\" type=\"u\" direction=\"out\" />\n"
+        "</method>\n"
+        "<method name=\"LifecycleRequestComplete\">\n"
+            "<arg name=\"RequestId\" type=\"u\" direction=\"in\" />\n"
+            "<arg name=\"Status\" type=\"i\" direction=\"in\" />\n"
+            "<arg name=\"ErrorCode\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        "<method name=\"GetInterfaceVersion\">\n"
+            "<arg name=\"Version\" type=\"u\" direction=\"out\" />\n"
+        "</method>\n"
+        "<method name=\"GetApplicationMode\">\n"
+            "<arg name=\"ErrorCode\" type=\"i\" direction=\"out\" />\n"
+            "<arg name=\"ApplicationModeId\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        "<method name=\"UnRegisterSession\">\n"
+            "<arg name=\"SessionName\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"SessionOwner\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"SeatID\" type=\"i\" direction=\"in\" />\n"
+            "<arg name=\"ErrorCode\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        "<method name=\"RegisterSession\">\n"
+            "<arg name=\"SessionName\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"SessionOwner\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"SeatID\" type=\"i\" direction=\"in\" />\n"
+            "<arg name=\"SessionState\" type=\"i\" direction=\"in\" />\n"
+            "<arg name=\"ErrorCode\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        "<method name=\"UnRegisterShutdownClient\">\n"
+            "<arg name=\"BusName\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"ObjName\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"ShutdownMode\" type=\"u\" direction=\"in\" />\n"
+            "<arg name=\"ErrorCode\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        "<method name=\"RegisterShutdownClient\">\n"
+            "<arg name=\"BusName\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"ObjName\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"ShutdownMode\" type=\"u\" direction=\"in\" />\n"
+            "<arg name=\"TimeoutMs\" type=\"u\" direction=\"in\" />\n"
+            "<arg name=\"ErrorCode\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        "<method name=\"GetNodeState\">\n"
+            "<arg name=\"ErrorCode\" type=\"i\" direction=\"out\" />\n"
+            "<arg name=\"NodeStateId\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        "<method name=\"GetSessionState\">\n"
+            "<arg name=\"SessionName\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"SeatID\" type=\"i\" direction=\"in\" />\n"
+            "<arg name=\"SessionState\" type=\"i\" direction=\"out\" />\n"
+            "<arg name=\"ErrorCode\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        "<method name=\"SetSessionState\">\n"
+            "<arg name=\"SessionName\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"SessionOwner\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"SessionState\" type=\"i\" direction=\"in\" />\n"
+            "<arg name=\"SeatID\" type=\"i\" direction=\"in\" />\n"
+            "<arg name=\"ErrorCode\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+
+    ;
+    return introspectionData.c_str();
+}
+
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        CommonAPI::Version
+        > ConsumerDBusStubAdapterInternal::getConsumerInterfaceVersionStubDispatcher(&ConsumerStub::getInterfaceVersion, "uu");
+
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        int32_t
+        > ConsumerDBusStubAdapterInternal::getBootModeAttributeStubDispatcher(&ConsumerStub::getBootModeAttribute, "i");
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        int32_t
+        > ConsumerDBusStubAdapterInternal::getRestartReasonAttributeStubDispatcher(&ConsumerStub::getRestartReasonAttribute, "i");
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        int32_t
+        > ConsumerDBusStubAdapterInternal::getShutdownReasonAttributeStubDispatcher(&ConsumerStub::getShutdownReasonAttribute, "i");
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        int32_t
+        > ConsumerDBusStubAdapterInternal::getWakeUpReasonAttributeStubDispatcher(&ConsumerStub::getWakeUpReasonAttribute, "i");
+
+
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<>,
+    std::tuple<uint32_t>
+    > ConsumerDBusStubAdapterInternal::getAppHealthCountStubDispatcher(&ConsumerStub::GetAppHealthCount, "u");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<uint32_t, int32_t>,
+    std::tuple<int32_t>
+    > ConsumerDBusStubAdapterInternal::lifecycleRequestCompleteStubDispatcher(&ConsumerStub::LifecycleRequestComplete, "i");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<>,
+    std::tuple<uint32_t>
+    > ConsumerDBusStubAdapterInternal::getInterfaceVersionStubDispatcher(&ConsumerStub::GetInterfaceVersion, "u");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<>,
+    std::tuple<int32_t, int32_t>
+    > ConsumerDBusStubAdapterInternal::getApplicationModeStubDispatcher(&ConsumerStub::GetApplicationMode, "ii");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, int32_t>,
+    std::tuple<int32_t>
+    > ConsumerDBusStubAdapterInternal::unRegisterSessionStubDispatcher(&ConsumerStub::UnRegisterSession, "i");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, int32_t, int32_t>,
+    std::tuple<int32_t>
+    > ConsumerDBusStubAdapterInternal::registerSessionStubDispatcher(&ConsumerStub::RegisterSession, "i");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, uint32_t>,
+    std::tuple<int32_t>
+    > ConsumerDBusStubAdapterInternal::unRegisterShutdownClientStubDispatcher(&ConsumerStub::UnRegisterShutdownClient, "i");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, uint32_t, uint32_t>,
+    std::tuple<int32_t>
+    > ConsumerDBusStubAdapterInternal::registerShutdownClientStubDispatcher(&ConsumerStub::RegisterShutdownClient, "i");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<>,
+    std::tuple<int32_t, int32_t>
+    > ConsumerDBusStubAdapterInternal::getNodeStateStubDispatcher(&ConsumerStub::GetNodeState, "ii");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, int32_t>,
+    std::tuple<int32_t, int32_t>
+    > ConsumerDBusStubAdapterInternal::getSessionStateStubDispatcher(&ConsumerStub::GetSessionState, "ii");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, int32_t, int32_t>,
+    std::tuple<int32_t>
+    > ConsumerDBusStubAdapterInternal::setSessionStateStubDispatcher(&ConsumerStub::SetSessionState, "i");
+
+
+
+void ConsumerDBusStubAdapterInternal::fireNodeApplicationModeEvent(const int32_t& ApplicationModeId) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<int32_t>>
+            ::sendSignal(
+                *this,
+                "NodeApplicationMode",
+                "i",
+                ApplicationModeId
+        );
+}
+void ConsumerDBusStubAdapterInternal::fireSessionStateChangedEvent(const std::string& SessionStateName, const int32_t& SeatID, const int32_t& SessionState) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<std::string, int32_t, int32_t>>
+            ::sendSignal(
+                *this,
+                "SessionStateChanged",
+                "sii",
+                SessionStateName, SeatID, SessionState
+        );
+}
+void ConsumerDBusStubAdapterInternal::fireNodeStateEvent(const int32_t& NodeState) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<int32_t>>
+            ::sendSignal(
+                *this,
+                "NodeState",
+                "i",
+                NodeState
+        );
+}
+
+
+const ConsumerDBusStubAdapterHelper::StubDispatcherTable& ConsumerDBusStubAdapterInternal::getStubDispatcherTable() {
+    return stubDispatcherTable_;
+}
+
+const CommonAPI::DBus::StubAttributeTable& ConsumerDBusStubAdapterInternal::getStubAttributeTable() {
+    return stubAttributeTable_;
+}
+
+ConsumerDBusStubAdapterInternal::ConsumerDBusStubAdapterInternal(
+        const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+        const std::string& commonApiAddress,
+        const std::string& dbusInterfaceName,
+        const std::string& dbusBusName,
+        const std::string& dbusObjectPath,
+        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+        const std::shared_ptr<CommonAPI::StubBase>& stub):
+        CommonAPI::DBus::DBusStubAdapter(
+                factory,
+                commonApiAddress,
+                dbusInterfaceName,
+                dbusBusName,
+                dbusObjectPath,
+                dbusConnection,
+                false),
+        ConsumerDBusStubAdapterHelper(
+            factory,
+            commonApiAddress,
+            dbusInterfaceName,
+            dbusBusName,
+            dbusObjectPath,
+            dbusConnection,
+            std::dynamic_pointer_cast<ConsumerStub>(stub),
+            false),
+        stubDispatcherTable_({
+            { { "getBootModeAttribute", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getBootModeAttributeStubDispatcher },
+            { { "getRestartReasonAttribute", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getRestartReasonAttributeStubDispatcher },
+            { { "getShutdownReasonAttribute", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getShutdownReasonAttributeStubDispatcher },
+            { { "getWakeUpReasonAttribute", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getWakeUpReasonAttributeStubDispatcher }
+            ,
+            { { "GetAppHealthCount", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getAppHealthCountStubDispatcher },
+            { { "LifecycleRequestComplete", "ui" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::lifecycleRequestCompleteStubDispatcher },
+            { { "GetInterfaceVersion", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getInterfaceVersionStubDispatcher },
+            { { "GetApplicationMode", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getApplicationModeStubDispatcher },
+            { { "UnRegisterSession", "ssi" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::unRegisterSessionStubDispatcher },
+            { { "RegisterSession", "ssii" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::registerSessionStubDispatcher },
+            { { "UnRegisterShutdownClient", "ssu" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::unRegisterShutdownClientStubDispatcher },
+            { { "RegisterShutdownClient", "ssuu" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::registerShutdownClientStubDispatcher },
+            { { "GetNodeState", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getNodeStateStubDispatcher },
+            { { "GetSessionState", "si" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getSessionStateStubDispatcher },
+            { { "SetSessionState", "ssii" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::setSessionStateStubDispatcher }
+            }),
+        stubAttributeTable_() {
+
+    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::NodeStateManager::ConsumerDBusStubAdapterInternal::getConsumerInterfaceVersionStubDispatcher });
+}
+
+const bool ConsumerDBusStubAdapterInternal::hasFreedesktopProperties() {
+    return false;
+}
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.h
new file mode 100644
index 0000000..aacecd0
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerDBusStubAdapter.h
@@ -0,0 +1,182 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Consumer_DBUS_STUB_ADAPTER_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Consumer_DBUS_STUB_ADAPTER_H_
+
+#include <org/genivi/NodeStateManager/ConsumerStub.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/DBus/DBusStubAdapterHelper.h>
+#include <CommonAPI/DBus/DBusStubAdapter.h>
+#include <CommonAPI/DBus/DBusFactory.h>
+#include <CommonAPI/DBus/DBusServicePublisher.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+typedef CommonAPI::DBus::DBusStubAdapterHelper<ConsumerStub> ConsumerDBusStubAdapterHelper;
+
+class ConsumerDBusStubAdapterInternal: public virtual ConsumerStubAdapter, public ConsumerDBusStubAdapterHelper {
+ public:
+    ConsumerDBusStubAdapterInternal(
+            const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+            const std::string& commonApiAddress,
+            const std::string& dbusInterfaceName,
+            const std::string& dbusBusName,
+            const std::string& dbusObjectPath,
+            const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+            const std::shared_ptr<CommonAPI::StubBase>& stub);
+
+    ~ConsumerDBusStubAdapterInternal();
+
+    virtual const bool hasFreedesktopProperties();
+
+
+    void fireNodeApplicationModeEvent(const int32_t& ApplicationModeId);
+    void fireSessionStateChangedEvent(const std::string& SessionStateName, const int32_t& SeatID, const int32_t& SessionState);
+    void fireNodeStateEvent(const int32_t& NodeState);
+
+
+    const ConsumerDBusStubAdapterHelper::StubDispatcherTable& getStubDispatcherTable();
+    const CommonAPI::DBus::StubAttributeTable& getStubAttributeTable();
+
+    void deactivateManagedInstances();
+
+
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        CommonAPI::Version
+        > getConsumerInterfaceVersionStubDispatcher;
+
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        int32_t
+        > getBootModeAttributeStubDispatcher;
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        int32_t
+        > getRestartReasonAttributeStubDispatcher;
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        int32_t
+        > getShutdownReasonAttributeStubDispatcher;
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        ConsumerStub,
+        int32_t
+        > getWakeUpReasonAttributeStubDispatcher;
+
+
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<>,
+    std::tuple<uint32_t>
+    > getAppHealthCountStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<uint32_t, int32_t>,
+    std::tuple<int32_t>
+    > lifecycleRequestCompleteStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<>,
+    std::tuple<uint32_t>
+    > getInterfaceVersionStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<>,
+    std::tuple<int32_t, int32_t>
+    > getApplicationModeStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, int32_t>,
+    std::tuple<int32_t>
+    > unRegisterSessionStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, int32_t, int32_t>,
+    std::tuple<int32_t>
+    > registerSessionStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, uint32_t>,
+    std::tuple<int32_t>
+    > unRegisterShutdownClientStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, uint32_t, uint32_t>,
+    std::tuple<int32_t>
+    > registerShutdownClientStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<>,
+    std::tuple<int32_t, int32_t>
+    > getNodeStateStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, int32_t>,
+    std::tuple<int32_t, int32_t>
+    > getSessionStateStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    ConsumerStub,
+    std::tuple<std::string, std::string, int32_t, int32_t>,
+    std::tuple<int32_t>
+    > setSessionStateStubDispatcher;
+
+
+
+
+ protected:
+    virtual const char* getMethodsDBusIntrospectionXmlData() const;
+
+ private:
+    ConsumerDBusStubAdapterHelper::StubDispatcherTable stubDispatcherTable_;
+    CommonAPI::DBus::StubAttributeTable stubAttributeTable_;
+};
+
+class ConsumerDBusStubAdapter: public ConsumerDBusStubAdapterInternal, public std::enable_shared_from_this<ConsumerDBusStubAdapter> {
+public:
+    ConsumerDBusStubAdapter(
+                         const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                         const std::string& commonApiAddress,
+                         const std::string& dbusInterfaceName,
+                         const std::string& dbusBusName,
+                         const std::string& dbusObjectPath,
+                         const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+                         const std::shared_ptr<CommonAPI::StubBase>& stub) :
+            CommonAPI::DBus::DBusStubAdapter(
+                            factory,
+                            commonApiAddress,
+                            dbusInterfaceName,
+                            dbusBusName,
+                            dbusObjectPath,
+                            dbusConnection,
+                            false),
+            ConsumerDBusStubAdapterInternal(
+                            factory,
+                            commonApiAddress,
+                            dbusInterfaceName,
+                            dbusBusName,
+                            dbusObjectPath,
+                            dbusConnection,
+                            stub) { }
+};
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Consumer_DBUS_STUB_ADAPTER_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxy.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxy.h
new file mode 100644
index 0000000..5b7c14a
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxy.h
@@ -0,0 +1,627 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Consumer_PROXY_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Consumer_PROXY_H_
+
+#include "ConsumerProxyBase.h"
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/AttributeExtension.h>
+#include <CommonAPI/Factory.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+template <typename ... _AttributeExtensions>
+class ConsumerProxy: virtual public Consumer, virtual public ConsumerProxyBase
+, public _AttributeExtensions... {
+public:
+    ConsumerProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
+    ~ConsumerProxy();
+
+    typedef Consumer InterfaceType;
+
+
+    /**
+     * Returns the wrapper class that provides access to the attribute BootMode.
+     */
+    virtual BootModeAttribute& getBootModeAttribute() {
+        return delegate_->getBootModeAttribute();
+    }
+    /**
+     * Returns the wrapper class that provides access to the attribute RestartReason.
+     */
+    virtual RestartReasonAttribute& getRestartReasonAttribute() {
+        return delegate_->getRestartReasonAttribute();
+    }
+    /**
+     * Returns the wrapper class that provides access to the attribute ShutdownReason.
+     */
+    virtual ShutdownReasonAttribute& getShutdownReasonAttribute() {
+        return delegate_->getShutdownReasonAttribute();
+    }
+    /**
+     * Returns the wrapper class that provides access to the attribute WakeUpReason.
+     */
+    virtual WakeUpReasonAttribute& getWakeUpReasonAttribute() {
+        return delegate_->getWakeUpReasonAttribute();
+    }
+
+    /**
+     * Returns the wrapper class that provides access to the broadcast NodeApplicationMode.
+     */
+    virtual NodeApplicationModeEvent& getNodeApplicationModeEvent() {
+        return delegate_->getNodeApplicationModeEvent();
+    }
+    /**
+     * Returns the wrapper class that provides access to the broadcast SessionStateChanged.
+     */
+    virtual SessionStateChangedEvent& getSessionStateChangedEvent() {
+        return delegate_->getSessionStateChangedEvent();
+    }
+    /**
+     * Returns the wrapper class that provides access to the broadcast NodeState.
+     */
+    virtual NodeStateEvent& getNodeStateEvent() {
+        return delegate_->getNodeStateEvent();
+    }
+
+    /**
+     * Calls GetAppHealthCount with synchronous semantics.
+     * 
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void GetAppHealthCount(CommonAPI::CallStatus& callStatus, uint32_t& Count);
+    /**
+     * Calls GetAppHealthCount with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> GetAppHealthCountAsync(GetAppHealthCountAsyncCallback callback);
+    /**
+     * Calls LifecycleRequestComplete with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void LifecycleRequestComplete(const uint32_t& RequestId, const int32_t& Status, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    /**
+     * Calls LifecycleRequestComplete with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> LifecycleRequestCompleteAsync(const uint32_t& RequestId, const int32_t& Status, LifecycleRequestCompleteAsyncCallback callback);
+    /**
+     * Calls GetInterfaceVersion with synchronous semantics.
+     * 
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void GetInterfaceVersion(CommonAPI::CallStatus& callStatus, uint32_t& Version);
+    /**
+     * Calls GetInterfaceVersion with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> GetInterfaceVersionAsync(GetInterfaceVersionAsyncCallback callback);
+    /**
+     * Calls GetApplicationMode with synchronous semantics.
+     * 
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void GetApplicationMode(CommonAPI::CallStatus& callStatus, int32_t& ErrorCode, int32_t& ApplicationModeId);
+    /**
+     * Calls GetApplicationMode with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> GetApplicationModeAsync(GetApplicationModeAsyncCallback callback);
+    /**
+     * Calls UnRegisterSession with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void UnRegisterSession(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    /**
+     * Calls UnRegisterSession with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> UnRegisterSessionAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, UnRegisterSessionAsyncCallback callback);
+    /**
+     * Calls RegisterSession with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void RegisterSession(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, const int32_t& SessionState, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    /**
+     * Calls RegisterSession with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> RegisterSessionAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, const int32_t& SessionState, RegisterSessionAsyncCallback callback);
+    /**
+     * Calls UnRegisterShutdownClient with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void UnRegisterShutdownClient(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    /**
+     * Calls UnRegisterShutdownClient with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> UnRegisterShutdownClientAsync(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, UnRegisterShutdownClientAsyncCallback callback);
+    /**
+     * Calls RegisterShutdownClient with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void RegisterShutdownClient(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, const uint32_t& TimeoutMs, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    /**
+     * Calls RegisterShutdownClient with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> RegisterShutdownClientAsync(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, const uint32_t& TimeoutMs, RegisterShutdownClientAsyncCallback callback);
+    /**
+     * Calls GetNodeState with synchronous semantics.
+     * 
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void GetNodeState(CommonAPI::CallStatus& callStatus, int32_t& ErrorCode, int32_t& NodeStateId);
+    /**
+     * Calls GetNodeState with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> GetNodeStateAsync(GetNodeStateAsyncCallback callback);
+    /**
+     * Calls GetSessionState with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void GetSessionState(const std::string& SessionName, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& SessionState, int32_t& ErrorCode);
+    /**
+     * Calls GetSessionState with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> GetSessionStateAsync(const std::string& SessionName, const int32_t& SeatID, GetSessionStateAsyncCallback callback);
+    /**
+     * Calls SetSessionState with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void SetSessionState(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SessionState, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    /**
+     * Calls SetSessionState with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> SetSessionStateAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SessionState, const int32_t& SeatID, SetSessionStateAsyncCallback callback);
+
+
+    /**
+     * Returns the CommonAPI address of the remote partner this proxy communicates with.
+     */
+    virtual std::string getAddress() const;
+
+    /**
+     * Returns the domain of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getDomain() const;
+
+    /** 
+     * Returns the service ID of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getServiceId() const;
+
+    /**
+     * Returns the instance ID of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getInstanceId() const;
+
+    /**
+     * Returns true if the remote partner for this proxy is currently known to be available.
+     */
+    virtual bool isAvailable() const;
+
+    /**
+     * Returns true if the remote partner for this proxy is available.
+     */
+    virtual bool isAvailableBlocking() const;
+
+    /**
+     * Returns the wrapper class that is used to (de-)register for notifications about
+     * the availability of the remote partner of this proxy.
+     */
+    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();
+
+    /**
+     * Returns the wrapper class that is used to access version information of the remote
+     * partner of this proxy.
+     */
+    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();
+
+ private:
+    std::shared_ptr<ConsumerProxyBase> delegate_;
+};
+
+#ifdef WIN32
+    typedef ConsumerProxy<CommonAPI::WINDummyAttributeExtension<CommonAPI::WINDummyAttribute>> ConsumerProxyDefault;
+#else
+    typedef ConsumerProxy<> ConsumerProxyDefault;
+#endif
+
+namespace ConsumerExtensions {
+    template <template <typename > class _ExtensionType>
+    class BootModeAttributeExtension {
+     public:
+        typedef _ExtensionType<ConsumerProxyBase::BootModeAttribute> extension_type;
+    
+        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConsumerProxyBase::BootModeAttribute>, extension_type>::value,
+                      "Not CommonAPI Attribute Extension!");
+    #ifdef WIN32
+        BootModeAttributeExtension() {}
+    #endif
+    
+        BootModeAttributeExtension(ConsumerProxyBase& proxy): attributeExtension_(proxy.getBootModeAttribute()) {
+        }
+    
+        inline extension_type& getBootModeAttributeExtension() {
+            return attributeExtension_;
+        }
+    
+     private:
+        extension_type attributeExtension_;
+    };
+
+    template <template <typename > class _ExtensionType>
+    class RestartReasonAttributeExtension {
+     public:
+        typedef _ExtensionType<ConsumerProxyBase::RestartReasonAttribute> extension_type;
+    
+        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConsumerProxyBase::RestartReasonAttribute>, extension_type>::value,
+                      "Not CommonAPI Attribute Extension!");
+    #ifdef WIN32
+        RestartReasonAttributeExtension() {}
+    #endif
+    
+        RestartReasonAttributeExtension(ConsumerProxyBase& proxy): attributeExtension_(proxy.getRestartReasonAttribute()) {
+        }
+    
+        inline extension_type& getRestartReasonAttributeExtension() {
+            return attributeExtension_;
+        }
+    
+     private:
+        extension_type attributeExtension_;
+    };
+
+    template <template <typename > class _ExtensionType>
+    class ShutdownReasonAttributeExtension {
+     public:
+        typedef _ExtensionType<ConsumerProxyBase::ShutdownReasonAttribute> extension_type;
+    
+        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConsumerProxyBase::ShutdownReasonAttribute>, extension_type>::value,
+                      "Not CommonAPI Attribute Extension!");
+    #ifdef WIN32
+        ShutdownReasonAttributeExtension() {}
+    #endif
+    
+        ShutdownReasonAttributeExtension(ConsumerProxyBase& proxy): attributeExtension_(proxy.getShutdownReasonAttribute()) {
+        }
+    
+        inline extension_type& getShutdownReasonAttributeExtension() {
+            return attributeExtension_;
+        }
+    
+     private:
+        extension_type attributeExtension_;
+    };
+
+    template <template <typename > class _ExtensionType>
+    class WakeUpReasonAttributeExtension {
+     public:
+        typedef _ExtensionType<ConsumerProxyBase::WakeUpReasonAttribute> extension_type;
+    
+        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConsumerProxyBase::WakeUpReasonAttribute>, extension_type>::value,
+                      "Not CommonAPI Attribute Extension!");
+    #ifdef WIN32
+        WakeUpReasonAttributeExtension() {}
+    #endif
+    
+        WakeUpReasonAttributeExtension(ConsumerProxyBase& proxy): attributeExtension_(proxy.getWakeUpReasonAttribute()) {
+        }
+    
+        inline extension_type& getWakeUpReasonAttributeExtension() {
+            return attributeExtension_;
+        }
+    
+     private:
+        extension_type attributeExtension_;
+    };
+
+} // namespace ConsumerExtensions
+
+//
+// ConsumerProxy Implementation
+//
+template <typename ... _AttributeExtensions>
+ConsumerProxy<_AttributeExtensions...>::ConsumerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
+        _AttributeExtensions(*(std::dynamic_pointer_cast<ConsumerProxyBase>(delegate)))...,
+        delegate_(std::dynamic_pointer_cast<ConsumerProxyBase>(delegate)) {
+}
+
+template <typename ... _AttributeExtensions>
+ConsumerProxy<_AttributeExtensions...>::~ConsumerProxy() {
+}
+
+template <typename ... _AttributeExtensions>
+void ConsumerProxy<_AttributeExtensions...>::GetAppHealthCount(CommonAPI::CallStatus& callStatus, uint32_t& Count) {
+    delegate_->GetAppHealthCount(callStatus, Count);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> ConsumerProxy<_AttributeExtensions...>::GetAppHealthCountAsync(GetAppHealthCountAsyncCallback callback) {
+    return delegate_->GetAppHealthCountAsync(callback);
+}
+template <typename ... _AttributeExtensions>
+void ConsumerProxy<_AttributeExtensions...>::LifecycleRequestComplete(const uint32_t& RequestId, const int32_t& Status, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    delegate_->LifecycleRequestComplete(RequestId, Status, callStatus, ErrorCode);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> ConsumerProxy<_AttributeExtensions...>::LifecycleRequestCompleteAsync(const uint32_t& RequestId, const int32_t& Status, LifecycleRequestCompleteAsyncCallback callback) {
+    return delegate_->LifecycleRequestCompleteAsync(RequestId, Status, callback);
+}
+template <typename ... _AttributeExtensions>
+void ConsumerProxy<_AttributeExtensions...>::GetInterfaceVersion(CommonAPI::CallStatus& callStatus, uint32_t& Version) {
+    delegate_->GetInterfaceVersion(callStatus, Version);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> ConsumerProxy<_AttributeExtensions...>::GetInterfaceVersionAsync(GetInterfaceVersionAsyncCallback callback) {
+    return delegate_->GetInterfaceVersionAsync(callback);
+}
+template <typename ... _AttributeExtensions>
+void ConsumerProxy<_AttributeExtensions...>::GetApplicationMode(CommonAPI::CallStatus& callStatus, int32_t& ErrorCode, int32_t& ApplicationModeId) {
+    delegate_->GetApplicationMode(callStatus, ErrorCode, ApplicationModeId);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> ConsumerProxy<_AttributeExtensions...>::GetApplicationModeAsync(GetApplicationModeAsyncCallback callback) {
+    return delegate_->GetApplicationModeAsync(callback);
+}
+template <typename ... _AttributeExtensions>
+void ConsumerProxy<_AttributeExtensions...>::UnRegisterSession(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    delegate_->UnRegisterSession(SessionName, SessionOwner, SeatID, callStatus, ErrorCode);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> ConsumerProxy<_AttributeExtensions...>::UnRegisterSessionAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, UnRegisterSessionAsyncCallback callback) {
+    return delegate_->UnRegisterSessionAsync(SessionName, SessionOwner, SeatID, callback);
+}
+template <typename ... _AttributeExtensions>
+void ConsumerProxy<_AttributeExtensions...>::RegisterSession(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, const int32_t& SessionState, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    delegate_->RegisterSession(SessionName, SessionOwner, SeatID, SessionState, callStatus, ErrorCode);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> ConsumerProxy<_AttributeExtensions...>::RegisterSessionAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, const int32_t& SessionState, RegisterSessionAsyncCallback callback) {
+    return delegate_->RegisterSessionAsync(SessionName, SessionOwner, SeatID, SessionState, callback);
+}
+template <typename ... _AttributeExtensions>
+void ConsumerProxy<_AttributeExtensions...>::UnRegisterShutdownClient(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    delegate_->UnRegisterShutdownClient(BusName, ObjName, ShutdownMode, callStatus, ErrorCode);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> ConsumerProxy<_AttributeExtensions...>::UnRegisterShutdownClientAsync(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, UnRegisterShutdownClientAsyncCallback callback) {
+    return delegate_->UnRegisterShutdownClientAsync(BusName, ObjName, ShutdownMode, callback);
+}
+template <typename ... _AttributeExtensions>
+void ConsumerProxy<_AttributeExtensions...>::RegisterShutdownClient(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, const uint32_t& TimeoutMs, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    delegate_->RegisterShutdownClient(BusName, ObjName, ShutdownMode, TimeoutMs, callStatus, ErrorCode);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> ConsumerProxy<_AttributeExtensions...>::RegisterShutdownClientAsync(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, const uint32_t& TimeoutMs, RegisterShutdownClientAsyncCallback callback) {
+    return delegate_->RegisterShutdownClientAsync(BusName, ObjName, ShutdownMode, TimeoutMs, callback);
+}
+template <typename ... _AttributeExtensions>
+void ConsumerProxy<_AttributeExtensions...>::GetNodeState(CommonAPI::CallStatus& callStatus, int32_t& ErrorCode, int32_t& NodeStateId) {
+    delegate_->GetNodeState(callStatus, ErrorCode, NodeStateId);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> ConsumerProxy<_AttributeExtensions...>::GetNodeStateAsync(GetNodeStateAsyncCallback callback) {
+    return delegate_->GetNodeStateAsync(callback);
+}
+template <typename ... _AttributeExtensions>
+void ConsumerProxy<_AttributeExtensions...>::GetSessionState(const std::string& SessionName, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& SessionState, int32_t& ErrorCode) {
+    delegate_->GetSessionState(SessionName, SeatID, callStatus, SessionState, ErrorCode);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> ConsumerProxy<_AttributeExtensions...>::GetSessionStateAsync(const std::string& SessionName, const int32_t& SeatID, GetSessionStateAsyncCallback callback) {
+    return delegate_->GetSessionStateAsync(SessionName, SeatID, callback);
+}
+template <typename ... _AttributeExtensions>
+void ConsumerProxy<_AttributeExtensions...>::SetSessionState(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SessionState, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    delegate_->SetSessionState(SessionName, SessionOwner, SessionState, SeatID, callStatus, ErrorCode);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> ConsumerProxy<_AttributeExtensions...>::SetSessionStateAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SessionState, const int32_t& SeatID, SetSessionStateAsyncCallback callback) {
+    return delegate_->SetSessionStateAsync(SessionName, SessionOwner, SessionState, SeatID, callback);
+}
+
+template <typename ... _AttributeExtensions>
+std::string ConsumerProxy<_AttributeExtensions...>::getAddress() const {
+    return delegate_->getAddress();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& ConsumerProxy<_AttributeExtensions...>::getDomain() const {
+    return delegate_->getDomain();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& ConsumerProxy<_AttributeExtensions...>::getServiceId() const {
+    return delegate_->getServiceId();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& ConsumerProxy<_AttributeExtensions...>::getInstanceId() const {
+    return delegate_->getInstanceId();
+}
+
+template <typename ... _AttributeExtensions>
+bool ConsumerProxy<_AttributeExtensions...>::isAvailable() const {
+    return delegate_->isAvailable();
+}
+
+template <typename ... _AttributeExtensions>
+bool ConsumerProxy<_AttributeExtensions...>::isAvailableBlocking() const {
+    return delegate_->isAvailableBlocking();
+}
+
+template <typename ... _AttributeExtensions>
+CommonAPI::ProxyStatusEvent& ConsumerProxy<_AttributeExtensions...>::getProxyStatusEvent() {
+    return delegate_->getProxyStatusEvent();
+}
+
+template <typename ... _AttributeExtensions>
+CommonAPI::InterfaceVersionAttribute& ConsumerProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
+    return delegate_->getInterfaceVersionAttribute();
+}
+
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+namespace CommonAPI {
+template<template<typename > class _AttributeExtension>
+struct DefaultAttributeProxyFactoryHelper<org::genivi::NodeStateManager::ConsumerProxy,
+    _AttributeExtension> {
+    typedef typename org::genivi::NodeStateManager::ConsumerProxy<
+            org::genivi::NodeStateManager::ConsumerExtensions::BootModeAttributeExtension<_AttributeExtension>, 
+            org::genivi::NodeStateManager::ConsumerExtensions::RestartReasonAttributeExtension<_AttributeExtension>, 
+            org::genivi::NodeStateManager::ConsumerExtensions::ShutdownReasonAttributeExtension<_AttributeExtension>, 
+            org::genivi::NodeStateManager::ConsumerExtensions::WakeUpReasonAttributeExtension<_AttributeExtension>
+    > class_t;
+};
+}
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Consumer_PROXY_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxyBase.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxyBase.h
new file mode 100644
index 0000000..b0afe99
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerProxyBase.h
@@ -0,0 +1,95 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Consumer_PROXY_BASE_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Consumer_PROXY_BASE_H_
+
+#include "Consumer.h"
+
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <vector>
+
+#include <CommonAPI/Attribute.h>
+#include <CommonAPI/Event.h>
+#include <CommonAPI/Proxy.h>
+#include <functional>
+#include <future>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+class ConsumerProxyBase: virtual public CommonAPI::Proxy {
+ public:
+    typedef CommonAPI::ReadonlyAttribute<int32_t> BootModeAttribute;
+    typedef CommonAPI::ReadonlyAttribute<int32_t> RestartReasonAttribute;
+    typedef CommonAPI::ReadonlyAttribute<int32_t> ShutdownReasonAttribute;
+    typedef CommonAPI::ReadonlyAttribute<int32_t> WakeUpReasonAttribute;
+    typedef CommonAPI::Event<int32_t> NodeApplicationModeEvent;
+    typedef CommonAPI::Event<std::string, int32_t, int32_t> SessionStateChangedEvent;
+    typedef CommonAPI::Event<int32_t> NodeStateEvent;
+
+    typedef std::function<void(const CommonAPI::CallStatus&, const uint32_t&)> GetAppHealthCountAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const int32_t&)> LifecycleRequestCompleteAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const uint32_t&)> GetInterfaceVersionAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const int32_t&, const int32_t&)> GetApplicationModeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const int32_t&)> UnRegisterSessionAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const int32_t&)> RegisterSessionAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const int32_t&)> UnRegisterShutdownClientAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const int32_t&)> RegisterShutdownClientAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const int32_t&, const int32_t&)> GetNodeStateAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const int32_t&, const int32_t&)> GetSessionStateAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const int32_t&)> SetSessionStateAsyncCallback;
+
+    virtual BootModeAttribute& getBootModeAttribute() = 0;
+    virtual RestartReasonAttribute& getRestartReasonAttribute() = 0;
+    virtual ShutdownReasonAttribute& getShutdownReasonAttribute() = 0;
+    virtual WakeUpReasonAttribute& getWakeUpReasonAttribute() = 0;
+
+    virtual NodeApplicationModeEvent& getNodeApplicationModeEvent() = 0;
+    virtual SessionStateChangedEvent& getSessionStateChangedEvent() = 0;
+    virtual NodeStateEvent& getNodeStateEvent() = 0;
+
+    virtual void GetAppHealthCount(CommonAPI::CallStatus& callStatus, uint32_t& Count) = 0;
+    virtual std::future<CommonAPI::CallStatus> GetAppHealthCountAsync(GetAppHealthCountAsyncCallback callback) = 0;
+    virtual void LifecycleRequestComplete(const uint32_t& RequestId, const int32_t& Status, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) = 0;
+    virtual std::future<CommonAPI::CallStatus> LifecycleRequestCompleteAsync(const uint32_t& RequestId, const int32_t& Status, LifecycleRequestCompleteAsyncCallback callback) = 0;
+    virtual void GetInterfaceVersion(CommonAPI::CallStatus& callStatus, uint32_t& Version) = 0;
+    virtual std::future<CommonAPI::CallStatus> GetInterfaceVersionAsync(GetInterfaceVersionAsyncCallback callback) = 0;
+    virtual void GetApplicationMode(CommonAPI::CallStatus& callStatus, int32_t& ErrorCode, int32_t& ApplicationModeId) = 0;
+    virtual std::future<CommonAPI::CallStatus> GetApplicationModeAsync(GetApplicationModeAsyncCallback callback) = 0;
+    virtual void UnRegisterSession(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) = 0;
+    virtual std::future<CommonAPI::CallStatus> UnRegisterSessionAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, UnRegisterSessionAsyncCallback callback) = 0;
+    virtual void RegisterSession(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, const int32_t& SessionState, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) = 0;
+    virtual std::future<CommonAPI::CallStatus> RegisterSessionAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SeatID, const int32_t& SessionState, RegisterSessionAsyncCallback callback) = 0;
+    virtual void UnRegisterShutdownClient(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) = 0;
+    virtual std::future<CommonAPI::CallStatus> UnRegisterShutdownClientAsync(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, UnRegisterShutdownClientAsyncCallback callback) = 0;
+    virtual void RegisterShutdownClient(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, const uint32_t& TimeoutMs, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) = 0;
+    virtual std::future<CommonAPI::CallStatus> RegisterShutdownClientAsync(const std::string& BusName, const std::string& ObjName, const uint32_t& ShutdownMode, const uint32_t& TimeoutMs, RegisterShutdownClientAsyncCallback callback) = 0;
+    virtual void GetNodeState(CommonAPI::CallStatus& callStatus, int32_t& ErrorCode, int32_t& NodeStateId) = 0;
+    virtual std::future<CommonAPI::CallStatus> GetNodeStateAsync(GetNodeStateAsyncCallback callback) = 0;
+    virtual void GetSessionState(const std::string& SessionName, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& SessionState, int32_t& ErrorCode) = 0;
+    virtual std::future<CommonAPI::CallStatus> GetSessionStateAsync(const std::string& SessionName, const int32_t& SeatID, GetSessionStateAsyncCallback callback) = 0;
+    virtual void SetSessionState(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SessionState, const int32_t& SeatID, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) = 0;
+    virtual std::future<CommonAPI::CallStatus> SetSessionStateAsync(const std::string& SessionName, const std::string& SessionOwner, const int32_t& SessionState, const int32_t& SeatID, SetSessionStateAsyncCallback callback) = 0;
+};
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Consumer_PROXY_BASE_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStub.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStub.h
new file mode 100644
index 0000000..107749e
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStub.h
@@ -0,0 +1,152 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Consumer_STUB_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Consumer_STUB_H_
+
+
+
+
+#include "Consumer.h"
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <unordered_set>
+#include <vector>
+
+#include <CommonAPI/Stub.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+/**
+ * Receives messages from remote and handles all dispatching of deserialized calls
+ * to a stub for the service Consumer. Also provides means to send broadcasts
+ * and attribute-changed-notifications of observable attributes as defined by this service.
+ * An application developer should not need to bother with this class.
+ */
+class ConsumerStubAdapter: virtual public CommonAPI::StubAdapter, public Consumer {
+ public:
+
+    /**
+     * Sends a broadcast event for NodeApplicationMode. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireNodeApplicationModeEvent(const int32_t& ApplicationModeId) = 0;
+    /**
+     * Sends a broadcast event for SessionStateChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireSessionStateChangedEvent(const std::string& SessionStateName, const int32_t& SeatID, const int32_t& SessionState) = 0;
+    /**
+     * Sends a broadcast event for NodeState. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireNodeStateEvent(const int32_t& NodeState) = 0;
+
+
+    virtual void deactivateManagedInstances() = 0;
+protected:
+    /**
+     * Defines properties for storing the ClientIds of clients / proxies that have
+     * subscribed to the selective broadcasts
+     */
+};
+
+
+/**
+ * Defines the necessary callbacks to handle remote set events related to the attributes
+ * defined in the IDL description for Consumer.
+ * For each attribute two callbacks are defined:
+ * - a verification callback that allows to verify the requested value and to prevent setting
+ *   e.g. an invalid value ("onRemoteSet<AttributeName>").
+ * - an action callback to do local work after the attribute value has been changed
+ *   ("onRemote<AttributeName>Changed").
+ *
+ * This class and the one below are the ones an application developer needs to have
+ * a look at if he wants to implement a service.
+ */
+class ConsumerStubRemoteEvent {
+ public:
+    virtual ~ConsumerStubRemoteEvent() { }
+
+
+
+
+
+};
+
+
+/**
+ * Defines the interface that must be implemented by any class that should provide
+ * the service Consumer to remote clients.
+ * This class and the one above are the ones an application developer needs to have
+ * a look at if he wants to implement a service.
+ */
+class ConsumerStub: public virtual CommonAPI::Stub<ConsumerStubAdapter, ConsumerStubRemoteEvent> {
+public:
+    virtual ~ConsumerStub() { }
+    virtual const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
+
+    /// Provides getter access to the attribute BootMode
+    virtual const int32_t& getBootModeAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
+    /// Provides getter access to the attribute RestartReason
+    virtual const int32_t& getRestartReasonAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
+    /// Provides getter access to the attribute ShutdownReason
+    virtual const int32_t& getShutdownReasonAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
+    /// Provides getter access to the attribute WakeUpReason
+    virtual const int32_t& getWakeUpReasonAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
+
+    /// This is the method that will be called on remote calls on the method GetAppHealthCount.
+    virtual void GetAppHealthCount(const std::shared_ptr<CommonAPI::ClientId> clientId, uint32_t& Count) = 0;
+    /// This is the method that will be called on remote calls on the method LifecycleRequestComplete.
+    virtual void LifecycleRequestComplete(const std::shared_ptr<CommonAPI::ClientId> clientId, uint32_t RequestId, int32_t Status, int32_t& ErrorCode) = 0;
+    /// This is the method that will be called on remote calls on the method GetInterfaceVersion.
+    virtual void GetInterfaceVersion(const std::shared_ptr<CommonAPI::ClientId> clientId, uint32_t& Version) = 0;
+    /// This is the method that will be called on remote calls on the method GetApplicationMode.
+    virtual void GetApplicationMode(const std::shared_ptr<CommonAPI::ClientId> clientId, int32_t& ErrorCode, int32_t& ApplicationModeId) = 0;
+    /// This is the method that will be called on remote calls on the method UnRegisterSession.
+    virtual void UnRegisterSession(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string SessionName, std::string SessionOwner, int32_t SeatID, int32_t& ErrorCode) = 0;
+    /// This is the method that will be called on remote calls on the method RegisterSession.
+    virtual void RegisterSession(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string SessionName, std::string SessionOwner, int32_t SeatID, int32_t SessionState, int32_t& ErrorCode) = 0;
+    /// This is the method that will be called on remote calls on the method UnRegisterShutdownClient.
+    virtual void UnRegisterShutdownClient(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string BusName, std::string ObjName, uint32_t ShutdownMode, int32_t& ErrorCode) = 0;
+    /// This is the method that will be called on remote calls on the method RegisterShutdownClient.
+    virtual void RegisterShutdownClient(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string BusName, std::string ObjName, uint32_t ShutdownMode, uint32_t TimeoutMs, int32_t& ErrorCode) = 0;
+    /// This is the method that will be called on remote calls on the method GetNodeState.
+    virtual void GetNodeState(const std::shared_ptr<CommonAPI::ClientId> clientId, int32_t& ErrorCode, int32_t& NodeStateId) = 0;
+    /// This is the method that will be called on remote calls on the method GetSessionState.
+    virtual void GetSessionState(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string SessionName, int32_t SeatID, int32_t& SessionState, int32_t& ErrorCode) = 0;
+    /// This is the method that will be called on remote calls on the method SetSessionState.
+    virtual void SetSessionState(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string SessionName, std::string SessionOwner, int32_t SessionState, int32_t SeatID, int32_t& ErrorCode) = 0;
+    /// Sends a broadcast event for NodeApplicationMode.
+    virtual void fireNodeApplicationModeEvent(const int32_t& ApplicationModeId) = 0;
+    /// Sends a broadcast event for SessionStateChanged.
+    virtual void fireSessionStateChangedEvent(const std::string& SessionStateName, const int32_t& SeatID, const int32_t& SessionState) = 0;
+    /// Sends a broadcast event for NodeState.
+    virtual void fireNodeStateEvent(const int32_t& NodeState) = 0;
+
+    using CommonAPI::Stub<ConsumerStubAdapter, ConsumerStubRemoteEvent>::initStubAdapter;
+    typedef CommonAPI::Stub<ConsumerStubAdapter, ConsumerStubRemoteEvent>::StubAdapterType StubAdapterType;
+    typedef CommonAPI::Stub<ConsumerStubAdapter, ConsumerStubRemoteEvent>::RemoteEventHandlerType RemoteEventHandlerType;
+    typedef ConsumerStubRemoteEvent RemoteEventType;
+    typedef Consumer StubInterface;
+};
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Consumer_STUB_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.cpp b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.cpp
new file mode 100644
index 0000000..18edb79
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.cpp
@@ -0,0 +1,239 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+#include <org/genivi/NodeStateManager/ConsumerStubDefault.h>
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+ConsumerStubDefault::ConsumerStubDefault():
+        remoteEventHandler_(this),
+        interfaceVersion_(Consumer::getInterfaceVersion()) {
+}
+
+const CommonAPI::Version& ConsumerStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) {
+    return interfaceVersion_;
+}
+
+ConsumerStubRemoteEvent* ConsumerStubDefault::initStubAdapter(const std::shared_ptr<ConsumerStubAdapter>& stubAdapter) {
+    CommonAPI::Stub<ConsumerStubAdapter, ConsumerStubRemoteEvent>::stubAdapter_ = stubAdapter;
+    return &remoteEventHandler_;
+}
+
+const int32_t& ConsumerStubDefault::getBootModeAttribute() {
+    return bootModeAttributeValue_;
+}
+
+const int32_t& ConsumerStubDefault::getBootModeAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId) {
+    return getBootModeAttribute();
+}
+
+void ConsumerStubDefault::setBootModeAttribute(int32_t value) {
+    trySetBootModeAttribute(std::move(value));
+}
+
+bool ConsumerStubDefault::trySetBootModeAttribute(int32_t value) {
+    if (!validateBootModeAttributeRequestedValue(value))
+        return false;
+
+    const bool valueChanged = (bootModeAttributeValue_ != value);
+    bootModeAttributeValue_ = std::move(value);
+    return valueChanged;
+}
+
+bool ConsumerStubDefault::validateBootModeAttributeRequestedValue(const int32_t& value) {
+    return true;
+}
+
+
+const int32_t& ConsumerStubDefault::getRestartReasonAttribute() {
+    return restartReasonAttributeValue_;
+}
+
+const int32_t& ConsumerStubDefault::getRestartReasonAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId) {
+    return getRestartReasonAttribute();
+}
+
+void ConsumerStubDefault::setRestartReasonAttribute(int32_t value) {
+    trySetRestartReasonAttribute(std::move(value));
+}
+
+bool ConsumerStubDefault::trySetRestartReasonAttribute(int32_t value) {
+    if (!validateRestartReasonAttributeRequestedValue(value))
+        return false;
+
+    const bool valueChanged = (restartReasonAttributeValue_ != value);
+    restartReasonAttributeValue_ = std::move(value);
+    return valueChanged;
+}
+
+bool ConsumerStubDefault::validateRestartReasonAttributeRequestedValue(const int32_t& value) {
+    return true;
+}
+
+
+const int32_t& ConsumerStubDefault::getShutdownReasonAttribute() {
+    return shutdownReasonAttributeValue_;
+}
+
+const int32_t& ConsumerStubDefault::getShutdownReasonAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId) {
+    return getShutdownReasonAttribute();
+}
+
+void ConsumerStubDefault::setShutdownReasonAttribute(int32_t value) {
+    trySetShutdownReasonAttribute(std::move(value));
+}
+
+bool ConsumerStubDefault::trySetShutdownReasonAttribute(int32_t value) {
+    if (!validateShutdownReasonAttributeRequestedValue(value))
+        return false;
+
+    const bool valueChanged = (shutdownReasonAttributeValue_ != value);
+    shutdownReasonAttributeValue_ = std::move(value);
+    return valueChanged;
+}
+
+bool ConsumerStubDefault::validateShutdownReasonAttributeRequestedValue(const int32_t& value) {
+    return true;
+}
+
+
+const int32_t& ConsumerStubDefault::getWakeUpReasonAttribute() {
+    return wakeUpReasonAttributeValue_;
+}
+
+const int32_t& ConsumerStubDefault::getWakeUpReasonAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId) {
+    return getWakeUpReasonAttribute();
+}
+
+void ConsumerStubDefault::setWakeUpReasonAttribute(int32_t value) {
+    trySetWakeUpReasonAttribute(std::move(value));
+}
+
+bool ConsumerStubDefault::trySetWakeUpReasonAttribute(int32_t value) {
+    if (!validateWakeUpReasonAttributeRequestedValue(value))
+        return false;
+
+    const bool valueChanged = (wakeUpReasonAttributeValue_ != value);
+    wakeUpReasonAttributeValue_ = std::move(value);
+    return valueChanged;
+}
+
+bool ConsumerStubDefault::validateWakeUpReasonAttributeRequestedValue(const int32_t& value) {
+    return true;
+}
+
+
+
+void ConsumerStubDefault::GetAppHealthCount(const std::shared_ptr<CommonAPI::ClientId> clientId, uint32_t& Count) {
+    // Call old style methods in default 
+    GetAppHealthCount(Count);
+}
+void ConsumerStubDefault::GetAppHealthCount(uint32_t& Count) {
+    // No operation in default
+}
+
+void ConsumerStubDefault::LifecycleRequestComplete(const std::shared_ptr<CommonAPI::ClientId> clientId, uint32_t RequestId, int32_t Status, int32_t& ErrorCode) {
+    // Call old style methods in default 
+    LifecycleRequestComplete(RequestId, Status, ErrorCode);
+}
+void ConsumerStubDefault::LifecycleRequestComplete(uint32_t RequestId, int32_t Status, int32_t& ErrorCode) {
+    // No operation in default
+}
+
+void ConsumerStubDefault::GetInterfaceVersion(const std::shared_ptr<CommonAPI::ClientId> clientId, uint32_t& Version) {
+    // Call old style methods in default 
+    GetInterfaceVersion(Version);
+}
+void ConsumerStubDefault::GetInterfaceVersion(uint32_t& Version) {
+    // No operation in default
+}
+
+void ConsumerStubDefault::GetApplicationMode(const std::shared_ptr<CommonAPI::ClientId> clientId, int32_t& ErrorCode, int32_t& ApplicationModeId) {
+    // Call old style methods in default 
+    GetApplicationMode(ErrorCode, ApplicationModeId);
+}
+void ConsumerStubDefault::GetApplicationMode(int32_t& ErrorCode, int32_t& ApplicationModeId) {
+    // No operation in default
+}
+
+void ConsumerStubDefault::UnRegisterSession(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string SessionName, std::string SessionOwner, int32_t SeatID, int32_t& ErrorCode) {
+    // Call old style methods in default 
+    UnRegisterSession(SessionName, SessionOwner, SeatID, ErrorCode);
+}
+void ConsumerStubDefault::UnRegisterSession(std::string SessionName, std::string SessionOwner, int32_t SeatID, int32_t& ErrorCode) {
+    // No operation in default
+}
+
+void ConsumerStubDefault::RegisterSession(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string SessionName, std::string SessionOwner, int32_t SeatID, int32_t SessionState, int32_t& ErrorCode) {
+    // Call old style methods in default 
+    RegisterSession(SessionName, SessionOwner, SeatID, SessionState, ErrorCode);
+}
+void ConsumerStubDefault::RegisterSession(std::string SessionName, std::string SessionOwner, int32_t SeatID, int32_t SessionState, int32_t& ErrorCode) {
+    // No operation in default
+}
+
+void ConsumerStubDefault::UnRegisterShutdownClient(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string BusName, std::string ObjName, uint32_t ShutdownMode, int32_t& ErrorCode) {
+    // Call old style methods in default 
+    UnRegisterShutdownClient(BusName, ObjName, ShutdownMode, ErrorCode);
+}
+void ConsumerStubDefault::UnRegisterShutdownClient(std::string BusName, std::string ObjName, uint32_t ShutdownMode, int32_t& ErrorCode) {
+    // No operation in default
+}
+
+void ConsumerStubDefault::RegisterShutdownClient(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string BusName, std::string ObjName, uint32_t ShutdownMode, uint32_t TimeoutMs, int32_t& ErrorCode) {
+    // Call old style methods in default 
+    RegisterShutdownClient(BusName, ObjName, ShutdownMode, TimeoutMs, ErrorCode);
+}
+void ConsumerStubDefault::RegisterShutdownClient(std::string BusName, std::string ObjName, uint32_t ShutdownMode, uint32_t TimeoutMs, int32_t& ErrorCode) {
+    // No operation in default
+}
+
+void ConsumerStubDefault::GetNodeState(const std::shared_ptr<CommonAPI::ClientId> clientId, int32_t& ErrorCode, int32_t& NodeStateId) {
+    // Call old style methods in default 
+    GetNodeState(ErrorCode, NodeStateId);
+}
+void ConsumerStubDefault::GetNodeState(int32_t& ErrorCode, int32_t& NodeStateId) {
+    // No operation in default
+}
+
+void ConsumerStubDefault::GetSessionState(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string SessionName, int32_t SeatID, int32_t& SessionState, int32_t& ErrorCode) {
+    // Call old style methods in default 
+    GetSessionState(SessionName, SeatID, SessionState, ErrorCode);
+}
+void ConsumerStubDefault::GetSessionState(std::string SessionName, int32_t SeatID, int32_t& SessionState, int32_t& ErrorCode) {
+    // No operation in default
+}
+
+void ConsumerStubDefault::SetSessionState(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string SessionName, std::string SessionOwner, int32_t SessionState, int32_t SeatID, int32_t& ErrorCode) {
+    // Call old style methods in default 
+    SetSessionState(SessionName, SessionOwner, SessionState, SeatID, ErrorCode);
+}
+void ConsumerStubDefault::SetSessionState(std::string SessionName, std::string SessionOwner, int32_t SessionState, int32_t SeatID, int32_t& ErrorCode) {
+    // No operation in default
+}
+
+
+void ConsumerStubDefault::fireNodeApplicationModeEvent(const int32_t& ApplicationModeId) {
+    stubAdapter_->fireNodeApplicationModeEvent(ApplicationModeId);
+}
+void ConsumerStubDefault::fireSessionStateChangedEvent(const std::string& SessionStateName, const int32_t& SeatID, const int32_t& SessionState) {
+    stubAdapter_->fireSessionStateChangedEvent(SessionStateName, SeatID, SessionState);
+}
+void ConsumerStubDefault::fireNodeStateEvent(const int32_t& NodeState) {
+    stubAdapter_->fireNodeStateEvent(NodeState);
+}
+
+
+ConsumerStubDefault::RemoteEventHandler::RemoteEventHandler(ConsumerStubDefault* defaultStub):
+        defaultStub_(defaultStub) {
+}
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.h
new file mode 100644
index 0000000..b28944c
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/ConsumerStubDefault.h
@@ -0,0 +1,128 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Consumer_STUB_DEFAULT_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Consumer_STUB_DEFAULT_H_
+
+
+#include <org/genivi/NodeStateManager/ConsumerStub.h>
+#include <sstream>
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+/**
+ * Provides a default implementation for ConsumerStubRemoteEvent and
+ * ConsumerStub. Method callbacks have an empty implementation,
+ * remote set calls on attributes will always change the value of the attribute
+ * to the one received.
+ *
+ * Override this stub if you only want to provide a subset of the functionality
+ * that would be defined for this service, and/or if you do not need any non-default
+ * behaviour.
+ */
+class ConsumerStubDefault : public virtual ConsumerStub {
+public:
+    ConsumerStubDefault();
+
+    ConsumerStubRemoteEvent* initStubAdapter(const std::shared_ptr<ConsumerStubAdapter>& stubAdapter);
+
+    const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId);
+
+    virtual const int32_t& getBootModeAttribute();
+    virtual const int32_t& getBootModeAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId);
+    virtual void setBootModeAttribute(int32_t value);
+    virtual const int32_t& getRestartReasonAttribute();
+    virtual const int32_t& getRestartReasonAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId);
+    virtual void setRestartReasonAttribute(int32_t value);
+    virtual const int32_t& getShutdownReasonAttribute();
+    virtual const int32_t& getShutdownReasonAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId);
+    virtual void setShutdownReasonAttribute(int32_t value);
+    virtual const int32_t& getWakeUpReasonAttribute();
+    virtual const int32_t& getWakeUpReasonAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId);
+    virtual void setWakeUpReasonAttribute(int32_t value);
+
+    virtual void GetAppHealthCount(const std::shared_ptr<CommonAPI::ClientId> clientId, uint32_t& Count);
+    virtual void GetAppHealthCount(uint32_t& Count);
+
+    virtual void LifecycleRequestComplete(const std::shared_ptr<CommonAPI::ClientId> clientId, uint32_t RequestId, int32_t Status, int32_t& ErrorCode);
+    virtual void LifecycleRequestComplete(uint32_t RequestId, int32_t Status, int32_t& ErrorCode);
+
+    virtual void GetInterfaceVersion(const std::shared_ptr<CommonAPI::ClientId> clientId, uint32_t& Version);
+    virtual void GetInterfaceVersion(uint32_t& Version);
+
+    virtual void GetApplicationMode(const std::shared_ptr<CommonAPI::ClientId> clientId, int32_t& ErrorCode, int32_t& ApplicationModeId);
+    virtual void GetApplicationMode(int32_t& ErrorCode, int32_t& ApplicationModeId);
+
+    virtual void UnRegisterSession(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string SessionName, std::string SessionOwner, int32_t SeatID, int32_t& ErrorCode);
+    virtual void UnRegisterSession(std::string SessionName, std::string SessionOwner, int32_t SeatID, int32_t& ErrorCode);
+
+    virtual void RegisterSession(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string SessionName, std::string SessionOwner, int32_t SeatID, int32_t SessionState, int32_t& ErrorCode);
+    virtual void RegisterSession(std::string SessionName, std::string SessionOwner, int32_t SeatID, int32_t SessionState, int32_t& ErrorCode);
+
+    virtual void UnRegisterShutdownClient(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string BusName, std::string ObjName, uint32_t ShutdownMode, int32_t& ErrorCode);
+    virtual void UnRegisterShutdownClient(std::string BusName, std::string ObjName, uint32_t ShutdownMode, int32_t& ErrorCode);
+
+    virtual void RegisterShutdownClient(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string BusName, std::string ObjName, uint32_t ShutdownMode, uint32_t TimeoutMs, int32_t& ErrorCode);
+    virtual void RegisterShutdownClient(std::string BusName, std::string ObjName, uint32_t ShutdownMode, uint32_t TimeoutMs, int32_t& ErrorCode);
+
+    virtual void GetNodeState(const std::shared_ptr<CommonAPI::ClientId> clientId, int32_t& ErrorCode, int32_t& NodeStateId);
+    virtual void GetNodeState(int32_t& ErrorCode, int32_t& NodeStateId);
+
+    virtual void GetSessionState(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string SessionName, int32_t SeatID, int32_t& SessionState, int32_t& ErrorCode);
+    virtual void GetSessionState(std::string SessionName, int32_t SeatID, int32_t& SessionState, int32_t& ErrorCode);
+
+    virtual void SetSessionState(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string SessionName, std::string SessionOwner, int32_t SessionState, int32_t SeatID, int32_t& ErrorCode);
+    virtual void SetSessionState(std::string SessionName, std::string SessionOwner, int32_t SessionState, int32_t SeatID, int32_t& ErrorCode);
+
+
+    virtual void fireNodeApplicationModeEvent(const int32_t& ApplicationModeId);
+    virtual void fireSessionStateChangedEvent(const std::string& SessionStateName, const int32_t& SeatID, const int32_t& SessionState);
+    virtual void fireNodeStateEvent(const int32_t& NodeState);
+
+
+protected:
+    virtual bool trySetBootModeAttribute(int32_t value);
+    virtual bool validateBootModeAttributeRequestedValue(const int32_t& value);
+    virtual bool trySetRestartReasonAttribute(int32_t value);
+    virtual bool validateRestartReasonAttributeRequestedValue(const int32_t& value);
+    virtual bool trySetShutdownReasonAttribute(int32_t value);
+    virtual bool validateShutdownReasonAttributeRequestedValue(const int32_t& value);
+    virtual bool trySetWakeUpReasonAttribute(int32_t value);
+    virtual bool validateWakeUpReasonAttributeRequestedValue(const int32_t& value);
+    class RemoteEventHandler: public virtual ConsumerStubRemoteEvent {
+     public:
+        RemoteEventHandler(ConsumerStubDefault* defaultStub);
+
+
+
+
+
+
+     private:
+        ConsumerStubDefault* defaultStub_;
+    };
+private:
+    ConsumerStubDefault::RemoteEventHandler remoteEventHandler_;
+
+    int32_t bootModeAttributeValue_;
+    int32_t restartReasonAttributeValue_;
+    int32_t shutdownReasonAttributeValue_;
+    int32_t wakeUpReasonAttributeValue_;
+
+    CommonAPI::Version interfaceVersion_;
+};
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Consumer_STUB_DEFAULT_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumer.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumer.h
new file mode 100644
index 0000000..d810ef8
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumer.h
@@ -0,0 +1,62 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_H_
+
+
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/types.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+class LifeCycleConsumer {
+ public:
+    virtual ~LifeCycleConsumer() { }
+
+    static inline const char* getInterfaceId();
+    static inline CommonAPI::Version getInterfaceVersion();
+};
+
+const char* LifeCycleConsumer::getInterfaceId() {
+    static const char* interfaceId = "org.genivi.NodeStateManager.LifeCycleConsumer";
+    return interfaceId;
+}
+
+CommonAPI::Version LifeCycleConsumer::getInterfaceVersion() {
+    return CommonAPI::Version(1, 0);
+}
+
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+namespace CommonAPI {
+
+}
+
+
+namespace std {
+    //hashes for types
+
+    //hashes for error types
+}
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.cpp b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.cpp
new file mode 100644
index 0000000..877f3cc
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.cpp
@@ -0,0 +1,74 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#include "LifeCycleConsumerDBusProxy.h"
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+std::shared_ptr<CommonAPI::DBus::DBusProxy> createLifeCycleConsumerDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection) {
+    return std::make_shared<LifeCycleConsumerDBusProxy>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection);
+}
+
+INITIALIZER(registerLifeCycleConsumerDBusProxy) {
+    CommonAPI::DBus::DBusFactory::registerProxyFactoryMethod(LifeCycleConsumer::getInterfaceId(),
+       &createLifeCycleConsumerDBusProxy);
+}
+
+LifeCycleConsumerDBusProxy::LifeCycleConsumerDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection):
+        CommonAPI::DBus::DBusProxy(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyconnection)
+    {
+    }
+
+
+
+void LifeCycleConsumerDBusProxy::LifecycleRequest(const uint32_t& Request, const uint32_t& RequestId, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<uint32_t, uint32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodWithReply(
+        *this,
+        "LifecycleRequest",
+        "uu",
+        Request, RequestId,
+        callStatus
+        , ErrorCode);
+}
+std::future<CommonAPI::CallStatus> LifeCycleConsumerDBusProxy::LifecycleRequestAsync(const uint32_t& Request, const uint32_t& RequestId, LifecycleRequestAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<uint32_t, uint32_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<int32_t> >::callMethodAsync(
+        *this,
+        "LifecycleRequest",
+        "uu",
+        Request, RequestId, 
+        std::move(callback));
+}
+
+
+
+void LifeCycleConsumerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
+    ownVersionMajor = 1;
+    ownVersionMinor = 0;
+}
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.h
new file mode 100644
index 0000000..abaa4d1
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusProxy.h
@@ -0,0 +1,62 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_DBUS_PROXY_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_DBUS_PROXY_H_
+
+#include <org/genivi/NodeStateManager/LifeCycleConsumerProxyBase.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/DBus/DBusFactory.h>
+#include <CommonAPI/DBus/DBusProxy.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+#include <string>
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+class LifeCycleConsumerDBusProxy: virtual public LifeCycleConsumerProxyBase, virtual public CommonAPI::DBus::DBusProxy {
+ public:
+    LifeCycleConsumerDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection);
+
+    virtual ~LifeCycleConsumerDBusProxy() { }
+
+
+
+    virtual void LifecycleRequest(const uint32_t& Request, const uint32_t& RequestId, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    virtual std::future<CommonAPI::CallStatus> LifecycleRequestAsync(const uint32_t& Request, const uint32_t& RequestId, LifecycleRequestAsyncCallback callback);
+
+
+    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;
+
+ private:
+
+
+};
+
+
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_DBUS_PROXY_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.cpp b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.cpp
new file mode 100644
index 0000000..0a2bb4d
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.cpp
@@ -0,0 +1,121 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+#include "LifeCycleConsumerDBusStubAdapter.h"
+#include <org/genivi/NodeStateManager/LifeCycleConsumer.h>
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createLifeCycleConsumerDBusStubAdapter(
+                   const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                   const std::string& commonApiAddress,
+                   const std::string& interfaceName,
+                   const std::string& busName,
+                   const std::string& objectPath,
+                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection,
+                   const std::shared_ptr<CommonAPI::StubBase>& stubBase) {
+    return std::make_shared<LifeCycleConsumerDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
+}
+
+INITIALIZER(registerLifeCycleConsumerDBusStubAdapter) {
+    CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(LifeCycleConsumer::getInterfaceId(),
+                                                               &createLifeCycleConsumerDBusStubAdapter);
+}
+
+
+
+LifeCycleConsumerDBusStubAdapterInternal::~LifeCycleConsumerDBusStubAdapterInternal() {
+    deactivateManagedInstances();
+    LifeCycleConsumerDBusStubAdapterHelper::deinit();
+}
+
+void LifeCycleConsumerDBusStubAdapterInternal::deactivateManagedInstances() {
+
+}
+
+const char* LifeCycleConsumerDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
+    static const std::string introspectionData =
+        "<method name=\"getInterfaceVersion\">\n"
+            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
+        "</method>\n"
+        "<method name=\"LifecycleRequest\">\n"
+            "<arg name=\"Request\" type=\"u\" direction=\"in\" />\n"
+            "<arg name=\"RequestId\" type=\"u\" direction=\"in\" />\n"
+            "<arg name=\"ErrorCode\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+
+    ;
+    return introspectionData.c_str();
+}
+
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        LifeCycleConsumerStub,
+        CommonAPI::Version
+        > LifeCycleConsumerDBusStubAdapterInternal::getLifeCycleConsumerInterfaceVersionStubDispatcher(&LifeCycleConsumerStub::getInterfaceVersion, "uu");
+
+
+
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    LifeCycleConsumerStub,
+    std::tuple<uint32_t, uint32_t>,
+    std::tuple<int32_t>
+    > LifeCycleConsumerDBusStubAdapterInternal::lifecycleRequestStubDispatcher(&LifeCycleConsumerStub::LifecycleRequest, "i");
+
+
+
+
+
+const LifeCycleConsumerDBusStubAdapterHelper::StubDispatcherTable& LifeCycleConsumerDBusStubAdapterInternal::getStubDispatcherTable() {
+    return stubDispatcherTable_;
+}
+
+const CommonAPI::DBus::StubAttributeTable& LifeCycleConsumerDBusStubAdapterInternal::getStubAttributeTable() {
+    return stubAttributeTable_;
+}
+
+LifeCycleConsumerDBusStubAdapterInternal::LifeCycleConsumerDBusStubAdapterInternal(
+        const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+        const std::string& commonApiAddress,
+        const std::string& dbusInterfaceName,
+        const std::string& dbusBusName,
+        const std::string& dbusObjectPath,
+        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+        const std::shared_ptr<CommonAPI::StubBase>& stub):
+        CommonAPI::DBus::DBusStubAdapter(
+                factory,
+                commonApiAddress,
+                dbusInterfaceName,
+                dbusBusName,
+                dbusObjectPath,
+                dbusConnection,
+                false),
+        LifeCycleConsumerDBusStubAdapterHelper(
+            factory,
+            commonApiAddress,
+            dbusInterfaceName,
+            dbusBusName,
+            dbusObjectPath,
+            dbusConnection,
+            std::dynamic_pointer_cast<LifeCycleConsumerStub>(stub),
+            false),
+        stubDispatcherTable_({
+            { { "LifecycleRequest", "uu" }, &org::genivi::NodeStateManager::LifeCycleConsumerDBusStubAdapterInternal::lifecycleRequestStubDispatcher }
+            }),
+        stubAttributeTable_() {
+
+    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::NodeStateManager::LifeCycleConsumerDBusStubAdapterInternal::getLifeCycleConsumerInterfaceVersionStubDispatcher });
+}
+
+const bool LifeCycleConsumerDBusStubAdapterInternal::hasFreedesktopProperties() {
+    return false;
+}
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.h
new file mode 100644
index 0000000..ac3d6ed
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerDBusStubAdapter.h
@@ -0,0 +1,113 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_DBUS_STUB_ADAPTER_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_DBUS_STUB_ADAPTER_H_
+
+#include <org/genivi/NodeStateManager/LifeCycleConsumerStub.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/DBus/DBusStubAdapterHelper.h>
+#include <CommonAPI/DBus/DBusStubAdapter.h>
+#include <CommonAPI/DBus/DBusFactory.h>
+#include <CommonAPI/DBus/DBusServicePublisher.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+typedef CommonAPI::DBus::DBusStubAdapterHelper<LifeCycleConsumerStub> LifeCycleConsumerDBusStubAdapterHelper;
+
+class LifeCycleConsumerDBusStubAdapterInternal: public virtual LifeCycleConsumerStubAdapter, public LifeCycleConsumerDBusStubAdapterHelper {
+ public:
+    LifeCycleConsumerDBusStubAdapterInternal(
+            const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+            const std::string& commonApiAddress,
+            const std::string& dbusInterfaceName,
+            const std::string& dbusBusName,
+            const std::string& dbusObjectPath,
+            const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+            const std::shared_ptr<CommonAPI::StubBase>& stub);
+
+    ~LifeCycleConsumerDBusStubAdapterInternal();
+
+    virtual const bool hasFreedesktopProperties();
+
+
+
+
+    const LifeCycleConsumerDBusStubAdapterHelper::StubDispatcherTable& getStubDispatcherTable();
+    const CommonAPI::DBus::StubAttributeTable& getStubAttributeTable();
+
+    void deactivateManagedInstances();
+
+
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        LifeCycleConsumerStub,
+        CommonAPI::Version
+        > getLifeCycleConsumerInterfaceVersionStubDispatcher;
+
+
+
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    LifeCycleConsumerStub,
+    std::tuple<uint32_t, uint32_t>,
+    std::tuple<int32_t>
+    > lifecycleRequestStubDispatcher;
+
+
+
+
+ protected:
+    virtual const char* getMethodsDBusIntrospectionXmlData() const;
+
+ private:
+    LifeCycleConsumerDBusStubAdapterHelper::StubDispatcherTable stubDispatcherTable_;
+    CommonAPI::DBus::StubAttributeTable stubAttributeTable_;
+};
+
+class LifeCycleConsumerDBusStubAdapter: public LifeCycleConsumerDBusStubAdapterInternal, public std::enable_shared_from_this<LifeCycleConsumerDBusStubAdapter> {
+public:
+    LifeCycleConsumerDBusStubAdapter(
+                         const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                         const std::string& commonApiAddress,
+                         const std::string& dbusInterfaceName,
+                         const std::string& dbusBusName,
+                         const std::string& dbusObjectPath,
+                         const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+                         const std::shared_ptr<CommonAPI::StubBase>& stub) :
+            CommonAPI::DBus::DBusStubAdapter(
+                            factory,
+                            commonApiAddress,
+                            dbusInterfaceName,
+                            dbusBusName,
+                            dbusObjectPath,
+                            dbusConnection,
+                            false),
+            LifeCycleConsumerDBusStubAdapterInternal(
+                            factory,
+                            commonApiAddress,
+                            dbusInterfaceName,
+                            dbusBusName,
+                            dbusObjectPath,
+                            dbusConnection,
+                            stub) { }
+};
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_DBUS_STUB_ADAPTER_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxy.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxy.h
new file mode 100644
index 0000000..710e1d8
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxy.h
@@ -0,0 +1,185 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_PROXY_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_PROXY_H_
+
+#include "LifeCycleConsumerProxyBase.h"
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+template <typename ... _AttributeExtensions>
+class LifeCycleConsumerProxy: virtual public LifeCycleConsumer, virtual public LifeCycleConsumerProxyBase
+, public _AttributeExtensions... {
+public:
+    LifeCycleConsumerProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
+    ~LifeCycleConsumerProxy();
+
+    typedef LifeCycleConsumer InterfaceType;
+
+
+
+
+    /**
+     * Calls LifecycleRequest with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void LifecycleRequest(const uint32_t& Request, const uint32_t& RequestId, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode);
+    /**
+     * Calls LifecycleRequest with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> LifecycleRequestAsync(const uint32_t& Request, const uint32_t& RequestId, LifecycleRequestAsyncCallback callback);
+
+
+    /**
+     * Returns the CommonAPI address of the remote partner this proxy communicates with.
+     */
+    virtual std::string getAddress() const;
+
+    /**
+     * Returns the domain of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getDomain() const;
+
+    /** 
+     * Returns the service ID of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getServiceId() const;
+
+    /**
+     * Returns the instance ID of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getInstanceId() const;
+
+    /**
+     * Returns true if the remote partner for this proxy is currently known to be available.
+     */
+    virtual bool isAvailable() const;
+
+    /**
+     * Returns true if the remote partner for this proxy is available.
+     */
+    virtual bool isAvailableBlocking() const;
+
+    /**
+     * Returns the wrapper class that is used to (de-)register for notifications about
+     * the availability of the remote partner of this proxy.
+     */
+    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();
+
+    /**
+     * Returns the wrapper class that is used to access version information of the remote
+     * partner of this proxy.
+     */
+    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();
+
+ private:
+    std::shared_ptr<LifeCycleConsumerProxyBase> delegate_;
+};
+
+#ifdef WIN32
+    typedef LifeCycleConsumerProxy<CommonAPI::WINDummyAttributeExtension<CommonAPI::WINDummyAttribute>> LifeCycleConsumerProxyDefault;
+#else
+    typedef LifeCycleConsumerProxy<> LifeCycleConsumerProxyDefault;
+#endif
+
+
+//
+// LifeCycleConsumerProxy Implementation
+//
+template <typename ... _AttributeExtensions>
+LifeCycleConsumerProxy<_AttributeExtensions...>::LifeCycleConsumerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
+        _AttributeExtensions(*(std::dynamic_pointer_cast<LifeCycleConsumerProxyBase>(delegate)))...,
+        delegate_(std::dynamic_pointer_cast<LifeCycleConsumerProxyBase>(delegate)) {
+}
+
+template <typename ... _AttributeExtensions>
+LifeCycleConsumerProxy<_AttributeExtensions...>::~LifeCycleConsumerProxy() {
+}
+
+template <typename ... _AttributeExtensions>
+void LifeCycleConsumerProxy<_AttributeExtensions...>::LifecycleRequest(const uint32_t& Request, const uint32_t& RequestId, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) {
+    delegate_->LifecycleRequest(Request, RequestId, callStatus, ErrorCode);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> LifeCycleConsumerProxy<_AttributeExtensions...>::LifecycleRequestAsync(const uint32_t& Request, const uint32_t& RequestId, LifecycleRequestAsyncCallback callback) {
+    return delegate_->LifecycleRequestAsync(Request, RequestId, callback);
+}
+
+template <typename ... _AttributeExtensions>
+std::string LifeCycleConsumerProxy<_AttributeExtensions...>::getAddress() const {
+    return delegate_->getAddress();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& LifeCycleConsumerProxy<_AttributeExtensions...>::getDomain() const {
+    return delegate_->getDomain();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& LifeCycleConsumerProxy<_AttributeExtensions...>::getServiceId() const {
+    return delegate_->getServiceId();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& LifeCycleConsumerProxy<_AttributeExtensions...>::getInstanceId() const {
+    return delegate_->getInstanceId();
+}
+
+template <typename ... _AttributeExtensions>
+bool LifeCycleConsumerProxy<_AttributeExtensions...>::isAvailable() const {
+    return delegate_->isAvailable();
+}
+
+template <typename ... _AttributeExtensions>
+bool LifeCycleConsumerProxy<_AttributeExtensions...>::isAvailableBlocking() const {
+    return delegate_->isAvailableBlocking();
+}
+
+template <typename ... _AttributeExtensions>
+CommonAPI::ProxyStatusEvent& LifeCycleConsumerProxy<_AttributeExtensions...>::getProxyStatusEvent() {
+    return delegate_->getProxyStatusEvent();
+}
+
+template <typename ... _AttributeExtensions>
+CommonAPI::InterfaceVersionAttribute& LifeCycleConsumerProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
+    return delegate_->getInterfaceVersionAttribute();
+}
+
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_PROXY_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxyBase.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxyBase.h
new file mode 100644
index 0000000..c6b3c4b
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerProxyBase.h
@@ -0,0 +1,49 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_PROXY_BASE_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_PROXY_BASE_H_
+
+#include "LifeCycleConsumer.h"
+
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <vector>
+
+#include <CommonAPI/Proxy.h>
+#include <functional>
+#include <future>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+class LifeCycleConsumerProxyBase: virtual public CommonAPI::Proxy {
+ public:
+
+    typedef std::function<void(const CommonAPI::CallStatus&, const int32_t&)> LifecycleRequestAsyncCallback;
+
+
+
+    virtual void LifecycleRequest(const uint32_t& Request, const uint32_t& RequestId, CommonAPI::CallStatus& callStatus, int32_t& ErrorCode) = 0;
+    virtual std::future<CommonAPI::CallStatus> LifecycleRequestAsync(const uint32_t& Request, const uint32_t& RequestId, LifecycleRequestAsyncCallback callback) = 0;
+};
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_PROXY_BASE_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStub.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStub.h
new file mode 100644
index 0000000..b7c8de6
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStub.h
@@ -0,0 +1,98 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_STUB_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_STUB_H_
+
+
+
+
+#include "LifeCycleConsumer.h"
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <vector>
+
+#include <CommonAPI/Stub.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+/**
+ * Receives messages from remote and handles all dispatching of deserialized calls
+ * to a stub for the service LifeCycleConsumer. Also provides means to send broadcasts
+ * and attribute-changed-notifications of observable attributes as defined by this service.
+ * An application developer should not need to bother with this class.
+ */
+class LifeCycleConsumerStubAdapter: virtual public CommonAPI::StubAdapter, public LifeCycleConsumer {
+ public:
+
+
+
+    virtual void deactivateManagedInstances() = 0;
+protected:
+    /**
+     * Defines properties for storing the ClientIds of clients / proxies that have
+     * subscribed to the selective broadcasts
+     */
+};
+
+
+/**
+ * Defines the necessary callbacks to handle remote set events related to the attributes
+ * defined in the IDL description for LifeCycleConsumer.
+ * For each attribute two callbacks are defined:
+ * - a verification callback that allows to verify the requested value and to prevent setting
+ *   e.g. an invalid value ("onRemoteSet<AttributeName>").
+ * - an action callback to do local work after the attribute value has been changed
+ *   ("onRemote<AttributeName>Changed").
+ *
+ * This class and the one below are the ones an application developer needs to have
+ * a look at if he wants to implement a service.
+ */
+class LifeCycleConsumerStubRemoteEvent {
+ public:
+    virtual ~LifeCycleConsumerStubRemoteEvent() { }
+
+};
+
+
+/**
+ * Defines the interface that must be implemented by any class that should provide
+ * the service LifeCycleConsumer to remote clients.
+ * This class and the one above are the ones an application developer needs to have
+ * a look at if he wants to implement a service.
+ */
+class LifeCycleConsumerStub: public virtual CommonAPI::Stub<LifeCycleConsumerStubAdapter, LifeCycleConsumerStubRemoteEvent> {
+public:
+    virtual ~LifeCycleConsumerStub() { }
+    virtual const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
+
+
+    /// This is the method that will be called on remote calls on the method LifecycleRequest.
+    virtual void LifecycleRequest(const std::shared_ptr<CommonAPI::ClientId> clientId, uint32_t Request, uint32_t RequestId, int32_t& ErrorCode) = 0;
+
+    using CommonAPI::Stub<LifeCycleConsumerStubAdapter, LifeCycleConsumerStubRemoteEvent>::initStubAdapter;
+    typedef CommonAPI::Stub<LifeCycleConsumerStubAdapter, LifeCycleConsumerStubRemoteEvent>::StubAdapterType StubAdapterType;
+    typedef CommonAPI::Stub<LifeCycleConsumerStubAdapter, LifeCycleConsumerStubRemoteEvent>::RemoteEventHandlerType RemoteEventHandlerType;
+    typedef LifeCycleConsumerStubRemoteEvent RemoteEventType;
+    typedef LifeCycleConsumer StubInterface;
+};
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_STUB_H_
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.cpp b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.cpp
new file mode 100644
index 0000000..aa86851
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.cpp
@@ -0,0 +1,46 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+#include <org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.h>
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+LifeCycleConsumerStubDefault::LifeCycleConsumerStubDefault():
+        remoteEventHandler_(this),
+        interfaceVersion_(LifeCycleConsumer::getInterfaceVersion()) {
+}
+
+const CommonAPI::Version& LifeCycleConsumerStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) {
+    return interfaceVersion_;
+}
+
+LifeCycleConsumerStubRemoteEvent* LifeCycleConsumerStubDefault::initStubAdapter(const std::shared_ptr<LifeCycleConsumerStubAdapter>& stubAdapter) {
+    CommonAPI::Stub<LifeCycleConsumerStubAdapter, LifeCycleConsumerStubRemoteEvent>::stubAdapter_ = stubAdapter;
+    return &remoteEventHandler_;
+}
+
+
+void LifeCycleConsumerStubDefault::LifecycleRequest(const std::shared_ptr<CommonAPI::ClientId> clientId, uint32_t Request, uint32_t RequestId, int32_t& ErrorCode) {
+    // Call old style methods in default 
+    LifecycleRequest(Request, RequestId, ErrorCode);
+}
+void LifeCycleConsumerStubDefault::LifecycleRequest(uint32_t Request, uint32_t RequestId, int32_t& ErrorCode) {
+    // No operation in default
+}
+
+
+
+
+LifeCycleConsumerStubDefault::RemoteEventHandler::RemoteEventHandler(LifeCycleConsumerStubDefault* defaultStub):
+        defaultStub_(defaultStub) {
+}
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
diff --git a/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.h b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.h
new file mode 100644
index 0000000..a474249
--- /dev/null
+++ b/AudioManagerDaemon/src-gen/org/genivi/NodeStateManager/LifeCycleConsumerStubDefault.h
@@ -0,0 +1,67 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_STUB_DEFAULT_H_
+#define ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_STUB_DEFAULT_H_
+
+
+#include <org/genivi/NodeStateManager/LifeCycleConsumerStub.h>
+#include <sstream>
+
+namespace org {
+namespace genivi {
+namespace NodeStateManager {
+
+/**
+ * Provides a default implementation for LifeCycleConsumerStubRemoteEvent and
+ * LifeCycleConsumerStub. Method callbacks have an empty implementation,
+ * remote set calls on attributes will always change the value of the attribute
+ * to the one received.
+ *
+ * Override this stub if you only want to provide a subset of the functionality
+ * that would be defined for this service, and/or if you do not need any non-default
+ * behaviour.
+ */
+class LifeCycleConsumerStubDefault : public virtual LifeCycleConsumerStub {
+public:
+    LifeCycleConsumerStubDefault();
+
+    LifeCycleConsumerStubRemoteEvent* initStubAdapter(const std::shared_ptr<LifeCycleConsumerStubAdapter>& stubAdapter);
+
+    const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId);
+
+
+    virtual void LifecycleRequest(const std::shared_ptr<CommonAPI::ClientId> clientId, uint32_t Request, uint32_t RequestId, int32_t& ErrorCode);
+    virtual void LifecycleRequest(uint32_t Request, uint32_t RequestId, int32_t& ErrorCode);
+
+
+
+
+protected:
+    class RemoteEventHandler: public virtual LifeCycleConsumerStubRemoteEvent {
+     public:
+        RemoteEventHandler(LifeCycleConsumerStubDefault* defaultStub);
+
+
+     private:
+        LifeCycleConsumerStubDefault* defaultStub_;
+    };
+private:
+    LifeCycleConsumerStubDefault::RemoteEventHandler remoteEventHandler_;
+
+
+    CommonAPI::Version interfaceVersion_;
+};
+
+} // namespace NodeStateManager
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_NODESTATEMANAGER_Life_Cycle_Consumer_STUB_DEFAULT_H_
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.cpp b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.cpp
new file mode 100644
index 0000000..8092420
--- /dev/null
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.cpp
@@ -0,0 +1,1043 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#include "am.h"
+
+
+namespace org {
+namespace genivi {
+namespace am {
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+am_Route_s::am_Route_s(const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_RoutingElement_L& routeValue):
+        sourceID(sourceIDValue),
+        sinkID(sinkIDValue),
+        route(routeValue)
+{
+}
+
+
+bool operator==(const am_Route_s& lhs, const am_Route_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceID == rhs.sourceID &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.route == rhs.route
+    ;
+}
+
+void am_Route_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceID;
+    inputStream >> sinkID;
+    inputStream >> route;
+}
+
+void am_Route_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceID;
+    outputStream << sinkID;
+    outputStream << route;
+}
+
+am_Availability_s::am_Availability_s(const am_Availability_e& availabilityValue, const am_CustomAvailabilityReason_t& availabilityReasonValue):
+        availability(availabilityValue),
+        availabilityReason(availabilityReasonValue)
+{
+}
+
+
+bool operator==(const am_Availability_s& lhs, const am_Availability_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.availability == rhs.availability &&
+        lhs.availabilityReason == rhs.availabilityReason
+    ;
+}
+
+void am_Availability_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> availability;
+    inputStream >> availabilityReason;
+}
+
+void am_Availability_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << availability;
+    outputStream << availabilityReason;
+}
+
+am_ClassProperty_s::am_ClassProperty_s(const am_CustomClassProperty_t& classPropertyValue, const int16_t& valueValue):
+        classProperty(classPropertyValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.classProperty == rhs.classProperty &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_ClassProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> classProperty;
+    inputStream >> value;
+}
+
+void am_ClassProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << classProperty;
+    outputStream << value;
+}
+
+am_Crossfader_s::am_Crossfader_s(const am_crossfaderID_t& crossfaderIDValue, const std::string& nameValue, const am_sinkID_t& sinkID_AValue, const am_sinkID_t& sinkID_BValue, const am_sourceID_t& sourceIDValue, const am_HotSink_e& hotSinkValue):
+        crossfaderID(crossfaderIDValue),
+        name(nameValue),
+        sinkID_A(sinkID_AValue),
+        sinkID_B(sinkID_BValue),
+        sourceID(sourceIDValue),
+        hotSink(hotSinkValue)
+{
+}
+
+
+bool operator==(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.crossfaderID == rhs.crossfaderID &&
+        lhs.name == rhs.name &&
+        lhs.sinkID_A == rhs.sinkID_A &&
+        lhs.sinkID_B == rhs.sinkID_B &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.hotSink == rhs.hotSink
+    ;
+}
+
+void am_Crossfader_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> crossfaderID;
+    inputStream >> name;
+    inputStream >> sinkID_A;
+    inputStream >> sinkID_B;
+    inputStream >> sourceID;
+    inputStream >> hotSink;
+}
+
+void am_Crossfader_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << crossfaderID;
+    outputStream << name;
+    outputStream << sinkID_A;
+    outputStream << sinkID_B;
+    outputStream << sourceID;
+    outputStream << hotSink;
+}
+
+am_Gateway_s::am_Gateway_s(const am_gatewayID_t& gatewayIDValue, const std::string& nameValue, const am_sinkID_t& sinkIDValue, const am_sourceID_t& sourceIDValue, const am_domainID_t& domainSinkIDValue, const am_domainID_t& domainSourceIDValue, const am_domainID_t& controlDomainIDValue, const am_ConnectionFormat_L& listSourceFormatsValue, const am_ConnectionFormat_L& listSinkFormatsValue, const am_Convertion_L& convertionMatrixValue):
+        gatewayID(gatewayIDValue),
+        name(nameValue),
+        sinkID(sinkIDValue),
+        sourceID(sourceIDValue),
+        domainSinkID(domainSinkIDValue),
+        domainSourceID(domainSourceIDValue),
+        controlDomainID(controlDomainIDValue),
+        listSourceFormats(listSourceFormatsValue),
+        listSinkFormats(listSinkFormatsValue),
+        convertionMatrix(convertionMatrixValue)
+{
+}
+
+
+bool operator==(const am_Gateway_s& lhs, const am_Gateway_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.gatewayID == rhs.gatewayID &&
+        lhs.name == rhs.name &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.domainSinkID == rhs.domainSinkID &&
+        lhs.domainSourceID == rhs.domainSourceID &&
+        lhs.controlDomainID == rhs.controlDomainID &&
+        lhs.listSourceFormats == rhs.listSourceFormats &&
+        lhs.listSinkFormats == rhs.listSinkFormats &&
+        lhs.convertionMatrix == rhs.convertionMatrix
+    ;
+}
+
+void am_Gateway_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> gatewayID;
+    inputStream >> name;
+    inputStream >> sinkID;
+    inputStream >> sourceID;
+    inputStream >> domainSinkID;
+    inputStream >> domainSourceID;
+    inputStream >> controlDomainID;
+    inputStream >> listSourceFormats;
+    inputStream >> listSinkFormats;
+    inputStream >> convertionMatrix;
+}
+
+void am_Gateway_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << gatewayID;
+    outputStream << name;
+    outputStream << sinkID;
+    outputStream << sourceID;
+    outputStream << domainSinkID;
+    outputStream << domainSourceID;
+    outputStream << controlDomainID;
+    outputStream << listSourceFormats;
+    outputStream << listSinkFormats;
+    outputStream << convertionMatrix;
+}
+
+am_Converter_s::am_Converter_s(const am_converterID_t& converterIDValue, const std::string& nameValue, const am_sinkID_t& sinkIDValue, const am_sourceID_t& sourceIDValue, const am_domainID_t& domainIDValue, const am_ConnectionFormat_L& listSourceFormatsValue, const am_ConnectionFormat_L& listSinkFormatsValue, const am_Convertion_L& convertionMatrixValue):
+        converterID(converterIDValue),
+        name(nameValue),
+        sinkID(sinkIDValue),
+        sourceID(sourceIDValue),
+        domainID(domainIDValue),
+        listSourceFormats(listSourceFormatsValue),
+        listSinkFormats(listSinkFormatsValue),
+        convertionMatrix(convertionMatrixValue)
+{
+}
+
+
+bool operator==(const am_Converter_s& lhs, const am_Converter_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.converterID == rhs.converterID &&
+        lhs.name == rhs.name &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.domainID == rhs.domainID &&
+        lhs.listSourceFormats == rhs.listSourceFormats &&
+        lhs.listSinkFormats == rhs.listSinkFormats &&
+        lhs.convertionMatrix == rhs.convertionMatrix
+    ;
+}
+
+void am_Converter_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> converterID;
+    inputStream >> name;
+    inputStream >> sinkID;
+    inputStream >> sourceID;
+    inputStream >> domainID;
+    inputStream >> listSourceFormats;
+    inputStream >> listSinkFormats;
+    inputStream >> convertionMatrix;
+}
+
+void am_Converter_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << converterID;
+    outputStream << name;
+    outputStream << sinkID;
+    outputStream << sourceID;
+    outputStream << domainID;
+    outputStream << listSourceFormats;
+    outputStream << listSinkFormats;
+    outputStream << convertionMatrix;
+}
+
+am_RoutingElement_s::am_RoutingElement_s(const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_domainID_t& domainIDValue, const am_CustomConnectionFormat_t& connectionFormatValue):
+        sourceID(sourceIDValue),
+        sinkID(sinkIDValue),
+        domainID(domainIDValue),
+        connectionFormat(connectionFormatValue)
+{
+}
+
+
+bool operator==(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceID == rhs.sourceID &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.domainID == rhs.domainID &&
+        lhs.connectionFormat == rhs.connectionFormat
+    ;
+}
+
+void am_RoutingElement_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceID;
+    inputStream >> sinkID;
+    inputStream >> domainID;
+    inputStream >> connectionFormat;
+}
+
+void am_RoutingElement_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceID;
+    outputStream << sinkID;
+    outputStream << domainID;
+    outputStream << connectionFormat;
+}
+
+am_SoundProperty_s::am_SoundProperty_s(const am_CustomSoundPropertyType_t& typeValue, const int16_t& valueValue):
+        type(typeValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_SoundProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> value;
+}
+
+void am_SoundProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << value;
+}
+
+am_SystemProperty_s::am_SystemProperty_s(const am_CustomSystemPropertyType_t& typeValue, const int16_t& valueValue):
+        type(typeValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_SystemProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> value;
+}
+
+void am_SystemProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << value;
+}
+
+am_SinkClass_s::am_SinkClass_s(const am_sinkClass_t& sinkClassIDValue, const std::string& nameValue, const am_ClassProperty_L& listClassPropertiesValue):
+        sinkClassID(sinkClassIDValue),
+        name(nameValue),
+        listClassProperties(listClassPropertiesValue)
+{
+}
+
+
+bool operator==(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sinkClassID == rhs.sinkClassID &&
+        lhs.name == rhs.name &&
+        lhs.listClassProperties == rhs.listClassProperties
+    ;
+}
+
+void am_SinkClass_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sinkClassID;
+    inputStream >> name;
+    inputStream >> listClassProperties;
+}
+
+void am_SinkClass_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sinkClassID;
+    outputStream << name;
+    outputStream << listClassProperties;
+}
+
+am_SourceClass_s::am_SourceClass_s(const am_sourceClass_t& sourceClassIDValue, const std::string& nameValue, const am_ClassProperty_L& listClassPropertiesValue):
+        sourceClassID(sourceClassIDValue),
+        name(nameValue),
+        listClassProperties(listClassPropertiesValue)
+{
+}
+
+
+bool operator==(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceClassID == rhs.sourceClassID &&
+        lhs.name == rhs.name &&
+        lhs.listClassProperties == rhs.listClassProperties
+    ;
+}
+
+void am_SourceClass_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceClassID;
+    inputStream >> name;
+    inputStream >> listClassProperties;
+}
+
+void am_SourceClass_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceClassID;
+    outputStream << name;
+    outputStream << listClassProperties;
+}
+
+am_SourceType_s::am_SourceType_s(const am_sourceID_t& sourceIDValue, const std::string& nameValue, const am_Availability_s& availabilityValue, const am_sourceClass_t& sourceClassIDValue):
+        sourceID(sourceIDValue),
+        name(nameValue),
+        availability(availabilityValue),
+        sourceClassID(sourceClassIDValue)
+{
+}
+
+
+bool operator==(const am_SourceType_s& lhs, const am_SourceType_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceID == rhs.sourceID &&
+        lhs.name == rhs.name &&
+        lhs.availability == rhs.availability &&
+        lhs.sourceClassID == rhs.sourceClassID
+    ;
+}
+
+void am_SourceType_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceID;
+    inputStream >> name;
+    inputStream >> availability;
+    inputStream >> sourceClassID;
+}
+
+void am_SourceType_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceID;
+    outputStream << name;
+    outputStream << availability;
+    outputStream << sourceClassID;
+}
+
+am_SinkType_s::am_SinkType_s(const am_sinkID_t& sinkIDValue, const std::string& nameValue, const am_Availability_s& availabilityValue, const am_mainVolume_t& volumeValue, const am_MuteState_e& muteStateValue, const am_sinkClass_t& sinkClassIDValue):
+        sinkID(sinkIDValue),
+        name(nameValue),
+        availability(availabilityValue),
+        volume(volumeValue),
+        muteState(muteStateValue),
+        sinkClassID(sinkClassIDValue)
+{
+}
+
+
+bool operator==(const am_SinkType_s& lhs, const am_SinkType_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sinkID == rhs.sinkID &&
+        lhs.name == rhs.name &&
+        lhs.availability == rhs.availability &&
+        lhs.volume == rhs.volume &&
+        lhs.muteState == rhs.muteState &&
+        lhs.sinkClassID == rhs.sinkClassID
+    ;
+}
+
+void am_SinkType_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sinkID;
+    inputStream >> name;
+    inputStream >> availability;
+    inputStream >> volume;
+    inputStream >> muteState;
+    inputStream >> sinkClassID;
+}
+
+void am_SinkType_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sinkID;
+    outputStream << name;
+    outputStream << availability;
+    outputStream << volume;
+    outputStream << muteState;
+    outputStream << sinkClassID;
+}
+
+am_Handle_s::am_Handle_s(const am_Handle_e& handleTypeValue, const uint16_t& handleValue):
+        handleType(handleTypeValue),
+        handle(handleValue)
+{
+}
+
+
+bool operator==(const am_Handle_s& lhs, const am_Handle_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.handleType == rhs.handleType &&
+        lhs.handle == rhs.handle
+    ;
+}
+
+void am_Handle_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> handleType;
+    inputStream >> handle;
+}
+
+void am_Handle_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << handleType;
+    outputStream << handle;
+}
+
+am_MainSoundProperty_s::am_MainSoundProperty_s(const am_CustomMainSoundPropertyType_t& typeValue, const int16_t& valueValue):
+        type(typeValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_MainSoundProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> value;
+}
+
+void am_MainSoundProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << value;
+}
+
+am_MainConnectionType_s::am_MainConnectionType_s(const am_mainConnectionID_t& mainConnectionIDValue, const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_timeSync_t& delayValue, const am_ConnectionState_e& connectionStateValue):
+        mainConnectionID(mainConnectionIDValue),
+        sourceID(sourceIDValue),
+        sinkID(sinkIDValue),
+        delay(delayValue),
+        connectionState(connectionStateValue)
+{
+}
+
+
+bool operator==(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.mainConnectionID == rhs.mainConnectionID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.delay == rhs.delay &&
+        lhs.connectionState == rhs.connectionState
+    ;
+}
+
+void am_MainConnectionType_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> mainConnectionID;
+    inputStream >> sourceID;
+    inputStream >> sinkID;
+    inputStream >> delay;
+    inputStream >> connectionState;
+}
+
+void am_MainConnectionType_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << mainConnectionID;
+    outputStream << sourceID;
+    outputStream << sinkID;
+    outputStream << delay;
+    outputStream << connectionState;
+}
+
+am_MainConnection_s::am_MainConnection_s(const am_mainConnectionID_t& mainConnectionIDValue, const am_ConnectionState_e& connectionStateValue, const am_sinkID_t& sinkIDValue, const am_sourceID_t& sourceIDValue, const am_timeSync_t& delayValue, const am_ConnectionID_L& listConnectionIDValue):
+        mainConnectionID(mainConnectionIDValue),
+        connectionState(connectionStateValue),
+        sinkID(sinkIDValue),
+        sourceID(sourceIDValue),
+        delay(delayValue),
+        listConnectionID(listConnectionIDValue)
+{
+}
+
+
+bool operator==(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.mainConnectionID == rhs.mainConnectionID &&
+        lhs.connectionState == rhs.connectionState &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.delay == rhs.delay &&
+        lhs.listConnectionID == rhs.listConnectionID
+    ;
+}
+
+void am_MainConnection_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> mainConnectionID;
+    inputStream >> connectionState;
+    inputStream >> sinkID;
+    inputStream >> sourceID;
+    inputStream >> delay;
+    inputStream >> listConnectionID;
+}
+
+void am_MainConnection_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << mainConnectionID;
+    outputStream << connectionState;
+    outputStream << sinkID;
+    outputStream << sourceID;
+    outputStream << delay;
+    outputStream << listConnectionID;
+}
+
+am_NotificationPayload_s::am_NotificationPayload_s(const am_CustomNotificationType_t& typeValue, const int16_t& valueValue):
+        type(typeValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_NotificationPayload_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> value;
+}
+
+void am_NotificationPayload_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << value;
+}
+
+am_NotificationConfiguration_s::am_NotificationConfiguration_s(const am_CustomNotificationType_t& typeValue, const am_NotificationStatus_e& statusValue, const int16_t& parameterValue):
+        type(typeValue),
+        status(statusValue),
+        parameter(parameterValue)
+{
+}
+
+
+bool operator==(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.status == rhs.status &&
+        lhs.parameter == rhs.parameter
+    ;
+}
+
+void am_NotificationConfiguration_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> status;
+    inputStream >> parameter;
+}
+
+void am_NotificationConfiguration_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << status;
+    outputStream << parameter;
+}
+
+am_Sink_s::am_Sink_s(const am_sinkID_t& sinkIDValue, const std::string& nameValue, const am_domainID_t& domainIDValue, const am_sinkClass_t& sinkClassIDValue, const am_volume_t& volumeValue, const bool& visibleValue, const am_Availability_s& availableValue, const am_MuteState_e& muteStateValue, const am_mainVolume_t& mainVolumeValue, const am_SoundProperty_L& listSoundPropertiesValue, const am_ConnectionFormat_L& listConnectionFormatsValue, const am_MainSoundProperty_L& listMainSoundPropertiesValue, const am_NotificationConfiguration_L& listMainNotificationConfigurationsValue, const am_NotificationConfiguration_L& listNotificationConfigurationsValue):
+        sinkID(sinkIDValue),
+        name(nameValue),
+        domainID(domainIDValue),
+        sinkClassID(sinkClassIDValue),
+        volume(volumeValue),
+        visible(visibleValue),
+        available(availableValue),
+        muteState(muteStateValue),
+        mainVolume(mainVolumeValue),
+        listSoundProperties(listSoundPropertiesValue),
+        listConnectionFormats(listConnectionFormatsValue),
+        listMainSoundProperties(listMainSoundPropertiesValue),
+        listMainNotificationConfigurations(listMainNotificationConfigurationsValue),
+        listNotificationConfigurations(listNotificationConfigurationsValue)
+{
+}
+
+
+bool operator==(const am_Sink_s& lhs, const am_Sink_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sinkID == rhs.sinkID &&
+        lhs.name == rhs.name &&
+        lhs.domainID == rhs.domainID &&
+        lhs.sinkClassID == rhs.sinkClassID &&
+        lhs.volume == rhs.volume &&
+        lhs.visible == rhs.visible &&
+        lhs.available == rhs.available &&
+        lhs.muteState == rhs.muteState &&
+        lhs.mainVolume == rhs.mainVolume &&
+        lhs.listSoundProperties == rhs.listSoundProperties &&
+        lhs.listConnectionFormats == rhs.listConnectionFormats &&
+        lhs.listMainSoundProperties == rhs.listMainSoundProperties &&
+        lhs.listMainNotificationConfigurations == rhs.listMainNotificationConfigurations &&
+        lhs.listNotificationConfigurations == rhs.listNotificationConfigurations
+    ;
+}
+
+void am_Sink_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sinkID;
+    inputStream >> name;
+    inputStream >> domainID;
+    inputStream >> sinkClassID;
+    inputStream >> volume;
+    inputStream >> visible;
+    inputStream >> available;
+    inputStream >> muteState;
+    inputStream >> mainVolume;
+    inputStream >> listSoundProperties;
+    inputStream >> listConnectionFormats;
+    inputStream >> listMainSoundProperties;
+    inputStream >> listMainNotificationConfigurations;
+    inputStream >> listNotificationConfigurations;
+}
+
+void am_Sink_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sinkID;
+    outputStream << name;
+    outputStream << domainID;
+    outputStream << sinkClassID;
+    outputStream << volume;
+    outputStream << visible;
+    outputStream << available;
+    outputStream << muteState;
+    outputStream << mainVolume;
+    outputStream << listSoundProperties;
+    outputStream << listConnectionFormats;
+    outputStream << listMainSoundProperties;
+    outputStream << listMainNotificationConfigurations;
+    outputStream << listNotificationConfigurations;
+}
+
+am_Source_s::am_Source_s(const am_sourceID_t& sourceIDValue, const am_domainID_t& domainIDValue, const std::string& nameValue, const am_sourceClass_t& sourceClassIDValue, const am_SourceState_e& sourceStateValue, const am_volume_t& volumeValue, const bool& visibleValue, const am_Availability_s& availableValue, const am_InterruptState_e& interruptStateValue, const am_SoundProperty_L& listSoundPropertiesValue, const am_ConnectionFormat_L& listConnectionFormatsValue, const am_MainSoundProperty_L& listMainSoundPropertiesValue, const am_NotificationConfiguration_L& listMainNotificationConfigurationsValue, const am_NotificationConfiguration_L& listNotificationConfigurationsValue):
+        sourceID(sourceIDValue),
+        domainID(domainIDValue),
+        name(nameValue),
+        sourceClassID(sourceClassIDValue),
+        sourceState(sourceStateValue),
+        volume(volumeValue),
+        visible(visibleValue),
+        available(availableValue),
+        interruptState(interruptStateValue),
+        listSoundProperties(listSoundPropertiesValue),
+        listConnectionFormats(listConnectionFormatsValue),
+        listMainSoundProperties(listMainSoundPropertiesValue),
+        listMainNotificationConfigurations(listMainNotificationConfigurationsValue),
+        listNotificationConfigurations(listNotificationConfigurationsValue)
+{
+}
+
+
+bool operator==(const am_Source_s& lhs, const am_Source_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceID == rhs.sourceID &&
+        lhs.domainID == rhs.domainID &&
+        lhs.name == rhs.name &&
+        lhs.sourceClassID == rhs.sourceClassID &&
+        lhs.sourceState == rhs.sourceState &&
+        lhs.volume == rhs.volume &&
+        lhs.visible == rhs.visible &&
+        lhs.available == rhs.available &&
+        lhs.interruptState == rhs.interruptState &&
+        lhs.listSoundProperties == rhs.listSoundProperties &&
+        lhs.listConnectionFormats == rhs.listConnectionFormats &&
+        lhs.listMainSoundProperties == rhs.listMainSoundProperties &&
+        lhs.listMainNotificationConfigurations == rhs.listMainNotificationConfigurations &&
+        lhs.listNotificationConfigurations == rhs.listNotificationConfigurations
+    ;
+}
+
+void am_Source_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceID;
+    inputStream >> domainID;
+    inputStream >> name;
+    inputStream >> sourceClassID;
+    inputStream >> sourceState;
+    inputStream >> volume;
+    inputStream >> visible;
+    inputStream >> available;
+    inputStream >> interruptState;
+    inputStream >> listSoundProperties;
+    inputStream >> listConnectionFormats;
+    inputStream >> listMainSoundProperties;
+    inputStream >> listMainNotificationConfigurations;
+    inputStream >> listNotificationConfigurations;
+}
+
+void am_Source_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceID;
+    outputStream << domainID;
+    outputStream << name;
+    outputStream << sourceClassID;
+    outputStream << sourceState;
+    outputStream << volume;
+    outputStream << visible;
+    outputStream << available;
+    outputStream << interruptState;
+    outputStream << listSoundProperties;
+    outputStream << listConnectionFormats;
+    outputStream << listMainSoundProperties;
+    outputStream << listMainNotificationConfigurations;
+    outputStream << listNotificationConfigurations;
+}
+
+am_Domain_s::am_Domain_s(const am_domainID_t& domainIDValue, const std::string& nameValue, const std::string& busnameValue, const std::string& nodenameValue, const bool& earlyValue, const bool& completeValue, const am_DomainState_e& stateValue):
+        domainID(domainIDValue),
+        name(nameValue),
+        busname(busnameValue),
+        nodename(nodenameValue),
+        early(earlyValue),
+        complete(completeValue),
+        state(stateValue)
+{
+}
+
+
+bool operator==(const am_Domain_s& lhs, const am_Domain_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.domainID == rhs.domainID &&
+        lhs.name == rhs.name &&
+        lhs.busname == rhs.busname &&
+        lhs.nodename == rhs.nodename &&
+        lhs.early == rhs.early &&
+        lhs.complete == rhs.complete &&
+        lhs.state == rhs.state
+    ;
+}
+
+void am_Domain_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> domainID;
+    inputStream >> name;
+    inputStream >> busname;
+    inputStream >> nodename;
+    inputStream >> early;
+    inputStream >> complete;
+    inputStream >> state;
+}
+
+void am_Domain_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << domainID;
+    outputStream << name;
+    outputStream << busname;
+    outputStream << nodename;
+    outputStream << early;
+    outputStream << complete;
+    outputStream << state;
+}
+
+am_EarlyData_s::am_EarlyData_s(const am_EarlyDataType_e& typeValue, const am_DataType_u& sinksourceValue, const am_EarlyData_u& dataValue):
+        type(typeValue),
+        sinksource(sinksourceValue),
+        data(dataValue)
+{
+}
+
+
+bool operator==(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.sinksource == rhs.sinksource &&
+        lhs.data == rhs.data
+    ;
+}
+
+void am_EarlyData_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> sinksource;
+    inputStream >> data;
+}
+
+void am_EarlyData_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << sinksource;
+    outputStream << data;
+}
+
+am_Connection_s::am_Connection_s(const am_connectionID_t& connectionIDValue, const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_timeSync_t& delayValue, const am_CustomConnectionFormat_t& connectionFormatValue):
+        connectionID(connectionIDValue),
+        sourceID(sourceIDValue),
+        sinkID(sinkIDValue),
+        delay(delayValue),
+        connectionFormat(connectionFormatValue)
+{
+}
+
+
+bool operator==(const am_Connection_s& lhs, const am_Connection_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.connectionID == rhs.connectionID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.delay == rhs.delay &&
+        lhs.connectionFormat == rhs.connectionFormat
+    ;
+}
+
+void am_Connection_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> connectionID;
+    inputStream >> sourceID;
+    inputStream >> sinkID;
+    inputStream >> delay;
+    inputStream >> connectionFormat;
+}
+
+void am_Connection_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << connectionID;
+    outputStream << sourceID;
+    outputStream << sinkID;
+    outputStream << delay;
+    outputStream << connectionFormat;
+}
+
+am_Volumes_s::am_Volumes_s(const am_VolumeType_e& volumeTypeValue, const am_DataType_u& volumeIDValue, const am_volume_t& volumeValue, const am_CustomRampType_t& rampValue, const am_time_t& timeValue):
+        volumeType(volumeTypeValue),
+        volumeID(volumeIDValue),
+        volume(volumeValue),
+        ramp(rampValue),
+        time(timeValue)
+{
+}
+
+
+bool operator==(const am_Volumes_s& lhs, const am_Volumes_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.volumeType == rhs.volumeType &&
+        lhs.volumeID == rhs.volumeID &&
+        lhs.volume == rhs.volume &&
+        lhs.ramp == rhs.ramp &&
+        lhs.time == rhs.time
+    ;
+}
+
+void am_Volumes_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> volumeType;
+    inputStream >> volumeID;
+    inputStream >> volume;
+    inputStream >> ramp;
+    inputStream >> time;
+}
+
+void am_Volumes_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << volumeType;
+    outputStream << volumeID;
+    outputStream << volume;
+    outputStream << ramp;
+    outputStream << time;
+}
+
+
+
+} // namespace am
+} // namespace genivi
+} // namespace org
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.h
new file mode 100644
index 0000000..e75db5d
--- /dev/null
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am.h
@@ -0,0 +1,2551 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_am_H_
+#define ORG_GENIVI_am_H_
+
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/InputStream.h>
+#include <CommonAPI/OutputStream.h>
+#include <CommonAPI/SerializableStruct.h>
+#include <CommonAPI/SerializableVariant.h>
+#include <CommonAPI/types.h>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <vector>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+
+namespace am {
+    /**
+     * a source ID
+     */
+    /**
+     * a source ID
+     */
+    typedef uint16_t am_sourceID_t;
+    /**
+     * a mainConnection ID
+     */
+    /**
+     * a mainConnection ID
+     */
+    typedef uint16_t am_mainConnectionID_t;
+    /**
+     * offset time that is introduced in milli seconds.
+     */
+    /**
+     * offset time that is introduced in milli seconds.
+     */
+    typedef int16_t am_timeSync_t;
+    /**
+     * a sink ID
+     */
+    /**
+     * a sink ID
+     */
+    typedef uint16_t am_sinkID_t;
+    /**
+     * represents the connection state
+     */
+    enum class am_ConnectionState_e: int32_t {
+        CS_UNKNOWN = 0,
+        /**
+         * This means the connection is just building up
+         */
+        CS_CONNECTING = 1,
+        /**
+         * the connection is ready to be used
+         */
+        CS_CONNECTED = 2,
+        /**
+         * the connection is in the course to be knocked down
+         */
+        CS_DISCONNECTING = 3,
+        /**
+         * only relevant for connectionStatechanged. Is send after the connection was
+         *  removed
+         */
+        CS_DISCONNECTED = 4,
+        /**
+         * this means the connection is still build up but unused at the moment
+         */
+        CS_SUSPENDED = 5,
+        CS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_ConnectionState_eComparator;
+    /**
+     * this type holds all information of connections relevant to the HMI
+     */
+    /**
+     * this type holds all information of connections relevant to the HMI
+     */
+    struct am_MainConnectionType_s: CommonAPI::SerializableStruct {
+        /**
+         * the ID of the mainconnection
+         */
+         am_mainConnectionID_t mainConnectionID;
+        /**
+         * the sourceID where the connection starts
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the sinkID where the connection ends
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the delay of the mainconnection
+         */
+         am_timeSync_t delay;
+        /**
+         * the current connection state
+         */
+         am_ConnectionState_e connectionState;
+    
+        am_MainConnectionType_s() = default;
+        am_MainConnectionType_s(const am_mainConnectionID_t& mainConnectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_timeSync_t& delay, const am_ConnectionState_e& connectionState);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeInt32Type();
+        }
+    };
+    typedef std::vector<am_MainConnectionType_s> am_MainConnection_L;
+    /**
+     * product specific identifier of property
+     */
+    /**
+     * product specific identifier of property
+     */
+    typedef uint16_t am_CustomClassProperty_t;
+    /**
+     * describes class properties
+     */
+    /**
+     * describes class properties
+     */
+    struct am_ClassProperty_s: CommonAPI::SerializableStruct {
+        /**
+         * the property as enum
+         */
+         am_CustomClassProperty_t classProperty;
+        /**
+         * the value of the property
+         */
+         int16_t value;
+    
+        am_ClassProperty_s() = default;
+        am_ClassProperty_s(const am_CustomClassProperty_t& classProperty, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_ClassProperty_s> am_ClassProperty_L;
+    typedef uint16_t am_sinkClass_t;
+    /**
+     * struct describing sinkclasses
+     */
+    /**
+     * struct describing sinkclasses
+     */
+    struct am_SinkClass_s: CommonAPI::SerializableStruct {
+        /**
+         * the ID of the sinkClass
+         */
+         am_sinkClass_t sinkClassID;
+        /**
+         * the name of the sinkClass - must be unique in the system
+         */
+         std::string name;
+        /**
+         * the list of the class properties. These are pairs of  a project specific enum
+         *  describing the type of the value and an integer holding the real value.
+         */
+         am_ClassProperty_L listClassProperties;
+    
+        am_SinkClass_s() = default;
+        am_SinkClass_s(const am_sinkClass_t& sinkClassID, const std::string& name, const am_ClassProperty_L& listClassProperties);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    typedef std::vector<am_SinkClass_s> am_SinkClass_L;
+    /**
+     * This is the volume presented on the command interface. It is in the duty of the
+     *  Controller to change the volumes given here into meaningful values on the
+     *  routing interface.
+    The range of this type is customer specific.
+     */
+    /**
+     * This is the volume presented on the command interface. It is in the duty of the
+     *  Controller to change the volumes given here into meaningful values on the
+     *  routing interface.
+    The range of this type is customer specific.
+     */
+    typedef int16_t am_mainVolume_t;
+    /**
+     * This  project specific value gives the information about reason for reason for
+     *  Source/Sink change
+     */
+    /**
+     * This  project specific value gives the information about reason for reason for
+     *  Source/Sink change
+     */
+    typedef uint16_t am_CustomAvailabilityReason_t;
+    /**
+     * with the help of this enum, sinks and sources can report their availability
+     *  state
+     */
+    enum class am_Availability_e: int32_t {
+        /**
+         * default
+         */
+        A_UNKNOWN = 0,
+        /**
+         * The source / sink is available
+         */
+        A_AVAILABLE = 1,
+        /**
+         * the source / sink is not available
+         */
+        A_UNAVAILABLE = 2,
+        A_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_Availability_eComparator;
+    enum class am_MuteState_e: int32_t {
+        /**
+         * default
+         */
+        MS_UNKNOWN = 0,
+        /**
+         * the source / sink is muted
+         */
+        MS_MUTED = 1,
+        /**
+         * the source / sink is unmuted
+         */
+        MS_UNMUTED = 2,
+        MS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_MuteState_eComparator;
+    /**
+     * this describes the availability of a sink or a source together with the latest
+     *  change
+     */
+    /**
+     * this describes the availability of a sink or a source together with the latest
+     *  change
+     */
+    struct am_Availability_s: CommonAPI::SerializableStruct {
+        /**
+         * the current availability state
+         */
+         am_Availability_e availability;
+        /**
+         * the reason for the last change. This can be used to trigger events that deal
+         *  with state changes.
+         */
+         am_CustomAvailabilityReason_t availabilityReason;
+    
+        am_Availability_s() = default;
+        am_Availability_s(const am_Availability_e& availability, const am_CustomAvailabilityReason_t& availabilityReason);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    /**
+     * this type holds all information of sinks relevant to the HMI
+     */
+    /**
+     * this type holds all information of sinks relevant to the HMI
+     */
+    struct am_SinkType_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the sink, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_sinkID_t sinkID;
+        /**
+         * The name of the sink. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * This attribute reflects the availability of the sink. There are several reasons
+         *  why a sink could be not available for the moment: for example the shutdown of
+         *  a sink because of overtemperature or over- &amp; undervoltage. The
+         *  availability consists of two pieces of information:
+        
+            Availablility: the
+         *  status itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
+           
+         *  AvailabilityReason: this informs about the last reason for a change in
+         *  availability. The reasons itself are product specific.
+         */
+         am_Availability_s availability;
+        /**
+         * This is the representation of the Volume for the commandInterface. It is used
+         *  by the HMI to set the volume of a sink, the AudioManagerController has to
+         *  transform this into real source and sink volumes.
+         */
+         am_mainVolume_t volume;
+         am_MuteState_e muteState;
+        /**
+         * The sinkClassID references to a sinkClass. With the help of classification,
+         *  rules can be setup to define the system behaviour.
+         */
+         am_sinkClass_t sinkClassID;
+    
+        am_SinkType_s() = default;
+        am_SinkType_s(const am_sinkID_t& sinkID, const std::string& name, const am_Availability_s& availability, const am_mainVolume_t& volume, const am_MuteState_e& muteState, const am_sinkClass_t& sinkClassID);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    typedef std::vector<am_SinkType_s> am_SinkType_L;
+    typedef uint16_t am_sourceClass_t;
+    /**
+     * struct describing source classes
+     */
+    /**
+     * struct describing source classes
+     */
+    struct am_SourceClass_s: CommonAPI::SerializableStruct {
+        /**
+         * the source ID
+         */
+         am_sourceClass_t sourceClassID;
+        /**
+         * the name of the sourceClass - must be unique in the system
+         */
+         std::string name;
+        /**
+         * the list of the class properties. These are pairs of  a project specific enum
+         *  describing the type of the value and an integer holding the real value.
+         */
+         am_ClassProperty_L listClassProperties;
+    
+        am_SourceClass_s() = default;
+        am_SourceClass_s(const am_sourceClass_t& sourceClassID, const std::string& name, const am_ClassProperty_L& listClassProperties);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    typedef std::vector<am_SourceClass_s> am_SourceClass_L;
+    /**
+     * this type holds all information of sources relevant to the HMI
+     */
+    /**
+     * this type holds all information of sources relevant to the HMI
+     */
+    struct am_SourceType_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the source, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_sourceID_t sourceID;
+        /**
+         * The name of the source. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * the availability of the source
+         */
+         am_Availability_s availability;
+        /**
+         * the sourceClassID, indicates the class the source is in. This information can
+         *  be used by the Controller to implement different behaviour for different
+         *  classes.
+         */
+         am_sourceClass_t sourceClassID;
+    
+        am_SourceType_s() = default;
+        am_SourceType_s(const am_sourceID_t& sourceID, const std::string& name, const am_Availability_s& availability, const am_sourceClass_t& sourceClassID);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    typedef std::vector<am_SourceType_s> am_SourceType_L;
+    /**
+     * describes the different system properties. Project specific
+     */
+    /**
+     * describes the different system properties. Project specific
+     */
+    typedef uint16_t am_CustomSystemPropertyType_t;
+    /**
+     * struct describing system properties
+     */
+    /**
+     * struct describing system properties
+     */
+    struct am_SystemProperty_s: CommonAPI::SerializableStruct {
+        /**
+         * the type that is set
+         */
+         am_CustomSystemPropertyType_t type;
+        /**
+         * the value
+         */
+         int16_t value;
+    
+        am_SystemProperty_s() = default;
+        am_SystemProperty_s(const am_CustomSystemPropertyType_t& type, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_SystemProperty_s> am_SystemProperty_L;
+    /**
+     * a connection ID
+     */
+    /**
+     * a connection ID
+     */
+    typedef uint16_t am_connectionID_t;
+    typedef std::vector<am_connectionID_t> am_ConnectionID_L;
+    /**
+     * The unit is 0.1 db steps,The smallest value -3000 (=AM_MUTE). The minimum and
+     *  maximum can be limited by actual project.
+     */
+    /**
+     * The unit is 0.1 db steps,The smallest value -3000 (=AM_MUTE). The minimum and
+     *  maximum can be limited by actual project.
+     */
+    typedef int16_t am_volume_t;
+    /**
+     * Project specific sound properties.
+     */
+    /**
+     * Project specific sound properties.
+     */
+    typedef uint16_t am_CustomSoundPropertyType_t;
+    /**
+     * This enum characterizes the data of the EarlyData_t
+     */
+    enum class am_EarlyDataType_e: int32_t {
+        /**
+         * default
+         */
+        ES_UNKNOWN = 0,
+        /**
+         * the source volume
+         */
+        ED_SOURCE_VOLUME = 1,
+        /**
+         * the sink volume
+         */
+        ED_SINK_VOLUME = 2,
+        /**
+         * a source property
+         */
+        ED_SOURCE_PROPERTY = 3,
+        /**
+         * a sink property
+         */
+        ED_SINK_PROPERTY = 4,
+        ED_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_EarlyDataType_eComparator;
+    /**
+     * struct describing the sound property
+     */
+    /**
+     * struct describing the sound property
+     */
+    struct am_SoundProperty_s: CommonAPI::SerializableStruct {
+        /**
+         * the type of the property - a project specific enum
+         */
+         am_CustomSoundPropertyType_t type;
+        /**
+         * the actual value of the property
+         */
+         int16_t value;
+    
+        am_SoundProperty_s() = default;
+        am_SoundProperty_s(const am_CustomSoundPropertyType_t& type, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    /**
+     * data type depends of am_EarlyDataType_e:
+    volume_t in case of ED_SOURCE_VOLUME,
+     *  ED_SINK_VOLUME 
+    soundProperty_t in case of ED_SOURCE_PROPERTY,
+     *  ED_SINK_PROPERTY
+     */
+    /**
+     * data type depends of am_EarlyDataType_e:
+    volume_t in case of ED_SOURCE_VOLUME,
+     *  ED_SINK_VOLUME 
+    soundProperty_t in case of ED_SOURCE_PROPERTY,
+     *  ED_SINK_PROPERTY
+     */
+    typedef CommonAPI::Variant<am_volume_t, am_SoundProperty_s>  am_EarlyData_u;
+    /**
+     * data type depends of am_EarlyDataType_e:
+    sourceID in case of ED_SOURCE_VOLUME,
+     *  ED_SOURCE_PROPERTY
+    sinkID in case of ED_SINK_VOLUME, ED_SINK_PROPERTY
+     */
+    /**
+     * data type depends of am_EarlyDataType_e:
+    sourceID in case of ED_SOURCE_VOLUME,
+     *  ED_SOURCE_PROPERTY
+    sinkID in case of ED_SINK_VOLUME, ED_SINK_PROPERTY
+     */
+    typedef CommonAPI::Variant<am_sinkID_t, am_sourceID_t>  am_DataType_u;
+    struct am_EarlyData_s: CommonAPI::SerializableStruct {
+         am_EarlyDataType_e type;
+         am_DataType_u sinksource;
+         am_EarlyData_u data;
+    
+        am_EarlyData_s() = default;
+        am_EarlyData_s(const am_EarlyDataType_e& type, const am_DataType_u& sinksource, const am_EarlyData_u& data);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeVariantType();
+            typeOutputStream.writeVariantType();
+        }
+    };
+    typedef std::vector<am_EarlyData_s> am_EarlyData_L;
+    /**
+     * Here are all SoundProperties that can be set via the CommandInterface. Product
+     *  specific
+     */
+    /**
+     * Here are all SoundProperties that can be set via the CommandInterface. Product
+     *  specific
+     */
+    typedef uint16_t am_CustomMainSoundPropertyType_t;
+    /**
+     * struct describung mainsound property
+     */
+    /**
+     * struct describung mainsound property
+     */
+    struct am_MainSoundProperty_s: CommonAPI::SerializableStruct {
+        /**
+         * the type of the property
+         */
+         am_CustomMainSoundPropertyType_t type;
+        /**
+         * the actual value
+         */
+         int16_t value;
+    
+        am_MainSoundProperty_s() = default;
+        am_MainSoundProperty_s(const am_CustomMainSoundPropertyType_t& type, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_MainSoundProperty_s> am_MainSoundProperty_L;
+    /**
+     * gives the type of the Notification.
+     */
+    /**
+     * gives the type of the Notification.
+     */
+    typedef uint16_t am_CustomNotificationType_t;
+    enum class am_NotificationStatus_e: int32_t {
+        NS_UNKNOWN = 0,
+        /**
+         * No notification, the function is turned off
+         */
+        NS_OFF = 1,
+        /**
+         * Periodic notifications are sent out. The period in ms is given by
+         *  am_NotificationParameter
+         */
+        NS_PERIODIC = 2,
+        /**
+         * The notification is sent out when the minimum given by am_NotificationParameter
+         *  is reached.
+         */
+        NS_MINIMUM = 3,
+        /**
+         * The notification is sent out when the maximum given by am_NotificationParameter
+         *  is reached.
+         */
+        NS_MAXIMUM = 4,
+        /**
+         * The notification is sent out when a change happened. The Resolution of the
+         *  change is defined by am_NotificationParameter.
+         */
+        NS_CHANGE_ = 5,
+        NS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_NotificationStatus_eComparator;
+    /**
+     * This struct holds information about the configuration for notifications
+     */
+    /**
+     * This struct holds information about the configuration for notifications
+     */
+    struct am_NotificationConfiguration_s: CommonAPI::SerializableStruct {
+        /**
+         * The notification type of the notification
+         */
+         am_CustomNotificationType_t type;
+        /**
+         * The Notification status. This can be periodic, min/max value based or even off
+         *  for example
+         */
+         am_NotificationStatus_e status;
+        /**
+         * This gives additional information to the notification status. 
+        Relation between
+         *  notification status and the value:
+        NS_PERIODIC - the period in ms
+        NS_MINIMUM
+         *  - the minimum value that triggers the notification
+        NS_MAXIMUM - the maximum
+         *  value that triggers the notifcation
+        NS_CHANGE - the resolution of the change
+         *  value
+         */
+         int16_t parameter;
+    
+        am_NotificationConfiguration_s() = default;
+        am_NotificationConfiguration_s(const am_CustomNotificationType_t& type, const am_NotificationStatus_e& status, const int16_t& parameter);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_NotificationConfiguration_s> am_NotificationConfiguration_L;
+    /**
+     * a domain ID
+     */
+    /**
+     * a domain ID
+     */
+    typedef uint16_t am_domainID_t;
+    /**
+     * This project specific value classifies the format in which data is exchanged
+     *  within a connection.
+     */
+    /**
+     * This project specific value classifies the format in which data is exchanged
+     *  within a connection.
+     */
+    typedef uint16_t am_CustomConnectionFormat_t;
+    /**
+     * This represents one "hopp" in a route
+     */
+    /**
+     * This represents one "hopp" in a route
+     */
+    struct am_RoutingElement_s: CommonAPI::SerializableStruct {
+        /**
+         * the source ID
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the sinkID
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the domainID the routeElement is in
+         */
+         am_domainID_t domainID;
+        /**
+         * the connectionformat that is used for the route
+         */
+         am_CustomConnectionFormat_t connectionFormat;
+    
+        am_RoutingElement_s() = default;
+        am_RoutingElement_s(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_domainID_t& domainID, const am_CustomConnectionFormat_t& connectionFormat);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    typedef std::vector<am_RoutingElement_s> am_RoutingElement_L;
+    typedef std::vector<am_SoundProperty_s> am_SoundProperty_L;
+    /**
+     * time in ms!
+     */
+    /**
+     * time in ms!
+     */
+    typedef int16_t am_time_t;
+    /**
+     * For products, different ramp types can be defined here.
+    It is in the
+     *  responsibility of the product to make sure that the routing plugins are aware
+     *  of the ramp types used.
+     */
+    /**
+     * For products, different ramp types can be defined here.
+    It is in the
+     *  responsibility of the product to make sure that the routing plugins are aware
+     *  of the ramp types used.
+     */
+    typedef uint16_t am_CustomRampType_t;
+    /**
+     * This datatype determines if a sourceID or a sinkID is used in the union
+     *  following
+     */
+    enum class am_VolumeType_e: int32_t {
+        VT_UNKNOWN = 0,
+        /**
+         * the following type is a sink
+         */
+        VT_SINK = 1,
+        /**
+         * the following type is a source
+         */
+        VT_SOURCE = 2,
+        VT_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_VolumeType_eComparator;
+    /**
+     * This types describe a mixed description for source and sinks volumes.
+     */
+    /**
+     * This types describe a mixed description for source and sinks volumes.
+     */
+    struct am_Volumes_s: CommonAPI::SerializableStruct {
+        /**
+         * describes the type of the volume: source or sink.
+         */
+         am_VolumeType_e volumeType;
+        /**
+         * either sourceID or sinkID
+         */
+         am_DataType_u volumeID;
+        /**
+         * The volume
+         */
+         am_volume_t volume;
+        /**
+         * the ramp that shall be driven
+         */
+         am_CustomRampType_t ramp;
+        /**
+         * the time for the ramp
+         */
+         am_time_t time;
+    
+        am_Volumes_s() = default;
+        am_Volumes_s(const am_VolumeType_e& volumeType, const am_DataType_u& volumeID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeVariantType();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_Volumes_s> am_Volumes_L;
+    typedef std::vector<am_CustomConnectionFormat_t> am_ConnectionFormat_L;
+    typedef bool am_bool_t;
+    typedef std::vector<am_bool_t> am_Convertion_L;
+    /**
+     * a gateway ID
+     */
+    /**
+     * a gateway ID
+     */
+    typedef uint16_t am_gatewayID_t;
+    /**
+     * a converter ID
+     */
+    /**
+     * a converter ID
+     */
+    typedef uint16_t am_converterID_t;
+    /**
+     * a crossfader ID
+     */
+    /**
+     * a crossfader ID
+     */
+    typedef uint16_t am_crossfaderID_t;
+    /**
+     * speed
+     */
+    /**
+     * speed
+     */
+    typedef uint16_t am_speed_t;
+    /**
+     * describes the active sink of a crossfader.
+     */
+    enum class am_HotSink_e: int32_t {
+        /**
+         * default
+         */
+        HS_UNKNOWN = 0,
+        /**
+         * sinkA is active
+         */
+        HS_SINKA = 1,
+        /**
+         * sinkB is active
+         */
+        HS_SINKB = 2,
+        /**
+         * the crossfader is in the transition state
+         */
+        HS_INTERMEDIATE = 3,
+        HS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_HotSink_eComparator;
+    enum class am_DomainState_e: int32_t {
+        /**
+         * default
+         */
+        DS_UNKNOWN = 0,
+        /**
+         * the domain is controlled by the daemon
+         */
+        DS_CONTROLLED = 1,
+        /**
+         * the domain is independent starting up
+         */
+        DS_INDEPENDENT_STARTUP = 1,
+        /**
+         * the domain is independent running down
+         */
+        DS_INDEPENDENT_RUNDOWN = 2,
+        DS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_DomainState_eComparator;
+    /**
+     * the errors of the audiomanager. All possible errors are in here. This enum is
+     *  used widely as return parameter.
+     */
+    enum class am_Error_e: int32_t {
+        /**
+         * no error - positive reply
+         */
+        E_OK = 0,
+        /**
+         * default
+         */
+        E_UNKNOWN = 1,
+        /**
+         * value out of range
+         */
+        E_OUT_OF_RANGE = 2,
+        /**
+         * not used
+         */
+        E_NOT_USED = 3,
+        /**
+         * a database error occurred
+         */
+        E_DATABASE_ERROR = 4,
+        /**
+         * the desired object already exists
+         */
+        E_ALREADY_EXISTS = 5,
+        /**
+         * there is no change
+         */
+        E_NO_CHANGE = 6,
+        /**
+         * the desired action is not possible
+         */
+        E_NOT_POSSIBLE = 7,
+        /**
+         * the desired object is non existent
+         */
+        E_NON_EXISTENT = 8,
+        /**
+         * the asynchronous action was aborted
+         */
+        E_ABORTED = 9,
+        /**
+         * This error is returned in case a connect is issued with a connectionFormat that
+         *  cannot be selected for the connection. This could be either due to the
+         *  capabilities of a source or a sink or gateway compatibilities for example
+         */
+        E_WRONG_FORMAT = 10,
+        E_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_Error_eComparator;
+    enum class am_InterruptState_e: int32_t {
+        /**
+         * default
+         */
+        IS_UNKNOWN = 0,
+        /**
+         * the interrupt state is off - no interrupt
+         */
+        IS_OFF = 1,
+        /**
+         * the interrupt state is interrupted - the interrupt is active
+         */
+        IS_INTERRUPTED = 2,
+        IS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_InterruptState_eComparator;
+    /**
+     * This enumeration is used to define the type of the action that is correlated to
+     *  a handle.
+     */
+    enum class am_Handle_e: int32_t {
+        H_UNKNOWN = 0,
+        H_CONNECT = 1,
+        H_DISCONNECT = 2,
+        H_SETSOURCESTATE = 3,
+        H_SETSINKVOLUME = 4,
+        H_SETSOURCEVOLUME = 5,
+        H_SETSINKSOUNDPROPERTY = 6,
+        H_SETSOURCESOUNDPROPERTY = 7,
+        H_SETSINKSOUNDPROPERTIES = 8,
+        H_SETSOURCESOUNDPROPERTIES = 9,
+        H_CROSSFADE = 10,
+        H_SETVOLUMES = 11,
+        H_SETSINKNOTIFICATION = 12,
+        H_SETSOURCENOTIFICATION = 13,
+        H_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_Handle_eComparator;
+    /**
+     * The source state reflects the state of the source
+     */
+    enum class am_SourceState_e: int32_t {
+        SS_UNKNNOWN = 0,
+        /**
+         * The source can be activly heared
+         */
+        SS_ON = 1,
+        /**
+         * The source cannot be heared
+         */
+        SS_OFF = 2,
+        /**
+         * The source is paused. Meaning it cannot be heared but should be prepared to
+         *  play again soon.
+         */
+        SS_PAUSED = 3,
+        SS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_SourceState_eComparator;
+    /**
+     * This enum describes the ready state of the routing part
+     */
+    enum class am_RoutingReady_e: int32_t {
+        RR_UNKNOWN = 0,
+        RR_READY = 1,
+        RR_RUNDOWN = 2
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_RoutingReady_eComparator;
+    /**
+     * a list of routing elements that lead from source to sink
+     */
+    /**
+     * a list of routing elements that lead from source to sink
+     */
+    struct am_Route_s: CommonAPI::SerializableStruct {
+        /**
+         * the sourceID where the route starts
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the sinkID where the route ends
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the actual route as list of routing elements
+         */
+         am_RoutingElement_L route;
+    
+        am_Route_s() = default;
+        am_Route_s(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_RoutingElement_L& route);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct describes the attribiutes of a crossfader.
+     */
+    /**
+     * This struct describes the attribiutes of a crossfader.
+     */
+    struct am_Crossfader_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the crossfader, it is unique in the system. There are 2 ways,
+         *  ID can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManager daemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_crossfaderID_t crossfaderID;
+        /**
+         * The name of the crossfader. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * The sinkID of the SinkA. Sinks shall be registered before registering the
+         *  crossfader.
+         */
+         am_sinkID_t sinkID_A;
+        /**
+         * The sinkID of the SinkB. Sinks shall be registered before registering the
+         *  crossfader.
+         */
+         am_sinkID_t sinkID_B;
+        /**
+         * The sourceID of the crossfader source. The source shall be registered before
+         *  the crossfader.
+         */
+         am_sourceID_t sourceID;
+        /**
+         * This enum can have 3 states:
+        
+            HS_SINKA sinkA is the current hot one, sinkB
+         *  is not audible
+            HS_SINKB sinkB is the current hot one, sinkB is not
+         *  audible
+            HS_INTERMEDIATE the fader is stuck in between a cross-fading
+         *  action. This could be due to an abort or an error. Before using the
+         *  crossfader, it must be set to either HS_SINKA or HS_SINKB.
+         */
+         am_HotSink_e hotSink;
+    
+        am_Crossfader_s() = default;
+        am_Crossfader_s(const am_crossfaderID_t& crossfaderID, const std::string& name, const am_sinkID_t& sinkID_A, const am_sinkID_t& sinkID_B, const am_sourceID_t& sourceID, const am_HotSink_e& hotSink);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt32Type();
+        }
+    };
+    /**
+     * This struct describes the attributes of a gateway.
+     */
+    /**
+     * This struct describes the attributes of a gateway.
+     */
+    struct am_Gateway_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the gateway, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_gatewayID_t gatewayID;
+        /**
+         * The name of the gateway. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * The sinkID of the gateway sink-end. The sink is a full blown sink with
+         *  connectionFormats, sinkClassIDs etc... It makes sense to register the sinks of
+         *  a gateway as non-visible. Care needs to be taken that the connectionsFormats
+         *  match with the ones in the conversionMatrix. If the sink is located in the
+         *  controllingDomain, the ID needs to be retrieved by registering the sink before
+         *  registering the gateway. In case the sink is in a different domain, the ID
+         *  needs to be retrieved via peeking.
+         */
+         am_sinkID_t sinkID;
+        /**
+         * The sourceID of the gateway sink-end. The sink is a full blown source with
+         *  connectionFormats, sinkClassIDs etc... It makes sense to register the sources
+         *  of a gateway as non-visible. Care needs to be taken that the
+         *  connectionsFormats match with the ones in the conversionMatrix. If the source
+         *  is located in the controllingDomain, the ID needs to be retrieved by
+         *  registering the source before registering the gateway. In case the source is
+         *  in a different domain, the ID needs to be retrieved via peeking.
+         */
+         am_sourceID_t sourceID;
+        /**
+         * The ID of the sink. If the domain is the same like the controlling domain, the
+         *  ID is known due to registration. If the domain is different, the ID needs to
+         *  be retrieved via peeking.
+         */
+         am_domainID_t domainSinkID;
+        /**
+         * The ID of the source. If the domain is the same like the controlling domain,
+         *  the ID is known due to registration. If the domain is different, the ID needs
+         *  to be retrieved via peeking.
+         */
+         am_domainID_t domainSourceID;
+        /**
+         * This is the ID of the domain that registers the gateway.
+         */
+         am_domainID_t controlDomainID;
+        /**
+         * This is the list of available formats on the source side of the gateway. It is
+         *  not defined during the gateway registration but copied from the source
+         *  registration.
+         */
+         am_ConnectionFormat_L listSourceFormats;
+        /**
+         * This is the list of available formats on the sink side of the gateway. It is
+         *  not defined during the gateway registration but copied from the sink
+         *  registration.
+         */
+         am_ConnectionFormat_L listSinkFormats;
+        /**
+         * This is matrix holding information about the conversion capability of the
+         *  gateway, it's length is defined by the length(listSinkFormats) x
+         *  length(listSourceFormats).
+        If a SinkFormat can be converted into a
+         *  SourceFormat, the vector will hold a 1, if no conversion is possible, a
+         *  0.
+        The data is stored row orientated, where the rows are related to the
+         *  sinksFormats and the columns to the sourceFormats. The first value will hold
+         *  the conversion information from the first sourceFormat to the first sinkFormat
+         *  for example and the seventh value the information about the 3rd sinkFormat to
+         *  the 1st sourceFormat in case we would have 3 sourceFormats.
+         */
+         am_Convertion_L convertionMatrix;
+    
+        am_Gateway_s() = default;
+        am_Gateway_s(const am_gatewayID_t& gatewayID, const std::string& name, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_domainID_t& domainSinkID, const am_domainID_t& domainSourceID, const am_domainID_t& controlDomainID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct describes the attributes of a gateway.
+     */
+    /**
+     * This struct describes the attributes of a gateway.
+     */
+    struct am_Converter_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the gateway, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_converterID_t converterID;
+        /**
+         * The name of the gateway. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * The sinkID of the gateway sink-end. The sink is a full blown sink with
+         *  connectionFormats, sinkClassIDs etc... It makes sense to register the sinks of
+         *  a gateway as non-visible. Care needs to be taken that the connectionsFormats
+         *  match with the ones in the conversionMatrix. If the sink is located in the
+         *  controllingDomain, the ID needs to be retrieved by registering the sink before
+         *  registering the gateway. In case the sink is in a different domain, the ID
+         *  needs to be retrieved via peeking.
+         */
+         am_sinkID_t sinkID;
+        /**
+         * The sourceID of the gateway sink-end. The sink is a full blown source with
+         *  connectionFormats, sinkClassIDs etc... It makes sense to register the sources
+         *  of a gateway as non-visible. Care needs to be taken that the
+         *  connectionsFormats match with the ones in the conversionMatrix. If the source
+         *  is located in the controllingDomain, the ID needs to be retrieved by
+         *  registering the source before registering the gateway. In case the source is
+         *  in a different domain, the ID needs to be retrieved via peeking.
+         */
+         am_sourceID_t sourceID;
+        /**
+         * The ID of the sink. If the domain is the same like the controlling domain, the
+         *  ID is known due to registration. If the domain is different, the ID needs to
+         *  be retrieved via peeking.
+         */
+         am_domainID_t domainID;
+        /**
+         * This is the list of available formats on the source side of the gateway. It is
+         *  not defined during the gateway registration but copied from the source
+         *  registration.
+         */
+         am_ConnectionFormat_L listSourceFormats;
+        /**
+         * This is the list of available formats on the sink side of the gateway. It is
+         *  not defined during the gateway registration but copied from the sink
+         *  registration.
+         */
+         am_ConnectionFormat_L listSinkFormats;
+        /**
+         * This is matrix holding information about the conversion capability of the
+         *  gateway, it's length is defined by the length(listSinkFormats) x
+         *  length(listSourceFormats).
+        If a SinkFormat can be converted into a
+         *  SourceFormat, the vector will hold a 1, if no conversion is possible, a
+         *  0.
+        The data is stored row orientated, where the rows are related to the
+         *  sinksFormats and the columns to the sourceFormats. The first value will hold
+         *  the conversion information from the first sourceFormat to the first sinkFormat
+         *  for example and the seventh value the information about the 3rd sinkFormat to
+         *  the 1st sourceFormat in case we would have 3 sourceFormats.
+         */
+         am_Convertion_L convertionMatrix;
+    
+        am_Converter_s() = default;
+        am_Converter_s(const am_converterID_t& converterID, const std::string& name, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_domainID_t& domainID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * a handle is used for asynchronous operations and is uniquely assigned for each
+     *  of this operations
+     */
+    /**
+     * a handle is used for asynchronous operations and is uniquely assigned for each
+     *  of this operations
+     */
+    struct am_Handle_s: CommonAPI::SerializableStruct {
+        /**
+         * the handletype
+         */
+         am_Handle_e handleType;
+        /**
+         * the handle as value
+         */
+         uint16_t handle;
+    
+        am_Handle_s() = default;
+        am_Handle_s(const am_Handle_e& handleType, const uint16_t& handle);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    /**
+     * struct that holds attribiutes of a mainconnection
+     */
+    /**
+     * struct that holds attribiutes of a mainconnection
+     */
+    struct am_MainConnection_s: CommonAPI::SerializableStruct {
+        /**
+         * the assigned ID
+         */
+         am_mainConnectionID_t mainConnectionID;
+        /**
+         * the current connection state
+         */
+         am_ConnectionState_e connectionState;
+        /**
+         * the sinkID
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the sourceID
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the delay of the connection
+         */
+         am_timeSync_t delay;
+        /**
+         * the list of sub connection IDs the mainconnection consists of
+         */
+         am_ConnectionID_L listConnectionID;
+    
+        am_MainConnection_s() = default;
+        am_MainConnection_s(const am_mainConnectionID_t& mainConnectionID, const am_ConnectionState_e& connectionState, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_timeSync_t& delay, const am_ConnectionID_L& listConnectionID);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct holds the payload of a notification.
+     */
+    /**
+     * This struct holds the payload of a notification.
+     */
+    struct am_NotificationPayload_s: CommonAPI::SerializableStruct {
+        /**
+         * This defines the notification type
+         */
+         am_CustomNotificationType_t type;
+        /**
+         * This is finally the value of the notification. It's meaning depends on the
+         *  notificationType
+         */
+         int16_t value;
+    
+        am_NotificationPayload_s() = default;
+        am_NotificationPayload_s(const am_CustomNotificationType_t& type, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    /**
+     * This struct describes the attribiutes of a sink
+     */
+    /**
+     * This struct describes the attribiutes of a sink
+     */
+    struct am_Sink_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the sink, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_sinkID_t sinkID;
+        /**
+         * The name of the sink. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * The domainID is the domain the sink belongs to. A sink can only be in one
+         *  domain.
+         */
+         am_domainID_t domainID;
+        /**
+         * The sinkClassID references to a sinkClass. With the help of classification,
+         *  rules can be setup to define the system behaviour.
+         */
+         am_sinkClass_t sinkClassID;
+        /**
+         * This is the volume of the sink. It is set by the AudioManagerController.
+         */
+         am_volume_t volume;
+        /**
+         * This Boolean flag indicates whether a sink is visible to the commandInterface
+         *  or not. If the User must have the possibility to choose the source in the HMI,
+         *  it must be visible. But there are also good reasons for invisible sinks, for
+         *  example if the sink is part of a crossfader or gateway. HMI relevant changes
+         *  in visible sinks will be automatically reported by the daemon to the
+         *  commandInterface.
+         */
+         bool visible;
+        /**
+         * This attribute reflects the availability of the sink. There are several reasons
+         *  why a sink could be not available for the moment: for example the shutdown of
+         *  a sink because of overtemperature or over- &amp; undervoltage. The
+         *  availability consists of two pieces of information:
+        
+            Availablility: the
+         *  status itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
+           
+         *  AvailabilityReason: this informs about the last reason for a change in
+         *  availability. The reasons itself are product specific.
+         */
+         am_Availability_s available;
+        /**
+         * This attribute reflects the muteState of the sink. The information is not the
+         *  "real" state of the sink, but the HMI representation for he commandInterface
+         *  controlled by the AudioManagerController.
+         */
+         am_MuteState_e muteState;
+        /**
+         * This is the representation of the Volume for the commandInterface. It is used
+         *  by the HMI to set the volume of a sink, the AudioManagerController has to
+         *  transform this into real source and sink volumes.
+         */
+         am_mainVolume_t mainVolume;
+        /**
+         * This is the list of soundProperties, that the sink is capable of. The
+         *  soundProperties itself are project specific. For sinks, a possible
+         *  soundProperty could be for example settings.
+         */
+         am_SoundProperty_L listSoundProperties;
+        /**
+         * This list holds information about the formats that the Source is capable of
+         *  supporting when delivering audio.
+         */
+         am_ConnectionFormat_L listConnectionFormats;
+        /**
+         * This is the list of the available mainSoundProperties. The principle is the
+         *  same than with soundProperties, but they are only visible to the
+         *  CommandInterface.
+         */
+         am_MainSoundProperty_L listMainSoundProperties;
+        /**
+         * This is the list of the MainNotificationConfigurations. These notifications
+         *  work on the level of command interface.
+         */
+         am_NotificationConfiguration_L listMainNotificationConfigurations;
+        /**
+         * This is the list of the NotificationConfigurations. These notifications work on
+         *  the level of RoutingPlugins.
+         */
+         am_NotificationConfiguration_L listNotificationConfigurations;
+    
+        am_Sink_s() = default;
+        am_Sink_s(const am_sinkID_t& sinkID, const std::string& name, const am_domainID_t& domainID, const am_sinkClass_t& sinkClassID, const am_volume_t& volume, const bool& visible, const am_Availability_s& available, const am_MuteState_e& muteState, const am_mainVolume_t& mainVolume, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, const am_NotificationConfiguration_L& listMainNotificationConfigurations, const am_NotificationConfiguration_L& listNotificationConfigurations);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct describes the attribiutes of a source
+     */
+    /**
+     * This struct describes the attribiutes of a source
+     */
+    struct am_Source_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the source, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_sourceID_t sourceID;
+        /**
+         * The domainID is the domain the source belongs to. A source can only be in one
+         *  domain.
+         */
+         am_domainID_t domainID;
+        /**
+         * The name of the source. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * the sourceClassID, indicates the class the source is in. This information can
+         *  be used by the Controller to implement different behaviour for different
+         *  classes.
+         */
+         am_sourceClass_t sourceClassID;
+        /**
+         * The source state is an indication towards the source if it is actively heard or
+         *  not. The source can use this information to implement features like automatic
+         *  spin down of CD's in case the CD is not the active source or AF following of a
+         *  tuner that is not actively heard. The source state is set by the
+         *  AudioManagerController.There are 3 possible states:
+        
+            SS_ON: the source is
+         *  active
+            SS_OFF: the source is off
+            SS_PAUSED: the source is paused and
+         *  not active.
+         */
+         am_SourceState_e sourceState;
+        /**
+         * This is the volume of the source. It is set by the AudioManagerController. It
+         *  is used to adopt different audiolevels in a system and mixing of sources (e.g.
+         *  navigation hints &amp; music).
+         */
+         am_volume_t volume;
+        /**
+         * This Boolean flag indicates whether a source is visible to the commandInterface
+         *  or not. If the User must have the possibility to choose the source in the HMI,
+         *  it must be visible. But there are also good reasons for invisible sources, for
+         *  example if the source is part of a crossfader or gateway. HMI relevant changes
+         *  in visible sources will be automatically reported by the daemon to the
+         *  commandInterface.
+         */
+         bool visible;
+        /**
+         * This attribute reflects the availability of the source. There are several
+         *  reasons why a source could be not available for the moment. For example a CD
+         *  player which has no CD entered in the slot can be unavailable, or a USB player
+         *  with no or unreadable stick attached. Other scenarios involve the shutdown of
+         *  a source because of overtemperature or over- &amp; undervoltage. The
+         *  availability consists of two informations:
+        
+            Availablility: the status
+         *  itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
+           
+         *  AvailabilityReason: this informs about the last reason for a change in
+         *  availability. The reasons itself are product specific.
+         */
+         am_Availability_s available;
+        /**
+         * Some special sources can have special behaviors, the are so called "Low Level
+         *  Interrupts". Here the current status is documented. The information can be
+         *  used by the AudioManagerController to react to the changes by for example
+         *  lowering the volume of the mainSources. The two states are
+        
+            IS_OFF: the
+         *  interrupt is not active at the moment
+            IS_INTERRUPTED: the interrupt is
+         *  playing at the moment.
+         */
+         am_InterruptState_e interruptState;
+        /**
+         * This is the list of soundProperties, that the source is capable of. The
+         *  soundProperties itself are project specific. For sources, a possible
+         *  soundProperty could be navigation volume offset, for example.
+         */
+         am_SoundProperty_L listSoundProperties;
+        /**
+         * This list holds information about the formats that the Source is capable of
+         *  supporting when delivering audio.
+         */
+         am_ConnectionFormat_L listConnectionFormats;
+        /**
+         * This is the list of the available mainSoundProperties. The principle is the
+         *  same than with soundProperties, but they are only visible to the
+         *  CommandInterface.
+         */
+         am_MainSoundProperty_L listMainSoundProperties;
+        /**
+         * The list of MainNotificationConfigurations. These notifications work on the
+         *  level of CommandInterface.
+         */
+         am_NotificationConfiguration_L listMainNotificationConfigurations;
+        /**
+         * The list of MainNotificationConfigurations. These notifications work on the
+         *  level of RoutingInterface.
+         */
+         am_NotificationConfiguration_L listNotificationConfigurations;
+    
+        am_Source_s() = default;
+        am_Source_s(const am_sourceID_t& sourceID, const am_domainID_t& domainID, const std::string& name, const am_sourceClass_t& sourceClassID, const am_SourceState_e& sourceState, const am_volume_t& volume, const bool& visible, const am_Availability_s& available, const am_InterruptState_e& interruptState, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, const am_NotificationConfiguration_L& listMainNotificationConfigurations, const am_NotificationConfiguration_L& listNotificationConfigurations);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct describes the attribiutes of a domain
+     */
+    /**
+     * This struct describes the attribiutes of a domain
+     */
+    struct am_Domain_s: CommonAPI::SerializableStruct {
+        /**
+         * the domain ID
+         */
+         am_domainID_t domainID;
+        /**
+         * the name of the domain
+         */
+         std::string name;
+        /**
+         * the busname. This is equal to a plugin name and is used to dispatch messages to
+         *  the elements of a plugin
+         */
+         std::string busname;
+        /**
+         * the name of the node
+         */
+         std::string nodename;
+        /**
+         * indicated if the domain is independent at startup or not
+         */
+         bool early;
+        /**
+         * indicates if the domain registration is complete or not
+         */
+         bool complete;
+        /**
+         * the current domain state
+         */
+         am_DomainState_e state;
+    
+        am_Domain_s() = default;
+        am_Domain_s(const am_domainID_t& domainID, const std::string& name, const std::string& busname, const std::string& nodename, const bool& early, const bool& complete, const am_DomainState_e& state);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.writeInt32Type();
+        }
+    };
+    /**
+     * a connection
+     */
+    /**
+     * a connection
+     */
+    struct am_Connection_s: CommonAPI::SerializableStruct {
+        /**
+         * the assigned ID
+         */
+         am_connectionID_t connectionID;
+        /**
+         * the source the audio flows from
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the sink the audio flows to
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the delay of the conneciton
+         */
+         am_timeSync_t delay;
+        /**
+         * the used connectionformat
+         */
+         am_CustomConnectionFormat_t connectionFormat;
+    
+        am_Connection_s() = default;
+        am_Connection_s(const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_timeSync_t& delay, const am_CustomConnectionFormat_t& connectionFormat);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Availability_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Availability_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_Availability_eComparator {
+    inline bool operator()(const am_Availability_e& lhs, const am_Availability_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_HotSink_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_HotSink_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_HotSink_eComparator {
+    inline bool operator()(const am_HotSink_e& lhs, const am_HotSink_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_ConnectionState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_ConnectionState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_ConnectionState_eComparator {
+    inline bool operator()(const am_ConnectionState_e& lhs, const am_ConnectionState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_DomainState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_DomainState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_DomainState_eComparator {
+    inline bool operator()(const am_DomainState_e& lhs, const am_DomainState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_EarlyDataType_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_EarlyDataType_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_EarlyDataType_eComparator {
+    inline bool operator()(const am_EarlyDataType_e& lhs, const am_EarlyDataType_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Error_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Error_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_Error_eComparator {
+    inline bool operator()(const am_Error_e& lhs, const am_Error_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_MuteState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_MuteState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_MuteState_eComparator {
+    inline bool operator()(const am_MuteState_e& lhs, const am_MuteState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_InterruptState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_InterruptState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_InterruptState_eComparator {
+    inline bool operator()(const am_InterruptState_e& lhs, const am_InterruptState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_VolumeType_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_VolumeType_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_VolumeType_eComparator {
+    inline bool operator()(const am_VolumeType_e& lhs, const am_VolumeType_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_NotificationStatus_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_NotificationStatus_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_NotificationStatus_eComparator {
+    inline bool operator()(const am_NotificationStatus_e& lhs, const am_NotificationStatus_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Handle_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Handle_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_Handle_eComparator {
+    inline bool operator()(const am_Handle_e& lhs, const am_Handle_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_SourceState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_SourceState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_SourceState_eComparator {
+    inline bool operator()(const am_SourceState_e& lhs, const am_SourceState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_RoutingReady_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_RoutingReady_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_RoutingReady_eComparator {
+    inline bool operator()(const am_RoutingReady_e& lhs, const am_RoutingReady_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+bool operator==(const am_Route_s& lhs, const am_Route_s& rhs);
+inline bool operator!=(const am_Route_s& lhs, const am_Route_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Availability_s& lhs, const am_Availability_s& rhs);
+inline bool operator!=(const am_Availability_s& lhs, const am_Availability_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs);
+inline bool operator!=(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs);
+inline bool operator!=(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Gateway_s& lhs, const am_Gateway_s& rhs);
+inline bool operator!=(const am_Gateway_s& lhs, const am_Gateway_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Converter_s& lhs, const am_Converter_s& rhs);
+inline bool operator!=(const am_Converter_s& lhs, const am_Converter_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs);
+inline bool operator!=(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs);
+inline bool operator!=(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs);
+inline bool operator!=(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs);
+inline bool operator!=(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs);
+inline bool operator!=(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SourceType_s& lhs, const am_SourceType_s& rhs);
+inline bool operator!=(const am_SourceType_s& lhs, const am_SourceType_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SinkType_s& lhs, const am_SinkType_s& rhs);
+inline bool operator!=(const am_SinkType_s& lhs, const am_SinkType_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Handle_s& lhs, const am_Handle_s& rhs);
+inline bool operator!=(const am_Handle_s& lhs, const am_Handle_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs);
+inline bool operator!=(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs);
+inline bool operator!=(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs);
+inline bool operator!=(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs);
+inline bool operator!=(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs);
+inline bool operator!=(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Sink_s& lhs, const am_Sink_s& rhs);
+inline bool operator!=(const am_Sink_s& lhs, const am_Sink_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Source_s& lhs, const am_Source_s& rhs);
+inline bool operator!=(const am_Source_s& lhs, const am_Source_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Domain_s& lhs, const am_Domain_s& rhs);
+inline bool operator!=(const am_Domain_s& lhs, const am_Domain_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs);
+inline bool operator!=(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Connection_s& lhs, const am_Connection_s& rhs);
+inline bool operator!=(const am_Connection_s& lhs, const am_Connection_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Volumes_s& lhs, const am_Volumes_s& rhs);
+inline bool operator!=(const am_Volumes_s& lhs, const am_Volumes_s& rhs) {
+    return !(lhs == rhs);
+}
+
+
+static inline const char* getTypeCollectionName() {
+    static const char* typeCollectionName = "org.genivi.am";
+    return typeCollectionName;
+}
+
+inline CommonAPI::Version getTypeCollectionVersion() {
+    return CommonAPI::Version(2, 0);
+}
+
+} // namespace am
+
+} // namespace genivi
+} // namespace org
+
+namespace CommonAPI {
+
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_Availability_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_Availability_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Availability_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_Availability_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Availability_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_HotSink_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_HotSink_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_HotSink_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_HotSink_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_HotSink_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_ConnectionState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_ConnectionState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_ConnectionState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_ConnectionState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_ConnectionState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_DomainState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_DomainState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_DomainState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_DomainState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_DomainState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_EarlyDataType_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_EarlyDataType_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_EarlyDataType_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_EarlyDataType_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_EarlyDataType_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_Error_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_Error_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Error_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_Error_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Error_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_MuteState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_MuteState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_MuteState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_MuteState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_MuteState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_InterruptState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_InterruptState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_InterruptState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_InterruptState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_InterruptState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_VolumeType_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_VolumeType_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_VolumeType_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_VolumeType_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_VolumeType_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_NotificationStatus_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_NotificationStatus_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_NotificationStatus_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_NotificationStatus_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_NotificationStatus_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_Handle_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_Handle_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Handle_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_Handle_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Handle_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_SourceState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_SourceState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_SourceState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_SourceState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_SourceState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_RoutingReady_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_RoutingReady_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_RoutingReady_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_RoutingReady_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_RoutingReady_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+
+}
+
+
+namespace std {
+    //Hash for am_Availability_e
+    template<>
+    struct hash<org::genivi::am::am_Availability_e> {
+        inline size_t operator()(const org::genivi::am::am_Availability_e& am_Availability_e) const {
+            return static_cast<int32_t>(am_Availability_e);
+        }
+    };
+    //Hash for am_HotSink_e
+    template<>
+    struct hash<org::genivi::am::am_HotSink_e> {
+        inline size_t operator()(const org::genivi::am::am_HotSink_e& am_HotSink_e) const {
+            return static_cast<int32_t>(am_HotSink_e);
+        }
+    };
+    //Hash for am_ConnectionState_e
+    template<>
+    struct hash<org::genivi::am::am_ConnectionState_e> {
+        inline size_t operator()(const org::genivi::am::am_ConnectionState_e& am_ConnectionState_e) const {
+            return static_cast<int32_t>(am_ConnectionState_e);
+        }
+    };
+    //Hash for am_DomainState_e
+    template<>
+    struct hash<org::genivi::am::am_DomainState_e> {
+        inline size_t operator()(const org::genivi::am::am_DomainState_e& am_DomainState_e) const {
+            return static_cast<int32_t>(am_DomainState_e);
+        }
+    };
+    //Hash for am_EarlyDataType_e
+    template<>
+    struct hash<org::genivi::am::am_EarlyDataType_e> {
+        inline size_t operator()(const org::genivi::am::am_EarlyDataType_e& am_EarlyDataType_e) const {
+            return static_cast<int32_t>(am_EarlyDataType_e);
+        }
+    };
+    //Hash for am_Error_e
+    template<>
+    struct hash<org::genivi::am::am_Error_e> {
+        inline size_t operator()(const org::genivi::am::am_Error_e& am_Error_e) const {
+            return static_cast<int32_t>(am_Error_e);
+        }
+    };
+    //Hash for am_MuteState_e
+    template<>
+    struct hash<org::genivi::am::am_MuteState_e> {
+        inline size_t operator()(const org::genivi::am::am_MuteState_e& am_MuteState_e) const {
+            return static_cast<int32_t>(am_MuteState_e);
+        }
+    };
+    //Hash for am_InterruptState_e
+    template<>
+    struct hash<org::genivi::am::am_InterruptState_e> {
+        inline size_t operator()(const org::genivi::am::am_InterruptState_e& am_InterruptState_e) const {
+            return static_cast<int32_t>(am_InterruptState_e);
+        }
+    };
+    //Hash for am_VolumeType_e
+    template<>
+    struct hash<org::genivi::am::am_VolumeType_e> {
+        inline size_t operator()(const org::genivi::am::am_VolumeType_e& am_VolumeType_e) const {
+            return static_cast<int32_t>(am_VolumeType_e);
+        }
+    };
+    //Hash for am_NotificationStatus_e
+    template<>
+    struct hash<org::genivi::am::am_NotificationStatus_e> {
+        inline size_t operator()(const org::genivi::am::am_NotificationStatus_e& am_NotificationStatus_e) const {
+            return static_cast<int32_t>(am_NotificationStatus_e);
+        }
+    };
+    //Hash for am_Handle_e
+    template<>
+    struct hash<org::genivi::am::am_Handle_e> {
+        inline size_t operator()(const org::genivi::am::am_Handle_e& am_Handle_e) const {
+            return static_cast<int32_t>(am_Handle_e);
+        }
+    };
+    //Hash for am_SourceState_e
+    template<>
+    struct hash<org::genivi::am::am_SourceState_e> {
+        inline size_t operator()(const org::genivi::am::am_SourceState_e& am_SourceState_e) const {
+            return static_cast<int32_t>(am_SourceState_e);
+        }
+    };
+    //Hash for am_RoutingReady_e
+    template<>
+    struct hash<org::genivi::am::am_RoutingReady_e> {
+        inline size_t operator()(const org::genivi::am::am_RoutingReady_e& am_RoutingReady_e) const {
+            return static_cast<int32_t>(am_RoutingReady_e);
+        }
+    };
+}
+
+#endif // ORG_GENIVI_am_H_
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControl.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControl.h
new file mode 100644
index 0000000..106e5ad
--- /dev/null
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControl.h
@@ -0,0 +1,67 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * The interface towards the Controlling Instance (e.g HMI). It handles the
+ *  communication towards the HMI and other system components who need to interact
+ *  with the audiomanagement.
+There are two rules that have to be kept in mind
+ *  when implementing against this interface:
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Command_Control_H_
+#define ORG_GENIVI_AM_Command_Control_H_
+
+
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/types.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+class CommandControl {
+ public:
+    virtual ~CommandControl() { }
+
+    static inline const char* getInterfaceId();
+    static inline CommonAPI::Version getInterfaceVersion();
+};
+
+const char* CommandControl::getInterfaceId() {
+    static const char* interfaceId = "org.genivi.am.CommandControl";
+    return interfaceId;
+}
+
+CommonAPI::Version CommandControl::getInterfaceVersion() {
+    return CommonAPI::Version(2, 0);
+}
+
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+namespace CommonAPI {
+
+}
+
+
+namespace std {
+    //hashes for types
+
+    //hashes for error types
+}
+
+#endif // ORG_GENIVI_AM_Command_Control_H_
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.cpp b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.cpp
new file mode 100644
index 0000000..bf46af3
--- /dev/null
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.cpp
@@ -0,0 +1,651 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * The interface towards the Controlling Instance (e.g HMI). It handles the
+ *  communication towards the HMI and other system components who need to interact
+ *  with the audiomanagement.
+There are two rules that have to be kept in mind
+ *  when implementing against this interface:
+ * @author Christian Mueller
+ */
+#include "CommandControlDBusProxy.h"
+
+namespace org {
+namespace genivi {
+namespace am {
+
+std::shared_ptr<CommonAPI::DBus::DBusProxy> createCommandControlDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection) {
+    return std::make_shared<CommandControlDBusProxy>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection);
+}
+
+INITIALIZER(registerCommandControlDBusProxy) {
+    CommonAPI::DBus::DBusFactory::registerProxyFactoryMethod(CommandControl::getInterfaceId(),
+       &createCommandControlDBusProxy);
+}
+
+CommandControlDBusProxy::CommandControlDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection):
+        CommonAPI::DBus::DBusProxy(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyconnection)
+,        newMainConnection_(*this, "newMainConnection", "(qqqni)"),
+        removedMainConnection_(*this, "removedMainConnection", "q"),
+        newSink_(*this, "newSink", "(qs(iq)niq)"),
+        removedSink_(*this, "removedSink", "q"),
+        newSource_(*this, "newSource", "(qs(iq)q)"),
+        removedSource_(*this, "removedSource", "q"),
+        numberOfSinkClassesChanged_(*this, "numberOfSinkClassesChanged", ""),
+        numberOfSourceClassesChanged_(*this, "numberOfSourceClassesChanged", ""),
+        mainConnectionStateChanged_(*this, "mainConnectionStateChanged", "qi"),
+        mainSinkSoundPropertyChanged_(*this, "mainSinkSoundPropertyChanged", "q(qn)"),
+        mainSourceSoundPropertyChanged_(*this, "mainSourceSoundPropertyChanged", "q(qn)"),
+        sinkAvailabilityChanged_(*this, "sinkAvailabilityChanged", "q(iq)"),
+        sourceAvailabilityChanged_(*this, "sourceAvailabilityChanged", "q(iq)"),
+        volumeChanged_(*this, "volumeChanged", "qn"),
+        sinkMuteStateChanged_(*this, "sinkMuteStateChanged", "qi"),
+        systemPropertyChanged_(*this, "systemPropertyChanged", "(qn)"),
+        timingInformationChanged_(*this, "timingInformationChanged", "qn"),
+        sinkUpdated_(*this, "sinkUpdated", "qqa(qn)"),
+        sourceUpdated_(*this, "sourceUpdated", "qqa(qn)"),
+        sinkNotification_(*this, "sinkNotification", "q(qn)"),
+        sourceNotification_(*this, "sourceNotification", "q(qn)"),
+        mainSinkNotificationConfigurationChanged_(*this, "mainSinkNotificationConfigurationChanged", "q(qin)"),
+        mainSourceNotificationConfigurationChanged_(*this, "mainSourceNotificationConfigurationChanged", "q(qin)")
+    {
+    }
+
+
+CommandControlDBusProxy::NewMainConnectionEvent& CommandControlDBusProxy::getNewMainConnectionEvent() {
+    return newMainConnection_;
+}
+CommandControlDBusProxy::RemovedMainConnectionEvent& CommandControlDBusProxy::getRemovedMainConnectionEvent() {
+    return removedMainConnection_;
+}
+CommandControlDBusProxy::NewSinkEvent& CommandControlDBusProxy::getNewSinkEvent() {
+    return newSink_;
+}
+CommandControlDBusProxy::RemovedSinkEvent& CommandControlDBusProxy::getRemovedSinkEvent() {
+    return removedSink_;
+}
+CommandControlDBusProxy::NewSourceEvent& CommandControlDBusProxy::getNewSourceEvent() {
+    return newSource_;
+}
+CommandControlDBusProxy::RemovedSourceEvent& CommandControlDBusProxy::getRemovedSourceEvent() {
+    return removedSource_;
+}
+CommandControlDBusProxy::NumberOfSinkClassesChangedEvent& CommandControlDBusProxy::getNumberOfSinkClassesChangedEvent() {
+    return numberOfSinkClassesChanged_;
+}
+CommandControlDBusProxy::NumberOfSourceClassesChangedEvent& CommandControlDBusProxy::getNumberOfSourceClassesChangedEvent() {
+    return numberOfSourceClassesChanged_;
+}
+CommandControlDBusProxy::MainConnectionStateChangedEvent& CommandControlDBusProxy::getMainConnectionStateChangedEvent() {
+    return mainConnectionStateChanged_;
+}
+CommandControlDBusProxy::MainSinkSoundPropertyChangedEvent& CommandControlDBusProxy::getMainSinkSoundPropertyChangedEvent() {
+    return mainSinkSoundPropertyChanged_;
+}
+CommandControlDBusProxy::MainSourceSoundPropertyChangedEvent& CommandControlDBusProxy::getMainSourceSoundPropertyChangedEvent() {
+    return mainSourceSoundPropertyChanged_;
+}
+CommandControlDBusProxy::SinkAvailabilityChangedEvent& CommandControlDBusProxy::getSinkAvailabilityChangedEvent() {
+    return sinkAvailabilityChanged_;
+}
+CommandControlDBusProxy::SourceAvailabilityChangedEvent& CommandControlDBusProxy::getSourceAvailabilityChangedEvent() {
+    return sourceAvailabilityChanged_;
+}
+CommandControlDBusProxy::VolumeChangedEvent& CommandControlDBusProxy::getVolumeChangedEvent() {
+    return volumeChanged_;
+}
+CommandControlDBusProxy::SinkMuteStateChangedEvent& CommandControlDBusProxy::getSinkMuteStateChangedEvent() {
+    return sinkMuteStateChanged_;
+}
+CommandControlDBusProxy::SystemPropertyChangedEvent& CommandControlDBusProxy::getSystemPropertyChangedEvent() {
+    return systemPropertyChanged_;
+}
+CommandControlDBusProxy::TimingInformationChangedEvent& CommandControlDBusProxy::getTimingInformationChangedEvent() {
+    return timingInformationChanged_;
+}
+CommandControlDBusProxy::SinkUpdatedEvent& CommandControlDBusProxy::getSinkUpdatedEvent() {
+    return sinkUpdated_;
+}
+CommandControlDBusProxy::SourceUpdatedEvent& CommandControlDBusProxy::getSourceUpdatedEvent() {
+    return sourceUpdated_;
+}
+CommandControlDBusProxy::SinkNotificationEvent& CommandControlDBusProxy::getSinkNotificationEvent() {
+    return sinkNotification_;
+}
+CommandControlDBusProxy::SourceNotificationEvent& CommandControlDBusProxy::getSourceNotificationEvent() {
+    return sourceNotification_;
+}
+CommandControlDBusProxy::MainSinkNotificationConfigurationChangedEvent& CommandControlDBusProxy::getMainSinkNotificationConfigurationChangedEvent() {
+    return mainSinkNotificationConfigurationChanged_;
+}
+CommandControlDBusProxy::MainSourceNotificationConfigurationChangedEvent& CommandControlDBusProxy::getMainSourceNotificationConfigurationChangedEvent() {
+    return mainSourceNotificationConfigurationChanged_;
+}
+
+/**
+ * connects a source to sink
+(at)return E_OK on success, E_NOT_POSSIBLE on
+ *  failure, E_ALREADY_EXISTS if the connection does already exists
+ */
+void CommandControlDBusProxy::connect(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_mainConnectionID_t& mainConnectionID, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_sinkID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_mainConnectionID_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "connect",
+        "qq",
+        sourceID, sinkID,
+        callStatus
+        , mainConnectionID, error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::connectAsync(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, ConnectAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_sinkID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_mainConnectionID_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "connect",
+        "qq",
+        sourceID, sinkID, 
+        std::move(callback));
+}
+/**
+ * disconnects a mainConnection
+(at)return E_OK on successes, E_NON_EXISTENT if
+ *  the connection does not exist, E_NOT_POSSIBLE on error.
+ */
+void CommandControlDBusProxy::disconnect(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_mainConnectionID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "disconnect",
+        "q",
+        mainConnectionID,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::disconnectAsync(const am_mainConnectionID_t& mainConnectionID, DisconnectAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_mainConnectionID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "disconnect",
+        "q",
+        mainConnectionID, 
+        std::move(callback));
+}
+/**
+ * sets the volume for a sink
+(at)return E_OK on success, E_UNKOWN on error,
+ *  E_OUT_OF_RANGE in case the value is out of range
+ */
+void CommandControlDBusProxy::setVolume(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_mainVolume_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "setVolume",
+        "qn",
+        sinkID, volume,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setVolumeAsync(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, SetVolumeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_mainVolume_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "setVolume",
+        "qn",
+        sinkID, volume, 
+        std::move(callback));
+}
+/**
+ * This function is used to increment or decrement the current volume for a
+ *  sink.
+(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+ *  value is not in the given volume range.
+ */
+void CommandControlDBusProxy::volumeStep(const am_sinkID_t& sinkID, const int16_t& volStep, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, int16_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "volumeStep",
+        "qn",
+        sinkID, volStep,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volStep, VolumeStepAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, int16_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "volumeStep",
+        "qn",
+        sinkID, volStep, 
+        std::move(callback));
+}
+/**
+ * sets the mute state of a sink
+(at)return E_OK on success, E_UNKNOWN on error.
+ *  If the mute state is already the desired one, the Daemon will return E_OK.
+ */
+void CommandControlDBusProxy::setSinkMuteState(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_MuteState_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "setSinkMuteState",
+        "qi",
+        sinkID, muteState,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setSinkMuteStateAsync(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, SetSinkMuteStateAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_MuteState_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "setSinkMuteState",
+        "qi",
+        sinkID, muteState, 
+        std::move(callback));
+}
+/**
+ * This method is used to set sound properties, e.g. Equalizer Values. Since the
+ *  capabilities of the system can differ, the exact key value pairs can be
+ *  extended in each product
+(at)return E_OK on success, E_OUT_OF_RANGE if value
+ *  exceeds range, E_UNKNOWN in case of an error
+ */
+void CommandControlDBusProxy::setMainSinkSoundProperty(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_MainSoundProperty_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "setMainSinkSoundProperty",
+        "q(qn)",
+        sinkID, soundProperty,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setMainSinkSoundPropertyAsync(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, SetMainSinkSoundPropertyAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_MainSoundProperty_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "setMainSinkSoundProperty",
+        "q(qn)",
+        sinkID, soundProperty, 
+        std::move(callback));
+}
+/**
+ * This method is used to set sound properties, e.g. Equalizer Values. Since the
+ *  capabilities of the system can differ, the exact key value pairs can be
+ *  extended in each product
+(at)return E_OK on success, E_OUT_OF_RANGE if value
+ *  exceeds range, E_UNKNOWN in case of an error
+ */
+void CommandControlDBusProxy::setMainSourceSoundProperty(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_MainSoundProperty_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "setMainSourceSoundProperty",
+        "q(qn)",
+        sourceID, soundProperty,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setMainSourceSoundPropertyAsync(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, SetMainSourceSoundPropertyAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_MainSoundProperty_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "setMainSourceSoundProperty",
+        "q(qn)",
+        sourceID, soundProperty, 
+        std::move(callback));
+}
+/**
+ * is used to set a specific system property.
+(at)return E_OK on success,
+ *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+ */
+void CommandControlDBusProxy::setSystemProperty(const am_SystemProperty_s& property, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_SystemProperty_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "setSystemProperty",
+        "(qn)",
+        property,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setSystemPropertyAsync(const am_SystemProperty_s& property, SetSystemPropertyAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_SystemProperty_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "setSystemProperty",
+        "(qn)",
+        property, 
+        std::move(callback));
+}
+/**
+ * returns the actual list of MainConnections
+(at)return E_OK on success,
+ *  E_DATABASE_ERROR on error
+ */
+void CommandControlDBusProxy::getListMainConnections(CommonAPI::CallStatus& callStatus, am_MainConnection_L& listConnections, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_MainConnection_L, am_Error_e> >::callMethodWithReply(
+        *this,
+        "getListMainConnections",
+        "",
+        callStatus
+        , listConnections, error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainConnectionsAsync(GetListMainConnectionsAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_MainConnection_L, am_Error_e> >::callMethodAsync(
+        *this,
+        "getListMainConnections",
+        "",
+        std::move(callback));
+}
+/**
+ * returns the actual list of Sinks
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
+ */
+void CommandControlDBusProxy::getListMainSinks(CommonAPI::CallStatus& callStatus, am_SinkType_L& listMainSinks, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_SinkType_L, am_Error_e> >::callMethodWithReply(
+        *this,
+        "getListMainSinks",
+        "",
+        callStatus
+        , listMainSinks, error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSinksAsync(GetListMainSinksAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_SinkType_L, am_Error_e> >::callMethodAsync(
+        *this,
+        "getListMainSinks",
+        "",
+        std::move(callback));
+}
+/**
+ * returns the actual list of Sources
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
+ */
+void CommandControlDBusProxy::getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_SourceType_L, am_Error_e> >::callMethodWithReply(
+        *this,
+        "getListMainSources",
+        "",
+        callStatus
+        , listMainSources, error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSourcesAsync(GetListMainSourcesAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_SourceType_L, am_Error_e> >::callMethodAsync(
+        *this,
+        "getListMainSources",
+        "",
+        std::move(callback));
+}
+/**
+ * This is used to retrieve all source sound properties related to a source.
+ *  Returns a vector of the sound properties and values as pair
+(at)return E_OK on
+ *  success, E_DATABASE_ERROR on error
+ */
+void CommandControlDBusProxy::getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_MainSoundProperty_L, am_Error_e> >::callMethodWithReply(
+        *this,
+        "getListMainSinkSoundProperties",
+        "q",
+        sinkID,
+        callStatus
+        , listSoundProperties, error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSinkSoundPropertiesAsync(const am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_MainSoundProperty_L, am_Error_e> >::callMethodAsync(
+        *this,
+        "getListMainSinkSoundProperties",
+        "q",
+        sinkID, 
+        std::move(callback));
+}
+/**
+ * This is used to retrieve all source sound properties related to a
+ *  source.
+(at)return E_OK on success, E_DATABASE_ERROR on error
+ */
+void CommandControlDBusProxy::getListMainSourceSoundProperties(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_MainSoundProperty_L, am_Error_e> >::callMethodWithReply(
+        *this,
+        "getListMainSourceSoundProperties",
+        "q",
+        sourceID,
+        callStatus
+        , listSourceProperties, error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSourceSoundPropertiesAsync(const am_sourceID_t& sourceID, GetListMainSourceSoundPropertiesAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_MainSoundProperty_L, am_Error_e> >::callMethodAsync(
+        *this,
+        "getListMainSourceSoundProperties",
+        "q",
+        sourceID, 
+        std::move(callback));
+}
+/**
+ * This is used to retrieve SourceClass Information of all source classes
+ *  
+(at)return E_OK on success, E_DATABASE_ERROR on error
+ */
+void CommandControlDBusProxy::getListSourceClasses(CommonAPI::CallStatus& callStatus, am_SourceClass_L& listSourceClasses, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_SourceClass_L, am_Error_e> >::callMethodWithReply(
+        *this,
+        "getListSourceClasses",
+        "",
+        callStatus
+        , listSourceClasses, error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListSourceClassesAsync(GetListSourceClassesAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_SourceClass_L, am_Error_e> >::callMethodAsync(
+        *this,
+        "getListSourceClasses",
+        "",
+        std::move(callback));
+}
+/**
+ * This is used to retrieve SinkClass Information of all sink classes 
+(at)return
+ *  E_OK on success, E_DATABASE_ERROR on error
+ */
+void CommandControlDBusProxy::getListSinkClasses(CommonAPI::CallStatus& callStatus, am_SinkClass_L& listSinkClasses, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_SinkClass_L, am_Error_e> >::callMethodWithReply(
+        *this,
+        "getListSinkClasses",
+        "",
+        callStatus
+        , listSinkClasses, error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListSinkClassesAsync(GetListSinkClassesAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_SinkClass_L, am_Error_e> >::callMethodAsync(
+        *this,
+        "getListSinkClasses",
+        "",
+        std::move(callback));
+}
+/**
+ * Retrieves a complete list of all systemProperties.
+(at)return E_OK on success,
+ *  E_DATABASE_ERROR on error
+ */
+void CommandControlDBusProxy::getListSystemProperties(CommonAPI::CallStatus& callStatus, am_SystemProperty_L& listSystemProperties, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_SystemProperty_L, am_Error_e> >::callMethodWithReply(
+        *this,
+        "getListSystemProperties",
+        "",
+        callStatus
+        , listSystemProperties, error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_SystemProperty_L, am_Error_e> >::callMethodAsync(
+        *this,
+        "getListSystemProperties",
+        "",
+        std::move(callback));
+}
+/**
+ * returns the delay in ms that the audiopath for the given mainConnection
+ *  has
+(at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+ *  yet retrieved, E_DATABASE_ERROR on read error on the database
+ */
+void CommandControlDBusProxy::getTimingInformation(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_timeSync_t& delay, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_mainConnectionID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_timeSync_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "getTimingInformation",
+        "q",
+        mainConnectionID,
+        callStatus
+        , delay, error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getTimingInformationAsync(const am_mainConnectionID_t& mainConnectionID, GetTimingInformationAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_mainConnectionID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_timeSync_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "getTimingInformation",
+        "q",
+        mainConnectionID, 
+        std::move(callback));
+}
+/**
+ * Retrieves the list of MainNotifications for a sink. Does not return the
+ *  possible ones.
+ */
+void CommandControlDBusProxy::getListMainSinkNotificationConfigurations(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_NotificationConfiguration_L, am_Error_e> >::callMethodWithReply(
+        *this,
+        "getListMainSinkNotificationConfigurations",
+        "q",
+        sinkID,
+        callStatus
+        , listMainNotificationConfigurations, error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSinkNotificationConfigurationsAsync(const am_sinkID_t& sinkID, GetListMainSinkNotificationConfigurationsAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_NotificationConfiguration_L, am_Error_e> >::callMethodAsync(
+        *this,
+        "getListMainSinkNotificationConfigurations",
+        "q",
+        sinkID, 
+        std::move(callback));
+}
+/**
+ * Retrieves the list of MainNotifications for a source. Does not return the
+ *  possible ones.
+ */
+void CommandControlDBusProxy::getListMainSourceNotificationConfigurations(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_NotificationConfiguration_L, am_Error_e> >::callMethodWithReply(
+        *this,
+        "getListMainSourceNotificationConfigurations",
+        "q",
+        sourceID,
+        callStatus
+        , listMainNotificationConfigurations, error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::getListMainSourceNotificationConfigurationsAsync(const am_sourceID_t& sourceID, GetListMainSourceNotificationConfigurationsAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_NotificationConfiguration_L, am_Error_e> >::callMethodAsync(
+        *this,
+        "getListMainSourceNotificationConfigurations",
+        "q",
+        sourceID, 
+        std::move(callback));
+}
+/**
+ * sets a MainNotificationConfiuration. This can be used to turn on an off
+ *  notifications an to change the mode of the configuration.
+(at)return E_OK on
+ *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+ */
+void CommandControlDBusProxy::setMainSinkNotificationConfiguration(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_NotificationConfiguration_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "setMainSinkNotificationConfiguration",
+        "q(qin)",
+        sinkID, mainNotificationConfiguration,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setMainSinkNotificationConfigurationAsync(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSinkNotificationConfigurationAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_NotificationConfiguration_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "setMainSinkNotificationConfiguration",
+        "q(qin)",
+        sinkID, mainNotificationConfiguration, 
+        std::move(callback));
+}
+/**
+ * sets a MainNotificationConfiuration. This can be used to turn on an off
+ *  notifications an to change the mode of the configuration.
+(at)return E_OK on
+ *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+ */
+void CommandControlDBusProxy::setMainSourceNotificationConfiguration(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_NotificationConfiguration_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "setMainSourceNotificationConfiguration",
+        "q(qin)",
+        sourceID, mainNotificationConfiguration,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> CommandControlDBusProxy::setMainSourceNotificationConfigurationAsync(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSourceNotificationConfigurationAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_NotificationConfiguration_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "setMainSourceNotificationConfiguration",
+        "q(qin)",
+        sourceID, mainNotificationConfiguration, 
+        std::move(callback));
+}
+
+
+
+void CommandControlDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
+    ownVersionMajor = 2;
+    ownVersionMinor = 0;
+}
+
+} // namespace am
+} // namespace genivi
+} // namespace org
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.h
new file mode 100644
index 0000000..c2a53ca
--- /dev/null
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusProxy.h
@@ -0,0 +1,266 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * The interface towards the Controlling Instance (e.g HMI). It handles the
+ *  communication towards the HMI and other system components who need to interact
+ *  with the audiomanagement.
+There are two rules that have to be kept in mind
+ *  when implementing against this interface:
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Command_Control_DBUS_PROXY_H_
+#define ORG_GENIVI_AM_Command_Control_DBUS_PROXY_H_
+
+#include <org/genivi/am/CommandControlProxyBase.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/DBus/DBusFactory.h>
+#include <CommonAPI/DBus/DBusProxy.h>
+#include <CommonAPI/DBus/DBusEvent.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+#include <string>
+
+namespace org {
+namespace genivi {
+namespace am {
+
+class CommandControlDBusProxy: virtual public CommandControlProxyBase, virtual public CommonAPI::DBus::DBusProxy {
+ public:
+    CommandControlDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection);
+
+    virtual ~CommandControlDBusProxy() { }
+
+
+    virtual NewMainConnectionEvent& getNewMainConnectionEvent();
+    virtual RemovedMainConnectionEvent& getRemovedMainConnectionEvent();
+    virtual NewSinkEvent& getNewSinkEvent();
+    virtual RemovedSinkEvent& getRemovedSinkEvent();
+    virtual NewSourceEvent& getNewSourceEvent();
+    virtual RemovedSourceEvent& getRemovedSourceEvent();
+    virtual NumberOfSinkClassesChangedEvent& getNumberOfSinkClassesChangedEvent();
+    virtual NumberOfSourceClassesChangedEvent& getNumberOfSourceClassesChangedEvent();
+    virtual MainConnectionStateChangedEvent& getMainConnectionStateChangedEvent();
+    virtual MainSinkSoundPropertyChangedEvent& getMainSinkSoundPropertyChangedEvent();
+    virtual MainSourceSoundPropertyChangedEvent& getMainSourceSoundPropertyChangedEvent();
+    virtual SinkAvailabilityChangedEvent& getSinkAvailabilityChangedEvent();
+    virtual SourceAvailabilityChangedEvent& getSourceAvailabilityChangedEvent();
+    virtual VolumeChangedEvent& getVolumeChangedEvent();
+    virtual SinkMuteStateChangedEvent& getSinkMuteStateChangedEvent();
+    virtual SystemPropertyChangedEvent& getSystemPropertyChangedEvent();
+    virtual TimingInformationChangedEvent& getTimingInformationChangedEvent();
+    virtual SinkUpdatedEvent& getSinkUpdatedEvent();
+    virtual SourceUpdatedEvent& getSourceUpdatedEvent();
+    virtual SinkNotificationEvent& getSinkNotificationEvent();
+    virtual SourceNotificationEvent& getSourceNotificationEvent();
+    virtual MainSinkNotificationConfigurationChangedEvent& getMainSinkNotificationConfigurationChangedEvent();
+    virtual MainSourceNotificationConfigurationChangedEvent& getMainSourceNotificationConfigurationChangedEvent();
+
+    /**
+     * connects a source to sink
+    (at)return E_OK on success, E_NOT_POSSIBLE on
+     *  failure, E_ALREADY_EXISTS if the connection does already exists
+     */
+    virtual void connect(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_mainConnectionID_t& mainConnectionID, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> connectAsync(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, ConnectAsyncCallback callback);
+    /**
+     * disconnects a mainConnection
+    (at)return E_OK on successes, E_NON_EXISTENT if
+     *  the connection does not exist, E_NOT_POSSIBLE on error.
+     */
+    virtual void disconnect(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> disconnectAsync(const am_mainConnectionID_t& mainConnectionID, DisconnectAsyncCallback callback);
+    /**
+     * sets the volume for a sink
+    (at)return E_OK on success, E_UNKOWN on error,
+     *  E_OUT_OF_RANGE in case the value is out of range
+     */
+    virtual void setVolume(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> setVolumeAsync(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, SetVolumeAsyncCallback callback);
+    /**
+     * This function is used to increment or decrement the current volume for a
+     *  sink.
+    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+     *  value is not in the given volume range.
+     */
+    virtual void volumeStep(const am_sinkID_t& sinkID, const int16_t& volStep, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volStep, VolumeStepAsyncCallback callback);
+    /**
+     * sets the mute state of a sink
+    (at)return E_OK on success, E_UNKNOWN on error.
+     *  If the mute state is already the desired one, the Daemon will return E_OK.
+     */
+    virtual void setSinkMuteState(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> setSinkMuteStateAsync(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, SetSinkMuteStateAsyncCallback callback);
+    /**
+     * This method is used to set sound properties, e.g. Equalizer Values. Since the
+     *  capabilities of the system can differ, the exact key value pairs can be
+     *  extended in each product
+    (at)return E_OK on success, E_OUT_OF_RANGE if value
+     *  exceeds range, E_UNKNOWN in case of an error
+     */
+    virtual void setMainSinkSoundProperty(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> setMainSinkSoundPropertyAsync(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, SetMainSinkSoundPropertyAsyncCallback callback);
+    /**
+     * This method is used to set sound properties, e.g. Equalizer Values. Since the
+     *  capabilities of the system can differ, the exact key value pairs can be
+     *  extended in each product
+    (at)return E_OK on success, E_OUT_OF_RANGE if value
+     *  exceeds range, E_UNKNOWN in case of an error
+     */
+    virtual void setMainSourceSoundProperty(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> setMainSourceSoundPropertyAsync(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, SetMainSourceSoundPropertyAsyncCallback callback);
+    /**
+     * is used to set a specific system property.
+    (at)return E_OK on success,
+     *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+     */
+    virtual void setSystemProperty(const am_SystemProperty_s& property, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> setSystemPropertyAsync(const am_SystemProperty_s& property, SetSystemPropertyAsyncCallback callback);
+    /**
+     * returns the actual list of MainConnections
+    (at)return E_OK on success,
+     *  E_DATABASE_ERROR on error
+     */
+    virtual void getListMainConnections(CommonAPI::CallStatus& callStatus, am_MainConnection_L& listConnections, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> getListMainConnectionsAsync(GetListMainConnectionsAsyncCallback callback);
+    /**
+     * returns the actual list of Sinks
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
+     */
+    virtual void getListMainSinks(CommonAPI::CallStatus& callStatus, am_SinkType_L& listMainSinks, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> getListMainSinksAsync(GetListMainSinksAsyncCallback callback);
+    /**
+     * returns the actual list of Sources
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
+     */
+    virtual void getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> getListMainSourcesAsync(GetListMainSourcesAsyncCallback callback);
+    /**
+     * This is used to retrieve all source sound properties related to a source.
+     *  Returns a vector of the sound properties and values as pair
+    (at)return E_OK on
+     *  success, E_DATABASE_ERROR on error
+     */
+    virtual void getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> getListMainSinkSoundPropertiesAsync(const am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback);
+    /**
+     * This is used to retrieve all source sound properties related to a
+     *  source.
+    (at)return E_OK on success, E_DATABASE_ERROR on error
+     */
+    virtual void getListMainSourceSoundProperties(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> getListMainSourceSoundPropertiesAsync(const am_sourceID_t& sourceID, GetListMainSourceSoundPropertiesAsyncCallback callback);
+    /**
+     * This is used to retrieve SourceClass Information of all source classes
+     *  
+    (at)return E_OK on success, E_DATABASE_ERROR on error
+     */
+    virtual void getListSourceClasses(CommonAPI::CallStatus& callStatus, am_SourceClass_L& listSourceClasses, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> getListSourceClassesAsync(GetListSourceClassesAsyncCallback callback);
+    /**
+     * This is used to retrieve SinkClass Information of all sink classes 
+    (at)return
+     *  E_OK on success, E_DATABASE_ERROR on error
+     */
+    virtual void getListSinkClasses(CommonAPI::CallStatus& callStatus, am_SinkClass_L& listSinkClasses, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> getListSinkClassesAsync(GetListSinkClassesAsyncCallback callback);
+    /**
+     * Retrieves a complete list of all systemProperties.
+    (at)return E_OK on success,
+     *  E_DATABASE_ERROR on error
+     */
+    virtual void getListSystemProperties(CommonAPI::CallStatus& callStatus, am_SystemProperty_L& listSystemProperties, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> getListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback callback);
+    /**
+     * returns the delay in ms that the audiopath for the given mainConnection
+     *  has
+    (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+     *  yet retrieved, E_DATABASE_ERROR on read error on the database
+     */
+    virtual void getTimingInformation(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_timeSync_t& delay, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> getTimingInformationAsync(const am_mainConnectionID_t& mainConnectionID, GetTimingInformationAsyncCallback callback);
+    /**
+     * Retrieves the list of MainNotifications for a sink. Does not return the
+     *  possible ones.
+     */
+    virtual void getListMainSinkNotificationConfigurations(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> getListMainSinkNotificationConfigurationsAsync(const am_sinkID_t& sinkID, GetListMainSinkNotificationConfigurationsAsyncCallback callback);
+    /**
+     * Retrieves the list of MainNotifications for a source. Does not return the
+     *  possible ones.
+     */
+    virtual void getListMainSourceNotificationConfigurations(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> getListMainSourceNotificationConfigurationsAsync(const am_sourceID_t& sourceID, GetListMainSourceNotificationConfigurationsAsyncCallback callback);
+    /**
+     * sets a MainNotificationConfiuration. This can be used to turn on an off
+     *  notifications an to change the mode of the configuration.
+    (at)return E_OK on
+     *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+     */
+    virtual void setMainSinkNotificationConfiguration(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> setMainSinkNotificationConfigurationAsync(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSinkNotificationConfigurationAsyncCallback callback);
+    /**
+     * sets a MainNotificationConfiuration. This can be used to turn on an off
+     *  notifications an to change the mode of the configuration.
+    (at)return E_OK on
+     *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+     */
+    virtual void setMainSourceNotificationConfiguration(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> setMainSourceNotificationConfigurationAsync(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSourceNotificationConfigurationAsyncCallback callback);
+
+
+    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;
+
+ private:
+
+    CommonAPI::DBus::DBusEvent<NewMainConnectionEvent> newMainConnection_;
+    CommonAPI::DBus::DBusEvent<RemovedMainConnectionEvent> removedMainConnection_;
+    CommonAPI::DBus::DBusEvent<NewSinkEvent> newSink_;
+    CommonAPI::DBus::DBusEvent<RemovedSinkEvent> removedSink_;
+    CommonAPI::DBus::DBusEvent<NewSourceEvent> newSource_;
+    CommonAPI::DBus::DBusEvent<RemovedSourceEvent> removedSource_;
+    CommonAPI::DBus::DBusEvent<NumberOfSinkClassesChangedEvent> numberOfSinkClassesChanged_;
+    CommonAPI::DBus::DBusEvent<NumberOfSourceClassesChangedEvent> numberOfSourceClassesChanged_;
+    CommonAPI::DBus::DBusEvent<MainConnectionStateChangedEvent> mainConnectionStateChanged_;
+    CommonAPI::DBus::DBusEvent<MainSinkSoundPropertyChangedEvent> mainSinkSoundPropertyChanged_;
+    CommonAPI::DBus::DBusEvent<MainSourceSoundPropertyChangedEvent> mainSourceSoundPropertyChanged_;
+    CommonAPI::DBus::DBusEvent<SinkAvailabilityChangedEvent> sinkAvailabilityChanged_;
+    CommonAPI::DBus::DBusEvent<SourceAvailabilityChangedEvent> sourceAvailabilityChanged_;
+    CommonAPI::DBus::DBusEvent<VolumeChangedEvent> volumeChanged_;
+    CommonAPI::DBus::DBusEvent<SinkMuteStateChangedEvent> sinkMuteStateChanged_;
+    CommonAPI::DBus::DBusEvent<SystemPropertyChangedEvent> systemPropertyChanged_;
+    CommonAPI::DBus::DBusEvent<TimingInformationChangedEvent> timingInformationChanged_;
+    CommonAPI::DBus::DBusEvent<SinkUpdatedEvent> sinkUpdated_;
+    CommonAPI::DBus::DBusEvent<SourceUpdatedEvent> sourceUpdated_;
+    CommonAPI::DBus::DBusEvent<SinkNotificationEvent> sinkNotification_;
+    CommonAPI::DBus::DBusEvent<SourceNotificationEvent> sourceNotification_;
+    CommonAPI::DBus::DBusEvent<MainSinkNotificationConfigurationChangedEvent> mainSinkNotificationConfigurationChanged_;
+    CommonAPI::DBus::DBusEvent<MainSourceNotificationConfigurationChangedEvent> mainSourceNotificationConfigurationChanged_;
+
+};
+
+
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Command_Control_DBUS_PROXY_H_
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.cpp b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.cpp
new file mode 100644
index 0000000..6da5cfd
--- /dev/null
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.cpp
@@ -0,0 +1,1096 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+#include "CommandControlDBusStubAdapter.h"
+#include <org/genivi/am/CommandControl.h>
+
+namespace org {
+namespace genivi {
+namespace am {
+
+std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createCommandControlDBusStubAdapter(
+                   const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                   const std::string& commonApiAddress,
+                   const std::string& interfaceName,
+                   const std::string& busName,
+                   const std::string& objectPath,
+                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection,
+                   const std::shared_ptr<CommonAPI::StubBase>& stubBase) {
+    return std::make_shared<CommandControlDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
+}
+
+INITIALIZER(registerCommandControlDBusStubAdapter) {
+    CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(CommandControl::getInterfaceId(),
+                                                               &createCommandControlDBusStubAdapter);
+}
+
+
+
+CommandControlDBusStubAdapterInternal::~CommandControlDBusStubAdapterInternal() {
+    deactivateManagedInstances();
+    CommandControlDBusStubAdapterHelper::deinit();
+}
+
+void CommandControlDBusStubAdapterInternal::deactivateManagedInstances() {
+
+}
+
+const char* CommandControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
+    static const std::string introspectionData =
+        "<method name=\"getInterfaceVersion\">\n"
+            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
+        "</method>\n"
+        /**
+         * Callback that is called when the number of connections change
+         */
+        "<signal name=\"newMainConnection\">\n"
+            "<arg name=\"mainConnection\" type=\"(qqqni)\" />\n"
+        "</signal>\n"
+        /**
+         * Callback that is called when the number of connections change
+         */
+        "<signal name=\"removedMainConnection\">\n"
+            "<arg name=\"mainConnection\" type=\"q\" />\n"
+        "</signal>\n"
+        /**
+         * Callback that is called when the number of sinks change
+         */
+        "<signal name=\"newSink\">\n"
+            "<arg name=\"sink\" type=\"(qs(iq)niq)\" />\n"
+        "</signal>\n"
+        /**
+         * Callback that is called when the number of sinks change
+         */
+        "<signal name=\"removedSink\">\n"
+            "<arg name=\"sinkID\" type=\"q\" />\n"
+        "</signal>\n"
+        /**
+         * Callback that is called when the number of sources change
+         */
+        "<signal name=\"newSource\">\n"
+            "<arg name=\"source\" type=\"(qs(iq)q)\" />\n"
+        "</signal>\n"
+        /**
+         * Callback that is called when the number of sources change
+         */
+        "<signal name=\"removedSource\">\n"
+            "<arg name=\"source\" type=\"q\" />\n"
+        "</signal>\n"
+        /**
+         * this callback is fired if the number of sink classes changed
+         */
+        "<signal name=\"numberOfSinkClassesChanged\">\n"
+        "</signal>\n"
+        /**
+         * this callback is fired if the number of source classes changed
+         */
+        "<signal name=\"numberOfSourceClassesChanged\">\n"
+        "</signal>\n"
+        /**
+         * This callback is called when the ConnectionState of a connection changed.
+         */
+        "<signal name=\"mainConnectionStateChanged\">\n"
+            "<arg name=\"connectionID\" type=\"q\" />\n"
+            "<arg name=\"connectionState\" type=\"i\" />\n"
+        "</signal>\n"
+        /**
+         * this callback indicates that a sinkSoundProperty has changed.
+         */
+        "<signal name=\"mainSinkSoundPropertyChanged\">\n"
+            "<arg name=\"sinkID\" type=\"q\" />\n"
+            "<arg name=\"soundProperty\" type=\"(qn)\" />\n"
+        "</signal>\n"
+        /**
+         * this callback indicates that a sourceSoundProperty has changed.
+         */
+        "<signal name=\"mainSourceSoundPropertyChanged\">\n"
+            "<arg name=\"sourceID\" type=\"q\" />\n"
+            "<arg name=\"soundProperty\" type=\"(qn)\" />\n"
+        "</signal>\n"
+        /**
+         * this callback is called when the availability of a sink has changed
+         */
+        "<signal name=\"sinkAvailabilityChanged\">\n"
+            "<arg name=\"sinkID\" type=\"q\" />\n"
+            "<arg name=\"availability\" type=\"(iq)\" />\n"
+        "</signal>\n"
+        /**
+         * this callback is called when the availability of source has changed.
+         */
+        "<signal name=\"sourceAvailabilityChanged\">\n"
+            "<arg name=\"sourceID\" type=\"q\" />\n"
+            "<arg name=\"availability\" type=\"(iq)\" />\n"
+        "</signal>\n"
+        /**
+         * this callback indicates a volume change on the indicated sink
+         */
+        "<signal name=\"volumeChanged\">\n"
+            "<arg name=\"sinkID\" type=\"q\" />\n"
+            "<arg name=\"volume\" type=\"n\" />\n"
+        "</signal>\n"
+        /**
+         * this callback indicates a mute state change on a sink.
+         */
+        "<signal name=\"sinkMuteStateChanged\">\n"
+            "<arg name=\"sinkID\" type=\"q\" />\n"
+            "<arg name=\"muteState\" type=\"i\" />\n"
+        "</signal>\n"
+        /**
+         * is fired if a systemProperty changed
+         */
+        "<signal name=\"systemPropertyChanged\">\n"
+            "<arg name=\"systemProperty\" type=\"(qn)\" />\n"
+        "</signal>\n"
+        /**
+         * This callback is fired if the timinginformation for a mainConnectionID changed
+         */
+        "<signal name=\"timingInformationChanged\">\n"
+            "<arg name=\"mainConnectionID\" type=\"q\" />\n"
+            "<arg name=\"time\" type=\"n\" />\n"
+        "</signal>\n"
+        /**
+         * This callback is called when a sink is updated.
+         */
+        "<signal name=\"sinkUpdated\">\n"
+            "<arg name=\"sinkID\" type=\"q\" />\n"
+            "<arg name=\"sinkClassID\" type=\"q\" />\n"
+            "<arg name=\"listMainSoundProperties\" type=\"a(qn)\" />\n"
+        "</signal>\n"
+        /**
+         * This callback is called when a source is updated.
+         */
+        "<signal name=\"sourceUpdated\">\n"
+            "<arg name=\"sourceID\" type=\"q\" />\n"
+            "<arg name=\"sourceClassID\" type=\"q\" />\n"
+            "<arg name=\"listMainSoundProperties\" type=\"a(qn)\" />\n"
+        "</signal>\n"
+        /**
+         * This callback is called when a notificated value of a sink changes.
+         */
+        "<signal name=\"sinkNotification\">\n"
+            "<arg name=\"sinkID\" type=\"q\" />\n"
+            "<arg name=\"notification\" type=\"(qn)\" />\n"
+        "</signal>\n"
+        /**
+         * This callback is called when a notifcated value of a source changes.
+         */
+        "<signal name=\"sourceNotification\">\n"
+            "<arg name=\"sourceID\" type=\"q\" />\n"
+            "<arg name=\"notification\" type=\"(qn)\" />\n"
+        "</signal>\n"
+        /**
+         * This callback is triggered when a mainNotificationConfiguration is changed.
+         */
+        "<signal name=\"mainSinkNotificationConfigurationChanged\">\n"
+            "<arg name=\"sinkID\" type=\"q\" />\n"
+            "<arg name=\"mainNotificationConfiguration\" type=\"(qin)\" />\n"
+        "</signal>\n"
+        /**
+         * This callback is triggered when a mainNotificationConfiguration is changed.
+         */
+        "<signal name=\"mainSourceNotificationConfigurationChanged\">\n"
+            "<arg name=\"sourceID\" type=\"q\" />\n"
+            "<arg name=\"mainNotificationConfiguration\" type=\"(qin)\" />\n"
+        "</signal>\n"
+        /**
+         * connects a source to sink
+        (at)return E_OK on success, E_NOT_POSSIBLE on
+         *  failure, E_ALREADY_EXISTS if the connection does already exists
+         */
+        "<method name=\"connect\">\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"mainConnectionID\" type=\"q\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * disconnects a mainConnection
+        (at)return E_OK on successes, E_NON_EXISTENT if
+         *  the connection does not exist, E_NOT_POSSIBLE on error.
+         */
+        "<method name=\"disconnect\">\n"
+            "<arg name=\"mainConnectionID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * sets the volume for a sink
+        (at)return E_OK on success, E_UNKOWN on error,
+         *  E_OUT_OF_RANGE in case the value is out of range
+         */
+        "<method name=\"setVolume\">\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * This function is used to increment or decrement the current volume for a
+         *  sink.
+        (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+         *  value is not in the given volume range.
+         */
+        "<method name=\"volumeStep\">\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"volStep\" type=\"n\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * sets the mute state of a sink
+        (at)return E_OK on success, E_UNKNOWN on error.
+         *  If the mute state is already the desired one, the Daemon will return E_OK.
+         */
+        "<method name=\"setSinkMuteState\">\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"muteState\" type=\"i\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * This method is used to set sound properties, e.g. Equalizer Values. Since the
+         *  capabilities of the system can differ, the exact key value pairs can be
+         *  extended in each product
+        (at)return E_OK on success, E_OUT_OF_RANGE if value
+         *  exceeds range, E_UNKNOWN in case of an error
+         */
+        "<method name=\"setMainSinkSoundProperty\">\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"soundProperty\" type=\"(qn)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * This method is used to set sound properties, e.g. Equalizer Values. Since the
+         *  capabilities of the system can differ, the exact key value pairs can be
+         *  extended in each product
+        (at)return E_OK on success, E_OUT_OF_RANGE if value
+         *  exceeds range, E_UNKNOWN in case of an error
+         */
+        "<method name=\"setMainSourceSoundProperty\">\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"soundProperty\" type=\"(qn)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * is used to set a specific system property.
+        (at)return E_OK on success,
+         *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+         */
+        "<method name=\"setSystemProperty\">\n"
+            "<arg name=\"property\" type=\"(qn)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * returns the actual list of MainConnections
+        (at)return E_OK on success,
+         *  E_DATABASE_ERROR on error
+         */
+        "<method name=\"getListMainConnections\">\n"
+            "<arg name=\"listConnections\" type=\"a(qqqni)\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * returns the actual list of Sinks
+        (at)return E_OK on success, E_DATABASE_ERROR
+         *  on error
+         */
+        "<method name=\"getListMainSinks\">\n"
+            "<arg name=\"listMainSinks\" type=\"a(qs(iq)niq)\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * returns the actual list of Sources
+        (at)return E_OK on success, E_DATABASE_ERROR
+         *  on error
+         */
+        "<method name=\"getListMainSources\">\n"
+            "<arg name=\"listMainSources\" type=\"a(qs(iq)q)\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * This is used to retrieve all source sound properties related to a source.
+         *  Returns a vector of the sound properties and values as pair
+        (at)return E_OK on
+         *  success, E_DATABASE_ERROR on error
+         */
+        "<method name=\"getListMainSinkSoundProperties\">\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"listSoundProperties\" type=\"a(qn)\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * This is used to retrieve all source sound properties related to a
+         *  source.
+        (at)return E_OK on success, E_DATABASE_ERROR on error
+         */
+        "<method name=\"getListMainSourceSoundProperties\">\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"listSourceProperties\" type=\"a(qn)\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * This is used to retrieve SourceClass Information of all source classes
+         *  
+        (at)return E_OK on success, E_DATABASE_ERROR on error
+         */
+        "<method name=\"getListSourceClasses\">\n"
+            "<arg name=\"listSourceClasses\" type=\"a(qsa(qn))\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * This is used to retrieve SinkClass Information of all sink classes 
+        (at)return
+         *  E_OK on success, E_DATABASE_ERROR on error
+         */
+        "<method name=\"getListSinkClasses\">\n"
+            "<arg name=\"listSinkClasses\" type=\"a(qsa(qn))\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * Retrieves a complete list of all systemProperties.
+        (at)return E_OK on success,
+         *  E_DATABASE_ERROR on error
+         */
+        "<method name=\"getListSystemProperties\">\n"
+            "<arg name=\"listSystemProperties\" type=\"a(qn)\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * returns the delay in ms that the audiopath for the given mainConnection
+         *  has
+        (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+         *  yet retrieved, E_DATABASE_ERROR on read error on the database
+         */
+        "<method name=\"getTimingInformation\">\n"
+            "<arg name=\"mainConnectionID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"delay\" type=\"n\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * Retrieves the list of MainNotifications for a sink. Does not return the
+         *  possible ones.
+         */
+        "<method name=\"getListMainSinkNotificationConfigurations\">\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"listMainNotificationConfigurations\" type=\"a(qin)\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * Retrieves the list of MainNotifications for a source. Does not return the
+         *  possible ones.
+         */
+        "<method name=\"getListMainSourceNotificationConfigurations\">\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"listMainNotificationConfigurations\" type=\"a(qin)\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * sets a MainNotificationConfiuration. This can be used to turn on an off
+         *  notifications an to change the mode of the configuration.
+        (at)return E_OK on
+         *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+         */
+        "<method name=\"setMainSinkNotificationConfiguration\">\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"mainNotificationConfiguration\" type=\"(qin)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * sets a MainNotificationConfiuration. This can be used to turn on an off
+         *  notifications an to change the mode of the configuration.
+        (at)return E_OK on
+         *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+         */
+        "<method name=\"setMainSourceNotificationConfiguration\">\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"mainNotificationConfiguration\" type=\"(qin)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+
+    ;
+    return introspectionData.c_str();
+}
+
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        CommandControlStub,
+        CommonAPI::Version
+        > CommandControlDBusStubAdapterInternal::getCommandControlInterfaceVersionStubDispatcher(&CommandControlStub::getInterfaceVersion, "uu");
+
+
+
+/**
+ * connects a source to sink
+(at)return E_OK on success, E_NOT_POSSIBLE on
+ *  failure, E_ALREADY_EXISTS if the connection does already exists
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t, am_sinkID_t>,
+    std::tuple<am_mainConnectionID_t, am_Error_e>
+    > CommandControlDBusStubAdapterInternal::connectStubDispatcher(&CommandControlStub::connect, "qi");
+/**
+ * disconnects a mainConnection
+(at)return E_OK on successes, E_NON_EXISTENT if
+ *  the connection does not exist, E_NOT_POSSIBLE on error.
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_mainConnectionID_t>,
+    std::tuple<am_Error_e>
+    > CommandControlDBusStubAdapterInternal::disconnectStubDispatcher(&CommandControlStub::disconnect, "i");
+/**
+ * sets the volume for a sink
+(at)return E_OK on success, E_UNKOWN on error,
+ *  E_OUT_OF_RANGE in case the value is out of range
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, am_mainVolume_t>,
+    std::tuple<am_Error_e>
+    > CommandControlDBusStubAdapterInternal::setVolumeStubDispatcher(&CommandControlStub::setVolume, "i");
+/**
+ * This function is used to increment or decrement the current volume for a
+ *  sink.
+(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+ *  value is not in the given volume range.
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, int16_t>,
+    std::tuple<am_Error_e>
+    > CommandControlDBusStubAdapterInternal::volumeStepStubDispatcher(&CommandControlStub::volumeStep, "i");
+/**
+ * sets the mute state of a sink
+(at)return E_OK on success, E_UNKNOWN on error.
+ *  If the mute state is already the desired one, the Daemon will return E_OK.
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, am_MuteState_e>,
+    std::tuple<am_Error_e>
+    > CommandControlDBusStubAdapterInternal::setSinkMuteStateStubDispatcher(&CommandControlStub::setSinkMuteState, "i");
+/**
+ * This method is used to set sound properties, e.g. Equalizer Values. Since the
+ *  capabilities of the system can differ, the exact key value pairs can be
+ *  extended in each product
+(at)return E_OK on success, E_OUT_OF_RANGE if value
+ *  exceeds range, E_UNKNOWN in case of an error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, am_MainSoundProperty_s>,
+    std::tuple<am_Error_e>
+    > CommandControlDBusStubAdapterInternal::setMainSinkSoundPropertyStubDispatcher(&CommandControlStub::setMainSinkSoundProperty, "i");
+/**
+ * This method is used to set sound properties, e.g. Equalizer Values. Since the
+ *  capabilities of the system can differ, the exact key value pairs can be
+ *  extended in each product
+(at)return E_OK on success, E_OUT_OF_RANGE if value
+ *  exceeds range, E_UNKNOWN in case of an error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t, am_MainSoundProperty_s>,
+    std::tuple<am_Error_e>
+    > CommandControlDBusStubAdapterInternal::setMainSourceSoundPropertyStubDispatcher(&CommandControlStub::setMainSourceSoundProperty, "i");
+/**
+ * is used to set a specific system property.
+(at)return E_OK on success,
+ *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_SystemProperty_s>,
+    std::tuple<am_Error_e>
+    > CommandControlDBusStubAdapterInternal::setSystemPropertyStubDispatcher(&CommandControlStub::setSystemProperty, "i");
+/**
+ * returns the actual list of MainConnections
+(at)return E_OK on success,
+ *  E_DATABASE_ERROR on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_MainConnection_L, am_Error_e>
+    > CommandControlDBusStubAdapterInternal::getListMainConnectionsStubDispatcher(&CommandControlStub::getListMainConnections, "a(qqqni)i");
+/**
+ * returns the actual list of Sinks
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SinkType_L, am_Error_e>
+    > CommandControlDBusStubAdapterInternal::getListMainSinksStubDispatcher(&CommandControlStub::getListMainSinks, "a(qs(iq)niq)i");
+/**
+ * returns the actual list of Sources
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SourceType_L, am_Error_e>
+    > CommandControlDBusStubAdapterInternal::getListMainSourcesStubDispatcher(&CommandControlStub::getListMainSources, "a(qs(iq)q)i");
+/**
+ * This is used to retrieve all source sound properties related to a source.
+ *  Returns a vector of the sound properties and values as pair
+(at)return E_OK on
+ *  success, E_DATABASE_ERROR on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t>,
+    std::tuple<am_MainSoundProperty_L, am_Error_e>
+    > CommandControlDBusStubAdapterInternal::getListMainSinkSoundPropertiesStubDispatcher(&CommandControlStub::getListMainSinkSoundProperties, "a(qn)i");
+/**
+ * This is used to retrieve all source sound properties related to a
+ *  source.
+(at)return E_OK on success, E_DATABASE_ERROR on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t>,
+    std::tuple<am_MainSoundProperty_L, am_Error_e>
+    > CommandControlDBusStubAdapterInternal::getListMainSourceSoundPropertiesStubDispatcher(&CommandControlStub::getListMainSourceSoundProperties, "a(qn)i");
+/**
+ * This is used to retrieve SourceClass Information of all source classes
+ *  
+(at)return E_OK on success, E_DATABASE_ERROR on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SourceClass_L, am_Error_e>
+    > CommandControlDBusStubAdapterInternal::getListSourceClassesStubDispatcher(&CommandControlStub::getListSourceClasses, "a(qsa(qn))i");
+/**
+ * This is used to retrieve SinkClass Information of all sink classes 
+(at)return
+ *  E_OK on success, E_DATABASE_ERROR on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SinkClass_L, am_Error_e>
+    > CommandControlDBusStubAdapterInternal::getListSinkClassesStubDispatcher(&CommandControlStub::getListSinkClasses, "a(qsa(qn))i");
+/**
+ * Retrieves a complete list of all systemProperties.
+(at)return E_OK on success,
+ *  E_DATABASE_ERROR on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SystemProperty_L, am_Error_e>
+    > CommandControlDBusStubAdapterInternal::getListSystemPropertiesStubDispatcher(&CommandControlStub::getListSystemProperties, "a(qn)i");
+/**
+ * returns the delay in ms that the audiopath for the given mainConnection
+ *  has
+(at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+ *  yet retrieved, E_DATABASE_ERROR on read error on the database
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_mainConnectionID_t>,
+    std::tuple<am_timeSync_t, am_Error_e>
+    > CommandControlDBusStubAdapterInternal::getTimingInformationStubDispatcher(&CommandControlStub::getTimingInformation, "ni");
+/**
+ * Retrieves the list of MainNotifications for a sink. Does not return the
+ *  possible ones.
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t>,
+    std::tuple<am_NotificationConfiguration_L, am_Error_e>
+    > CommandControlDBusStubAdapterInternal::getListMainSinkNotificationConfigurationsStubDispatcher(&CommandControlStub::getListMainSinkNotificationConfigurations, "a(qin)i");
+/**
+ * Retrieves the list of MainNotifications for a source. Does not return the
+ *  possible ones.
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t>,
+    std::tuple<am_NotificationConfiguration_L, am_Error_e>
+    > CommandControlDBusStubAdapterInternal::getListMainSourceNotificationConfigurationsStubDispatcher(&CommandControlStub::getListMainSourceNotificationConfigurations, "a(qin)i");
+/**
+ * sets a MainNotificationConfiuration. This can be used to turn on an off
+ *  notifications an to change the mode of the configuration.
+(at)return E_OK on
+ *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, am_NotificationConfiguration_s>,
+    std::tuple<am_Error_e>
+    > CommandControlDBusStubAdapterInternal::setMainSinkNotificationConfigurationStubDispatcher(&CommandControlStub::setMainSinkNotificationConfiguration, "i");
+/**
+ * sets a MainNotificationConfiuration. This can be used to turn on an off
+ *  notifications an to change the mode of the configuration.
+(at)return E_OK on
+ *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t, am_NotificationConfiguration_s>,
+    std::tuple<am_Error_e>
+    > CommandControlDBusStubAdapterInternal::setMainSourceNotificationConfigurationStubDispatcher(&CommandControlStub::setMainSourceNotificationConfiguration, "i");
+
+
+
+/**
+ * Callback that is called when the number of connections change
+ */
+void CommandControlDBusStubAdapterInternal::fireNewMainConnectionEvent(const am_MainConnectionType_s& mainConnection) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_MainConnectionType_s>>
+            ::sendSignal(
+                *this,
+                "newMainConnection",
+                "(qqqni)",
+                mainConnection
+        );
+}
+/**
+ * Callback that is called when the number of connections change
+ */
+void CommandControlDBusStubAdapterInternal::fireRemovedMainConnectionEvent(const am_mainConnectionID_t& mainConnection) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_mainConnectionID_t>>
+            ::sendSignal(
+                *this,
+                "removedMainConnection",
+                "q",
+                mainConnection
+        );
+}
+/**
+ * Callback that is called when the number of sinks change
+ */
+void CommandControlDBusStubAdapterInternal::fireNewSinkEvent(const am_SinkType_s& sink) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_SinkType_s>>
+            ::sendSignal(
+                *this,
+                "newSink",
+                "(qs(iq)niq)",
+                sink
+        );
+}
+/**
+ * Callback that is called when the number of sinks change
+ */
+void CommandControlDBusStubAdapterInternal::fireRemovedSinkEvent(const am_sinkID_t& sinkID) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t>>
+            ::sendSignal(
+                *this,
+                "removedSink",
+                "q",
+                sinkID
+        );
+}
+/**
+ * Callback that is called when the number of sources change
+ */
+void CommandControlDBusStubAdapterInternal::fireNewSourceEvent(const am_SourceType_s& source) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_SourceType_s>>
+            ::sendSignal(
+                *this,
+                "newSource",
+                "(qs(iq)q)",
+                source
+        );
+}
+/**
+ * Callback that is called when the number of sources change
+ */
+void CommandControlDBusStubAdapterInternal::fireRemovedSourceEvent(const am_sourceID_t& source) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t>>
+            ::sendSignal(
+                *this,
+                "removedSource",
+                "q",
+                source
+        );
+}
+/**
+ * this callback is fired if the number of sink classes changed
+ */
+void CommandControlDBusStubAdapterInternal::fireNumberOfSinkClassesChangedEvent() {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<>>
+            ::sendSignal(
+                *this,
+                "numberOfSinkClassesChanged",
+                ""
+        );
+}
+/**
+ * this callback is fired if the number of source classes changed
+ */
+void CommandControlDBusStubAdapterInternal::fireNumberOfSourceClassesChangedEvent() {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<>>
+            ::sendSignal(
+                *this,
+                "numberOfSourceClassesChanged",
+                ""
+        );
+}
+/**
+ * This callback is called when the ConnectionState of a connection changed.
+ */
+void CommandControlDBusStubAdapterInternal::fireMainConnectionStateChangedEvent(const am_mainConnectionID_t& connectionID, const am_ConnectionState_e& connectionState) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_mainConnectionID_t, am_ConnectionState_e>>
+            ::sendSignal(
+                *this,
+                "mainConnectionStateChanged",
+                "qi",
+                connectionID, connectionState
+        );
+}
+/**
+ * this callback indicates that a sinkSoundProperty has changed.
+ */
+void CommandControlDBusStubAdapterInternal::fireMainSinkSoundPropertyChangedEvent(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_MainSoundProperty_s>>
+            ::sendSignal(
+                *this,
+                "mainSinkSoundPropertyChanged",
+                "q(qn)",
+                sinkID, soundProperty
+        );
+}
+/**
+ * this callback indicates that a sourceSoundProperty has changed.
+ */
+void CommandControlDBusStubAdapterInternal::fireMainSourceSoundPropertyChangedEvent(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_MainSoundProperty_s>>
+            ::sendSignal(
+                *this,
+                "mainSourceSoundPropertyChanged",
+                "q(qn)",
+                sourceID, soundProperty
+        );
+}
+/**
+ * this callback is called when the availability of a sink has changed
+ */
+void CommandControlDBusStubAdapterInternal::fireSinkAvailabilityChangedEvent(const am_sinkID_t& sinkID, const am_Availability_s& availability) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Availability_s>>
+            ::sendSignal(
+                *this,
+                "sinkAvailabilityChanged",
+                "q(iq)",
+                sinkID, availability
+        );
+}
+/**
+ * this callback is called when the availability of source has changed.
+ */
+void CommandControlDBusStubAdapterInternal::fireSourceAvailabilityChangedEvent(const am_sourceID_t& sourceID, const am_Availability_s& availability) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Availability_s>>
+            ::sendSignal(
+                *this,
+                "sourceAvailabilityChanged",
+                "q(iq)",
+                sourceID, availability
+        );
+}
+/**
+ * this callback indicates a volume change on the indicated sink
+ */
+void CommandControlDBusStubAdapterInternal::fireVolumeChangedEvent(const am_sinkID_t& sinkID, const am_mainVolume_t& volume) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_mainVolume_t>>
+            ::sendSignal(
+                *this,
+                "volumeChanged",
+                "qn",
+                sinkID, volume
+        );
+}
+/**
+ * this callback indicates a mute state change on a sink.
+ */
+void CommandControlDBusStubAdapterInternal::fireSinkMuteStateChangedEvent(const am_sinkID_t& sinkID, const am_MuteState_e& muteState) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_MuteState_e>>
+            ::sendSignal(
+                *this,
+                "sinkMuteStateChanged",
+                "qi",
+                sinkID, muteState
+        );
+}
+/**
+ * is fired if a systemProperty changed
+ */
+void CommandControlDBusStubAdapterInternal::fireSystemPropertyChangedEvent(const am_SystemProperty_s& systemProperty) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_SystemProperty_s>>
+            ::sendSignal(
+                *this,
+                "systemPropertyChanged",
+                "(qn)",
+                systemProperty
+        );
+}
+/**
+ * This callback is fired if the timinginformation for a mainConnectionID changed
+ */
+void CommandControlDBusStubAdapterInternal::fireTimingInformationChangedEvent(const am_mainConnectionID_t& mainConnectionID, const am_timeSync_t& time) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_mainConnectionID_t, am_timeSync_t>>
+            ::sendSignal(
+                *this,
+                "timingInformationChanged",
+                "qn",
+                mainConnectionID, time
+        );
+}
+/**
+ * This callback is called when a sink is updated.
+ */
+void CommandControlDBusStubAdapterInternal::fireSinkUpdatedEvent(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_MainSoundProperty_L& listMainSoundProperties) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_sinkClass_t, am_MainSoundProperty_L>>
+            ::sendSignal(
+                *this,
+                "sinkUpdated",
+                "qqa(qn)",
+                sinkID, sinkClassID, listMainSoundProperties
+        );
+}
+/**
+ * This callback is called when a source is updated.
+ */
+void CommandControlDBusStubAdapterInternal::fireSourceUpdatedEvent(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_MainSoundProperty_L& listMainSoundProperties) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_sourceClass_t, am_MainSoundProperty_L>>
+            ::sendSignal(
+                *this,
+                "sourceUpdated",
+                "qqa(qn)",
+                sourceID, sourceClassID, listMainSoundProperties
+        );
+}
+/**
+ * This callback is called when a notificated value of a sink changes.
+ */
+void CommandControlDBusStubAdapterInternal::fireSinkNotificationEvent(const am_sinkID_t& sinkID, const am_NotificationPayload_s& notification) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_NotificationPayload_s>>
+            ::sendSignal(
+                *this,
+                "sinkNotification",
+                "q(qn)",
+                sinkID, notification
+        );
+}
+/**
+ * This callback is called when a notifcated value of a source changes.
+ */
+void CommandControlDBusStubAdapterInternal::fireSourceNotificationEvent(const am_sourceID_t& sourceID, const am_NotificationPayload_s& notification) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_NotificationPayload_s>>
+            ::sendSignal(
+                *this,
+                "sourceNotification",
+                "q(qn)",
+                sourceID, notification
+        );
+}
+/**
+ * This callback is triggered when a mainNotificationConfiguration is changed.
+ */
+void CommandControlDBusStubAdapterInternal::fireMainSinkNotificationConfigurationChangedEvent(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_NotificationConfiguration_s>>
+            ::sendSignal(
+                *this,
+                "mainSinkNotificationConfigurationChanged",
+                "q(qin)",
+                sinkID, mainNotificationConfiguration
+        );
+}
+/**
+ * This callback is triggered when a mainNotificationConfiguration is changed.
+ */
+void CommandControlDBusStubAdapterInternal::fireMainSourceNotificationConfigurationChangedEvent(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_NotificationConfiguration_s>>
+            ::sendSignal(
+                *this,
+                "mainSourceNotificationConfigurationChanged",
+                "q(qin)",
+                sourceID, mainNotificationConfiguration
+        );
+}
+
+
+const CommandControlDBusStubAdapterHelper::StubDispatcherTable& CommandControlDBusStubAdapterInternal::getStubDispatcherTable() {
+    return stubDispatcherTable_;
+}
+
+const CommonAPI::DBus::StubAttributeTable& CommandControlDBusStubAdapterInternal::getStubAttributeTable() {
+    return stubAttributeTable_;
+}
+
+CommandControlDBusStubAdapterInternal::CommandControlDBusStubAdapterInternal(
+        const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+        const std::string& commonApiAddress,
+        const std::string& dbusInterfaceName,
+        const std::string& dbusBusName,
+        const std::string& dbusObjectPath,
+        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+        const std::shared_ptr<CommonAPI::StubBase>& stub):
+        CommonAPI::DBus::DBusStubAdapter(
+                factory,
+                commonApiAddress,
+                dbusInterfaceName,
+                dbusBusName,
+                dbusObjectPath,
+                dbusConnection,
+                false),
+        CommandControlDBusStubAdapterHelper(
+            factory,
+            commonApiAddress,
+            dbusInterfaceName,
+            dbusBusName,
+            dbusObjectPath,
+            dbusConnection,
+            std::dynamic_pointer_cast<CommandControlStub>(stub),
+            false),
+        stubDispatcherTable_({
+            /**
+             * connects a source to sink
+            (at)return E_OK on success, E_NOT_POSSIBLE on
+             *  failure, E_ALREADY_EXISTS if the connection does already exists
+             */
+            { { "connect", "qq" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::connectStubDispatcher },
+            /**
+             * disconnects a mainConnection
+            (at)return E_OK on successes, E_NON_EXISTENT if
+             *  the connection does not exist, E_NOT_POSSIBLE on error.
+             */
+            { { "disconnect", "q" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::disconnectStubDispatcher },
+            /**
+             * sets the volume for a sink
+            (at)return E_OK on success, E_UNKOWN on error,
+             *  E_OUT_OF_RANGE in case the value is out of range
+             */
+            { { "setVolume", "qn" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setVolumeStubDispatcher },
+            /**
+             * This function is used to increment or decrement the current volume for a
+             *  sink.
+            (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+             *  value is not in the given volume range.
+             */
+            { { "volumeStep", "qn" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::volumeStepStubDispatcher },
+            /**
+             * sets the mute state of a sink
+            (at)return E_OK on success, E_UNKNOWN on error.
+             *  If the mute state is already the desired one, the Daemon will return E_OK.
+             */
+            { { "setSinkMuteState", "qi" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setSinkMuteStateStubDispatcher },
+            /**
+             * This method is used to set sound properties, e.g. Equalizer Values. Since the
+             *  capabilities of the system can differ, the exact key value pairs can be
+             *  extended in each product
+            (at)return E_OK on success, E_OUT_OF_RANGE if value
+             *  exceeds range, E_UNKNOWN in case of an error
+             */
+            { { "setMainSinkSoundProperty", "q(qn)" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setMainSinkSoundPropertyStubDispatcher },
+            /**
+             * This method is used to set sound properties, e.g. Equalizer Values. Since the
+             *  capabilities of the system can differ, the exact key value pairs can be
+             *  extended in each product
+            (at)return E_OK on success, E_OUT_OF_RANGE if value
+             *  exceeds range, E_UNKNOWN in case of an error
+             */
+            { { "setMainSourceSoundProperty", "q(qn)" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setMainSourceSoundPropertyStubDispatcher },
+            /**
+             * is used to set a specific system property.
+            (at)return E_OK on success,
+             *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+             */
+            { { "setSystemProperty", "(qn)" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setSystemPropertyStubDispatcher },
+            /**
+             * returns the actual list of MainConnections
+            (at)return E_OK on success,
+             *  E_DATABASE_ERROR on error
+             */
+            { { "getListMainConnections", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainConnectionsStubDispatcher },
+            /**
+             * returns the actual list of Sinks
+            (at)return E_OK on success, E_DATABASE_ERROR
+             *  on error
+             */
+            { { "getListMainSinks", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainSinksStubDispatcher },
+            /**
+             * returns the actual list of Sources
+            (at)return E_OK on success, E_DATABASE_ERROR
+             *  on error
+             */
+            { { "getListMainSources", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainSourcesStubDispatcher },
+            /**
+             * This is used to retrieve all source sound properties related to a source.
+             *  Returns a vector of the sound properties and values as pair
+            (at)return E_OK on
+             *  success, E_DATABASE_ERROR on error
+             */
+            { { "getListMainSinkSoundProperties", "q" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainSinkSoundPropertiesStubDispatcher },
+            /**
+             * This is used to retrieve all source sound properties related to a
+             *  source.
+            (at)return E_OK on success, E_DATABASE_ERROR on error
+             */
+            { { "getListMainSourceSoundProperties", "q" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainSourceSoundPropertiesStubDispatcher },
+            /**
+             * This is used to retrieve SourceClass Information of all source classes
+             *  
+            (at)return E_OK on success, E_DATABASE_ERROR on error
+             */
+            { { "getListSourceClasses", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListSourceClassesStubDispatcher },
+            /**
+             * This is used to retrieve SinkClass Information of all sink classes 
+            (at)return
+             *  E_OK on success, E_DATABASE_ERROR on error
+             */
+            { { "getListSinkClasses", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListSinkClassesStubDispatcher },
+            /**
+             * Retrieves a complete list of all systemProperties.
+            (at)return E_OK on success,
+             *  E_DATABASE_ERROR on error
+             */
+            { { "getListSystemProperties", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListSystemPropertiesStubDispatcher },
+            /**
+             * returns the delay in ms that the audiopath for the given mainConnection
+             *  has
+            (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+             *  yet retrieved, E_DATABASE_ERROR on read error on the database
+             */
+            { { "getTimingInformation", "q" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getTimingInformationStubDispatcher },
+            /**
+             * Retrieves the list of MainNotifications for a sink. Does not return the
+             *  possible ones.
+             */
+            { { "getListMainSinkNotificationConfigurations", "q" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainSinkNotificationConfigurationsStubDispatcher },
+            /**
+             * Retrieves the list of MainNotifications for a source. Does not return the
+             *  possible ones.
+             */
+            { { "getListMainSourceNotificationConfigurations", "q" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getListMainSourceNotificationConfigurationsStubDispatcher },
+            /**
+             * sets a MainNotificationConfiuration. This can be used to turn on an off
+             *  notifications an to change the mode of the configuration.
+            (at)return E_OK on
+             *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+             */
+            { { "setMainSinkNotificationConfiguration", "q(qin)" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setMainSinkNotificationConfigurationStubDispatcher },
+            /**
+             * sets a MainNotificationConfiuration. This can be used to turn on an off
+             *  notifications an to change the mode of the configuration.
+            (at)return E_OK on
+             *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+             */
+            { { "setMainSourceNotificationConfiguration", "q(qin)" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::setMainSourceNotificationConfigurationStubDispatcher }
+            }),
+        stubAttributeTable_() {
+
+    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::am::CommandControlDBusStubAdapterInternal::getCommandControlInterfaceVersionStubDispatcher });
+}
+
+const bool CommandControlDBusStubAdapterInternal::hasFreedesktopProperties() {
+    return false;
+}
+
+} // namespace am
+} // namespace genivi
+} // namespace org
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.h
new file mode 100644
index 0000000..0909211
--- /dev/null
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlDBusStubAdapter.h
@@ -0,0 +1,422 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * The interface towards the Controlling Instance (e.g HMI). It handles the
+ *  communication towards the HMI and other system components who need to interact
+ *  with the audiomanagement.
+There are two rules that have to be kept in mind
+ *  when implementing against this interface:
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Command_Control_DBUS_STUB_ADAPTER_H_
+#define ORG_GENIVI_AM_Command_Control_DBUS_STUB_ADAPTER_H_
+
+#include <org/genivi/am/CommandControlStub.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/DBus/DBusStubAdapterHelper.h>
+#include <CommonAPI/DBus/DBusStubAdapter.h>
+#include <CommonAPI/DBus/DBusFactory.h>
+#include <CommonAPI/DBus/DBusServicePublisher.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+typedef CommonAPI::DBus::DBusStubAdapterHelper<CommandControlStub> CommandControlDBusStubAdapterHelper;
+
+class CommandControlDBusStubAdapterInternal: public virtual CommandControlStubAdapter, public CommandControlDBusStubAdapterHelper {
+ public:
+    CommandControlDBusStubAdapterInternal(
+            const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+            const std::string& commonApiAddress,
+            const std::string& dbusInterfaceName,
+            const std::string& dbusBusName,
+            const std::string& dbusObjectPath,
+            const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+            const std::shared_ptr<CommonAPI::StubBase>& stub);
+
+    ~CommandControlDBusStubAdapterInternal();
+
+    virtual const bool hasFreedesktopProperties();
+
+
+    /**
+     * Callback that is called when the number of connections change
+     */
+    void fireNewMainConnectionEvent(const am_MainConnectionType_s& mainConnection);
+    /**
+     * Callback that is called when the number of connections change
+     */
+    void fireRemovedMainConnectionEvent(const am_mainConnectionID_t& mainConnection);
+    /**
+     * Callback that is called when the number of sinks change
+     */
+    void fireNewSinkEvent(const am_SinkType_s& sink);
+    /**
+     * Callback that is called when the number of sinks change
+     */
+    void fireRemovedSinkEvent(const am_sinkID_t& sinkID);
+    /**
+     * Callback that is called when the number of sources change
+     */
+    void fireNewSourceEvent(const am_SourceType_s& source);
+    /**
+     * Callback that is called when the number of sources change
+     */
+    void fireRemovedSourceEvent(const am_sourceID_t& source);
+    /**
+     * this callback is fired if the number of sink classes changed
+     */
+    void fireNumberOfSinkClassesChangedEvent();
+    /**
+     * this callback is fired if the number of source classes changed
+     */
+    void fireNumberOfSourceClassesChangedEvent();
+    /**
+     * This callback is called when the ConnectionState of a connection changed.
+     */
+    void fireMainConnectionStateChangedEvent(const am_mainConnectionID_t& connectionID, const am_ConnectionState_e& connectionState);
+    /**
+     * this callback indicates that a sinkSoundProperty has changed.
+     */
+    void fireMainSinkSoundPropertyChangedEvent(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty);
+    /**
+     * this callback indicates that a sourceSoundProperty has changed.
+     */
+    void fireMainSourceSoundPropertyChangedEvent(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty);
+    /**
+     * this callback is called when the availability of a sink has changed
+     */
+    void fireSinkAvailabilityChangedEvent(const am_sinkID_t& sinkID, const am_Availability_s& availability);
+    /**
+     * this callback is called when the availability of source has changed.
+     */
+    void fireSourceAvailabilityChangedEvent(const am_sourceID_t& sourceID, const am_Availability_s& availability);
+    /**
+     * this callback indicates a volume change on the indicated sink
+     */
+    void fireVolumeChangedEvent(const am_sinkID_t& sinkID, const am_mainVolume_t& volume);
+    /**
+     * this callback indicates a mute state change on a sink.
+     */
+    void fireSinkMuteStateChangedEvent(const am_sinkID_t& sinkID, const am_MuteState_e& muteState);
+    /**
+     * is fired if a systemProperty changed
+     */
+    void fireSystemPropertyChangedEvent(const am_SystemProperty_s& systemProperty);
+    /**
+     * This callback is fired if the timinginformation for a mainConnectionID changed
+     */
+    void fireTimingInformationChangedEvent(const am_mainConnectionID_t& mainConnectionID, const am_timeSync_t& time);
+    /**
+     * This callback is called when a sink is updated.
+     */
+    void fireSinkUpdatedEvent(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_MainSoundProperty_L& listMainSoundProperties);
+    /**
+     * This callback is called when a source is updated.
+     */
+    void fireSourceUpdatedEvent(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_MainSoundProperty_L& listMainSoundProperties);
+    /**
+     * This callback is called when a notificated value of a sink changes.
+     */
+    void fireSinkNotificationEvent(const am_sinkID_t& sinkID, const am_NotificationPayload_s& notification);
+    /**
+     * This callback is called when a notifcated value of a source changes.
+     */
+    void fireSourceNotificationEvent(const am_sourceID_t& sourceID, const am_NotificationPayload_s& notification);
+    /**
+     * This callback is triggered when a mainNotificationConfiguration is changed.
+     */
+    void fireMainSinkNotificationConfigurationChangedEvent(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration);
+    /**
+     * This callback is triggered when a mainNotificationConfiguration is changed.
+     */
+    void fireMainSourceNotificationConfigurationChangedEvent(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration);
+
+
+    const CommandControlDBusStubAdapterHelper::StubDispatcherTable& getStubDispatcherTable();
+    const CommonAPI::DBus::StubAttributeTable& getStubAttributeTable();
+
+    void deactivateManagedInstances();
+
+
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        CommandControlStub,
+        CommonAPI::Version
+        > getCommandControlInterfaceVersionStubDispatcher;
+
+
+
+/**
+ * connects a source to sink
+(at)return E_OK on success, E_NOT_POSSIBLE on
+ *  failure, E_ALREADY_EXISTS if the connection does already exists
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t, am_sinkID_t>,
+    std::tuple<am_mainConnectionID_t, am_Error_e>
+    > connectStubDispatcher;
+/**
+ * disconnects a mainConnection
+(at)return E_OK on successes, E_NON_EXISTENT if
+ *  the connection does not exist, E_NOT_POSSIBLE on error.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_mainConnectionID_t>,
+    std::tuple<am_Error_e>
+    > disconnectStubDispatcher;
+/**
+ * sets the volume for a sink
+(at)return E_OK on success, E_UNKOWN on error,
+ *  E_OUT_OF_RANGE in case the value is out of range
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, am_mainVolume_t>,
+    std::tuple<am_Error_e>
+    > setVolumeStubDispatcher;
+/**
+ * This function is used to increment or decrement the current volume for a
+ *  sink.
+(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+ *  value is not in the given volume range.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, int16_t>,
+    std::tuple<am_Error_e>
+    > volumeStepStubDispatcher;
+/**
+ * sets the mute state of a sink
+(at)return E_OK on success, E_UNKNOWN on error.
+ *  If the mute state is already the desired one, the Daemon will return E_OK.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, am_MuteState_e>,
+    std::tuple<am_Error_e>
+    > setSinkMuteStateStubDispatcher;
+/**
+ * This method is used to set sound properties, e.g. Equalizer Values. Since the
+ *  capabilities of the system can differ, the exact key value pairs can be
+ *  extended in each product
+(at)return E_OK on success, E_OUT_OF_RANGE if value
+ *  exceeds range, E_UNKNOWN in case of an error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, am_MainSoundProperty_s>,
+    std::tuple<am_Error_e>
+    > setMainSinkSoundPropertyStubDispatcher;
+/**
+ * This method is used to set sound properties, e.g. Equalizer Values. Since the
+ *  capabilities of the system can differ, the exact key value pairs can be
+ *  extended in each product
+(at)return E_OK on success, E_OUT_OF_RANGE if value
+ *  exceeds range, E_UNKNOWN in case of an error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t, am_MainSoundProperty_s>,
+    std::tuple<am_Error_e>
+    > setMainSourceSoundPropertyStubDispatcher;
+/**
+ * is used to set a specific system property.
+(at)return E_OK on success,
+ *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_SystemProperty_s>,
+    std::tuple<am_Error_e>
+    > setSystemPropertyStubDispatcher;
+/**
+ * returns the actual list of MainConnections
+(at)return E_OK on success,
+ *  E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_MainConnection_L, am_Error_e>
+    > getListMainConnectionsStubDispatcher;
+/**
+ * returns the actual list of Sinks
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SinkType_L, am_Error_e>
+    > getListMainSinksStubDispatcher;
+/**
+ * returns the actual list of Sources
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SourceType_L, am_Error_e>
+    > getListMainSourcesStubDispatcher;
+/**
+ * This is used to retrieve all source sound properties related to a source.
+ *  Returns a vector of the sound properties and values as pair
+(at)return E_OK on
+ *  success, E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t>,
+    std::tuple<am_MainSoundProperty_L, am_Error_e>
+    > getListMainSinkSoundPropertiesStubDispatcher;
+/**
+ * This is used to retrieve all source sound properties related to a
+ *  source.
+(at)return E_OK on success, E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t>,
+    std::tuple<am_MainSoundProperty_L, am_Error_e>
+    > getListMainSourceSoundPropertiesStubDispatcher;
+/**
+ * This is used to retrieve SourceClass Information of all source classes
+ *  
+(at)return E_OK on success, E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SourceClass_L, am_Error_e>
+    > getListSourceClassesStubDispatcher;
+/**
+ * This is used to retrieve SinkClass Information of all sink classes 
+(at)return
+ *  E_OK on success, E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SinkClass_L, am_Error_e>
+    > getListSinkClassesStubDispatcher;
+/**
+ * Retrieves a complete list of all systemProperties.
+(at)return E_OK on success,
+ *  E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<>,
+    std::tuple<am_SystemProperty_L, am_Error_e>
+    > getListSystemPropertiesStubDispatcher;
+/**
+ * returns the delay in ms that the audiopath for the given mainConnection
+ *  has
+(at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+ *  yet retrieved, E_DATABASE_ERROR on read error on the database
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_mainConnectionID_t>,
+    std::tuple<am_timeSync_t, am_Error_e>
+    > getTimingInformationStubDispatcher;
+/**
+ * Retrieves the list of MainNotifications for a sink. Does not return the
+ *  possible ones.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t>,
+    std::tuple<am_NotificationConfiguration_L, am_Error_e>
+    > getListMainSinkNotificationConfigurationsStubDispatcher;
+/**
+ * Retrieves the list of MainNotifications for a source. Does not return the
+ *  possible ones.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t>,
+    std::tuple<am_NotificationConfiguration_L, am_Error_e>
+    > getListMainSourceNotificationConfigurationsStubDispatcher;
+/**
+ * sets a MainNotificationConfiuration. This can be used to turn on an off
+ *  notifications an to change the mode of the configuration.
+(at)return E_OK on
+ *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sinkID_t, am_NotificationConfiguration_s>,
+    std::tuple<am_Error_e>
+    > setMainSinkNotificationConfigurationStubDispatcher;
+/**
+ * sets a MainNotificationConfiuration. This can be used to turn on an off
+ *  notifications an to change the mode of the configuration.
+(at)return E_OK on
+ *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    CommandControlStub,
+    std::tuple<am_sourceID_t, am_NotificationConfiguration_s>,
+    std::tuple<am_Error_e>
+    > setMainSourceNotificationConfigurationStubDispatcher;
+
+
+
+
+ protected:
+    virtual const char* getMethodsDBusIntrospectionXmlData() const;
+
+ private:
+    CommandControlDBusStubAdapterHelper::StubDispatcherTable stubDispatcherTable_;
+    CommonAPI::DBus::StubAttributeTable stubAttributeTable_;
+};
+
+class CommandControlDBusStubAdapter: public CommandControlDBusStubAdapterInternal, public std::enable_shared_from_this<CommandControlDBusStubAdapter> {
+public:
+    CommandControlDBusStubAdapter(
+                         const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                         const std::string& commonApiAddress,
+                         const std::string& dbusInterfaceName,
+                         const std::string& dbusBusName,
+                         const std::string& dbusObjectPath,
+                         const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+                         const std::shared_ptr<CommonAPI::StubBase>& stub) :
+            CommonAPI::DBus::DBusStubAdapter(
+                            factory,
+                            commonApiAddress,
+                            dbusInterfaceName,
+                            dbusBusName,
+                            dbusObjectPath,
+                            dbusConnection,
+                            false),
+            CommandControlDBusStubAdapterInternal(
+                            factory,
+                            commonApiAddress,
+                            dbusInterfaceName,
+                            dbusBusName,
+                            dbusObjectPath,
+                            dbusConnection,
+                            stub) { }
+};
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Command_Control_DBUS_STUB_ADAPTER_H_
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxy.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxy.h
new file mode 100644
index 0000000..03e6a62
--- /dev/null
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxy.h
@@ -0,0 +1,1194 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * The interface towards the Controlling Instance (e.g HMI). It handles the
+ *  communication towards the HMI and other system components who need to interact
+ *  with the audiomanagement.
+There are two rules that have to be kept in mind
+ *  when implementing against this interface:
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Command_Control_PROXY_H_
+#define ORG_GENIVI_AM_Command_Control_PROXY_H_
+
+#include "CommandControlProxyBase.h"
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+template <typename ... _AttributeExtensions>
+class CommandControlProxy: virtual public CommandControl, virtual public CommandControlProxyBase
+, public _AttributeExtensions... {
+public:
+    CommandControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
+    ~CommandControlProxy();
+
+    typedef CommandControl InterfaceType;
+
+
+
+    /**
+     * Callback that is called when the number of connections change
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast newMainConnection.
+     */
+    virtual NewMainConnectionEvent& getNewMainConnectionEvent() {
+        return delegate_->getNewMainConnectionEvent();
+    }
+    /**
+     * Callback that is called when the number of connections change
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast removedMainConnection.
+     */
+    virtual RemovedMainConnectionEvent& getRemovedMainConnectionEvent() {
+        return delegate_->getRemovedMainConnectionEvent();
+    }
+    /**
+     * Callback that is called when the number of sinks change
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast newSink.
+     */
+    virtual NewSinkEvent& getNewSinkEvent() {
+        return delegate_->getNewSinkEvent();
+    }
+    /**
+     * Callback that is called when the number of sinks change
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast removedSink.
+     */
+    virtual RemovedSinkEvent& getRemovedSinkEvent() {
+        return delegate_->getRemovedSinkEvent();
+    }
+    /**
+     * Callback that is called when the number of sources change
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast newSource.
+     */
+    virtual NewSourceEvent& getNewSourceEvent() {
+        return delegate_->getNewSourceEvent();
+    }
+    /**
+     * Callback that is called when the number of sources change
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast removedSource.
+     */
+    virtual RemovedSourceEvent& getRemovedSourceEvent() {
+        return delegate_->getRemovedSourceEvent();
+    }
+    /**
+     * this callback is fired if the number of sink classes changed
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast numberOfSinkClassesChanged.
+     */
+    virtual NumberOfSinkClassesChangedEvent& getNumberOfSinkClassesChangedEvent() {
+        return delegate_->getNumberOfSinkClassesChangedEvent();
+    }
+    /**
+     * this callback is fired if the number of source classes changed
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast numberOfSourceClassesChanged.
+     */
+    virtual NumberOfSourceClassesChangedEvent& getNumberOfSourceClassesChangedEvent() {
+        return delegate_->getNumberOfSourceClassesChangedEvent();
+    }
+    /**
+     * This callback is called when the ConnectionState of a connection changed.
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast mainConnectionStateChanged.
+     */
+    virtual MainConnectionStateChangedEvent& getMainConnectionStateChangedEvent() {
+        return delegate_->getMainConnectionStateChangedEvent();
+    }
+    /**
+     * this callback indicates that a sinkSoundProperty has changed.
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast mainSinkSoundPropertyChanged.
+     */
+    virtual MainSinkSoundPropertyChangedEvent& getMainSinkSoundPropertyChangedEvent() {
+        return delegate_->getMainSinkSoundPropertyChangedEvent();
+    }
+    /**
+     * this callback indicates that a sourceSoundProperty has changed.
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast mainSourceSoundPropertyChanged.
+     */
+    virtual MainSourceSoundPropertyChangedEvent& getMainSourceSoundPropertyChangedEvent() {
+        return delegate_->getMainSourceSoundPropertyChangedEvent();
+    }
+    /**
+     * this callback is called when the availability of a sink has changed
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast sinkAvailabilityChanged.
+     */
+    virtual SinkAvailabilityChangedEvent& getSinkAvailabilityChangedEvent() {
+        return delegate_->getSinkAvailabilityChangedEvent();
+    }
+    /**
+     * this callback is called when the availability of source has changed.
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast sourceAvailabilityChanged.
+     */
+    virtual SourceAvailabilityChangedEvent& getSourceAvailabilityChangedEvent() {
+        return delegate_->getSourceAvailabilityChangedEvent();
+    }
+    /**
+     * this callback indicates a volume change on the indicated sink
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast volumeChanged.
+     */
+    virtual VolumeChangedEvent& getVolumeChangedEvent() {
+        return delegate_->getVolumeChangedEvent();
+    }
+    /**
+     * this callback indicates a mute state change on a sink.
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast sinkMuteStateChanged.
+     */
+    virtual SinkMuteStateChangedEvent& getSinkMuteStateChangedEvent() {
+        return delegate_->getSinkMuteStateChangedEvent();
+    }
+    /**
+     * is fired if a systemProperty changed
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast systemPropertyChanged.
+     */
+    virtual SystemPropertyChangedEvent& getSystemPropertyChangedEvent() {
+        return delegate_->getSystemPropertyChangedEvent();
+    }
+    /**
+     * This callback is fired if the timinginformation for a mainConnectionID changed
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast timingInformationChanged.
+     */
+    virtual TimingInformationChangedEvent& getTimingInformationChangedEvent() {
+        return delegate_->getTimingInformationChangedEvent();
+    }
+    /**
+     * This callback is called when a sink is updated.
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast sinkUpdated.
+     */
+    virtual SinkUpdatedEvent& getSinkUpdatedEvent() {
+        return delegate_->getSinkUpdatedEvent();
+    }
+    /**
+     * This callback is called when a source is updated.
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast sourceUpdated.
+     */
+    virtual SourceUpdatedEvent& getSourceUpdatedEvent() {
+        return delegate_->getSourceUpdatedEvent();
+    }
+    /**
+     * This callback is called when a notificated value of a sink changes.
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast sinkNotification.
+     */
+    virtual SinkNotificationEvent& getSinkNotificationEvent() {
+        return delegate_->getSinkNotificationEvent();
+    }
+    /**
+     * This callback is called when a notifcated value of a source changes.
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast sourceNotification.
+     */
+    virtual SourceNotificationEvent& getSourceNotificationEvent() {
+        return delegate_->getSourceNotificationEvent();
+    }
+    /**
+     * This callback is triggered when a mainNotificationConfiguration is changed.
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast mainSinkNotificationConfigurationChanged.
+     */
+    virtual MainSinkNotificationConfigurationChangedEvent& getMainSinkNotificationConfigurationChangedEvent() {
+        return delegate_->getMainSinkNotificationConfigurationChangedEvent();
+    }
+    /**
+     * This callback is triggered when a mainNotificationConfiguration is changed.
+     */
+    /**
+     * Returns the wrapper class that provides access to the broadcast mainSourceNotificationConfigurationChanged.
+     */
+    virtual MainSourceNotificationConfigurationChangedEvent& getMainSourceNotificationConfigurationChangedEvent() {
+        return delegate_->getMainSourceNotificationConfigurationChangedEvent();
+    }
+
+    /**
+     * connects a source to sink
+    (at)return E_OK on success, E_NOT_POSSIBLE on
+     *  failure, E_ALREADY_EXISTS if the connection does already exists
+     * 
+     * Calls connect with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void connect(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_mainConnectionID_t& mainConnectionID, am_Error_e& error);
+    /**
+     * Calls connect with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> connectAsync(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, ConnectAsyncCallback callback);
+    /**
+     * disconnects a mainConnection
+    (at)return E_OK on successes, E_NON_EXISTENT if
+     *  the connection does not exist, E_NOT_POSSIBLE on error.
+     * 
+     * Calls disconnect with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void disconnect(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls disconnect with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> disconnectAsync(const am_mainConnectionID_t& mainConnectionID, DisconnectAsyncCallback callback);
+    /**
+     * sets the volume for a sink
+    (at)return E_OK on success, E_UNKOWN on error,
+     *  E_OUT_OF_RANGE in case the value is out of range
+     * 
+     * Calls setVolume with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void setVolume(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls setVolume with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> setVolumeAsync(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, SetVolumeAsyncCallback callback);
+    /**
+     * This function is used to increment or decrement the current volume for a
+     *  sink.
+    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+     *  value is not in the given volume range.
+     * 
+     * Calls volumeStep with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void volumeStep(const am_sinkID_t& sinkID, const int16_t& volStep, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls volumeStep with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volStep, VolumeStepAsyncCallback callback);
+    /**
+     * sets the mute state of a sink
+    (at)return E_OK on success, E_UNKNOWN on error.
+     *  If the mute state is already the desired one, the Daemon will return E_OK.
+     * 
+     * Calls setSinkMuteState with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void setSinkMuteState(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls setSinkMuteState with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> setSinkMuteStateAsync(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, SetSinkMuteStateAsyncCallback callback);
+    /**
+     * This method is used to set sound properties, e.g. Equalizer Values. Since the
+     *  capabilities of the system can differ, the exact key value pairs can be
+     *  extended in each product
+    (at)return E_OK on success, E_OUT_OF_RANGE if value
+     *  exceeds range, E_UNKNOWN in case of an error
+     * 
+     * Calls setMainSinkSoundProperty with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void setMainSinkSoundProperty(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls setMainSinkSoundProperty with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> setMainSinkSoundPropertyAsync(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, SetMainSinkSoundPropertyAsyncCallback callback);
+    /**
+     * This method is used to set sound properties, e.g. Equalizer Values. Since the
+     *  capabilities of the system can differ, the exact key value pairs can be
+     *  extended in each product
+    (at)return E_OK on success, E_OUT_OF_RANGE if value
+     *  exceeds range, E_UNKNOWN in case of an error
+     * 
+     * Calls setMainSourceSoundProperty with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void setMainSourceSoundProperty(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls setMainSourceSoundProperty with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> setMainSourceSoundPropertyAsync(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, SetMainSourceSoundPropertyAsyncCallback callback);
+    /**
+     * is used to set a specific system property.
+    (at)return E_OK on success,
+     *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+     * 
+     * Calls setSystemProperty with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void setSystemProperty(const am_SystemProperty_s& property, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls setSystemProperty with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> setSystemPropertyAsync(const am_SystemProperty_s& property, SetSystemPropertyAsyncCallback callback);
+    /**
+     * returns the actual list of MainConnections
+    (at)return E_OK on success,
+     *  E_DATABASE_ERROR on error
+     * 
+     * Calls getListMainConnections with synchronous semantics.
+     * 
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void getListMainConnections(CommonAPI::CallStatus& callStatus, am_MainConnection_L& listConnections, am_Error_e& error);
+    /**
+     * Calls getListMainConnections with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> getListMainConnectionsAsync(GetListMainConnectionsAsyncCallback callback);
+    /**
+     * returns the actual list of Sinks
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
+     * 
+     * Calls getListMainSinks with synchronous semantics.
+     * 
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void getListMainSinks(CommonAPI::CallStatus& callStatus, am_SinkType_L& listMainSinks, am_Error_e& error);
+    /**
+     * Calls getListMainSinks with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> getListMainSinksAsync(GetListMainSinksAsyncCallback callback);
+    /**
+     * returns the actual list of Sources
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
+     * 
+     * Calls getListMainSources with synchronous semantics.
+     * 
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error);
+    /**
+     * Calls getListMainSources with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> getListMainSourcesAsync(GetListMainSourcesAsyncCallback callback);
+    /**
+     * This is used to retrieve all source sound properties related to a source.
+     *  Returns a vector of the sound properties and values as pair
+    (at)return E_OK on
+     *  success, E_DATABASE_ERROR on error
+     * 
+     * Calls getListMainSinkSoundProperties with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error);
+    /**
+     * Calls getListMainSinkSoundProperties with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> getListMainSinkSoundPropertiesAsync(const am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback);
+    /**
+     * This is used to retrieve all source sound properties related to a
+     *  source.
+    (at)return E_OK on success, E_DATABASE_ERROR on error
+     * 
+     * Calls getListMainSourceSoundProperties with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void getListMainSourceSoundProperties(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error);
+    /**
+     * Calls getListMainSourceSoundProperties with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> getListMainSourceSoundPropertiesAsync(const am_sourceID_t& sourceID, GetListMainSourceSoundPropertiesAsyncCallback callback);
+    /**
+     * This is used to retrieve SourceClass Information of all source classes
+     *  
+    (at)return E_OK on success, E_DATABASE_ERROR on error
+     * 
+     * Calls getListSourceClasses with synchronous semantics.
+     * 
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void getListSourceClasses(CommonAPI::CallStatus& callStatus, am_SourceClass_L& listSourceClasses, am_Error_e& error);
+    /**
+     * Calls getListSourceClasses with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> getListSourceClassesAsync(GetListSourceClassesAsyncCallback callback);
+    /**
+     * This is used to retrieve SinkClass Information of all sink classes 
+    (at)return
+     *  E_OK on success, E_DATABASE_ERROR on error
+     * 
+     * Calls getListSinkClasses with synchronous semantics.
+     * 
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void getListSinkClasses(CommonAPI::CallStatus& callStatus, am_SinkClass_L& listSinkClasses, am_Error_e& error);
+    /**
+     * Calls getListSinkClasses with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> getListSinkClassesAsync(GetListSinkClassesAsyncCallback callback);
+    /**
+     * Retrieves a complete list of all systemProperties.
+    (at)return E_OK on success,
+     *  E_DATABASE_ERROR on error
+     * 
+     * Calls getListSystemProperties with synchronous semantics.
+     * 
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void getListSystemProperties(CommonAPI::CallStatus& callStatus, am_SystemProperty_L& listSystemProperties, am_Error_e& error);
+    /**
+     * Calls getListSystemProperties with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> getListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback callback);
+    /**
+     * returns the delay in ms that the audiopath for the given mainConnection
+     *  has
+    (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+     *  yet retrieved, E_DATABASE_ERROR on read error on the database
+     * 
+     * Calls getTimingInformation with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void getTimingInformation(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_timeSync_t& delay, am_Error_e& error);
+    /**
+     * Calls getTimingInformation with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> getTimingInformationAsync(const am_mainConnectionID_t& mainConnectionID, GetTimingInformationAsyncCallback callback);
+    /**
+     * Retrieves the list of MainNotifications for a sink. Does not return the
+     *  possible ones.
+     * 
+     * Calls getListMainSinkNotificationConfigurations with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void getListMainSinkNotificationConfigurations(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error);
+    /**
+     * Calls getListMainSinkNotificationConfigurations with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> getListMainSinkNotificationConfigurationsAsync(const am_sinkID_t& sinkID, GetListMainSinkNotificationConfigurationsAsyncCallback callback);
+    /**
+     * Retrieves the list of MainNotifications for a source. Does not return the
+     *  possible ones.
+     * 
+     * Calls getListMainSourceNotificationConfigurations with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void getListMainSourceNotificationConfigurations(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error);
+    /**
+     * Calls getListMainSourceNotificationConfigurations with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> getListMainSourceNotificationConfigurationsAsync(const am_sourceID_t& sourceID, GetListMainSourceNotificationConfigurationsAsyncCallback callback);
+    /**
+     * sets a MainNotificationConfiuration. This can be used to turn on an off
+     *  notifications an to change the mode of the configuration.
+    (at)return E_OK on
+     *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+     * 
+     * Calls setMainSinkNotificationConfiguration with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void setMainSinkNotificationConfiguration(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls setMainSinkNotificationConfiguration with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> setMainSinkNotificationConfigurationAsync(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSinkNotificationConfigurationAsyncCallback callback);
+    /**
+     * sets a MainNotificationConfiuration. This can be used to turn on an off
+     *  notifications an to change the mode of the configuration.
+    (at)return E_OK on
+     *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+     * 
+     * Calls setMainSourceNotificationConfiguration with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void setMainSourceNotificationConfiguration(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls setMainSourceNotificationConfiguration with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> setMainSourceNotificationConfigurationAsync(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSourceNotificationConfigurationAsyncCallback callback);
+
+
+    /**
+     * Returns the CommonAPI address of the remote partner this proxy communicates with.
+     */
+    virtual std::string getAddress() const;
+
+    /**
+     * Returns the domain of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getDomain() const;
+
+    /** 
+     * Returns the service ID of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getServiceId() const;
+
+    /**
+     * Returns the instance ID of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getInstanceId() const;
+
+    /**
+     * Returns true if the remote partner for this proxy is currently known to be available.
+     */
+    virtual bool isAvailable() const;
+
+    /**
+     * Returns true if the remote partner for this proxy is available.
+     */
+    virtual bool isAvailableBlocking() const;
+
+    /**
+     * Returns the wrapper class that is used to (de-)register for notifications about
+     * the availability of the remote partner of this proxy.
+     */
+    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();
+
+    /**
+     * Returns the wrapper class that is used to access version information of the remote
+     * partner of this proxy.
+     */
+    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();
+
+ private:
+    std::shared_ptr<CommandControlProxyBase> delegate_;
+};
+
+#ifdef WIN32
+    typedef CommandControlProxy<CommonAPI::WINDummyAttributeExtension<CommonAPI::WINDummyAttribute>> CommandControlProxyDefault;
+#else
+    typedef CommandControlProxy<> CommandControlProxyDefault;
+#endif
+
+
+//
+// CommandControlProxy Implementation
+//
+template <typename ... _AttributeExtensions>
+CommandControlProxy<_AttributeExtensions...>::CommandControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
+        _AttributeExtensions(*(std::dynamic_pointer_cast<CommandControlProxyBase>(delegate)))...,
+        delegate_(std::dynamic_pointer_cast<CommandControlProxyBase>(delegate)) {
+}
+
+template <typename ... _AttributeExtensions>
+CommandControlProxy<_AttributeExtensions...>::~CommandControlProxy() {
+}
+
+/**
+ * connects a source to sink
+(at)return E_OK on success, E_NOT_POSSIBLE on
+ *  failure, E_ALREADY_EXISTS if the connection does already exists
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::connect(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_mainConnectionID_t& mainConnectionID, am_Error_e& error) {
+    delegate_->connect(sourceID, sinkID, callStatus, mainConnectionID, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::connectAsync(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, ConnectAsyncCallback callback) {
+    return delegate_->connectAsync(sourceID, sinkID, callback);
+}
+/**
+ * disconnects a mainConnection
+(at)return E_OK on successes, E_NON_EXISTENT if
+ *  the connection does not exist, E_NOT_POSSIBLE on error.
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::disconnect(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->disconnect(mainConnectionID, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::disconnectAsync(const am_mainConnectionID_t& mainConnectionID, DisconnectAsyncCallback callback) {
+    return delegate_->disconnectAsync(mainConnectionID, callback);
+}
+/**
+ * sets the volume for a sink
+(at)return E_OK on success, E_UNKOWN on error,
+ *  E_OUT_OF_RANGE in case the value is out of range
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::setVolume(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->setVolume(sinkID, volume, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setVolumeAsync(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, SetVolumeAsyncCallback callback) {
+    return delegate_->setVolumeAsync(sinkID, volume, callback);
+}
+/**
+ * This function is used to increment or decrement the current volume for a
+ *  sink.
+(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+ *  value is not in the given volume range.
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::volumeStep(const am_sinkID_t& sinkID, const int16_t& volStep, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->volumeStep(sinkID, volStep, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volStep, VolumeStepAsyncCallback callback) {
+    return delegate_->volumeStepAsync(sinkID, volStep, callback);
+}
+/**
+ * sets the mute state of a sink
+(at)return E_OK on success, E_UNKNOWN on error.
+ *  If the mute state is already the desired one, the Daemon will return E_OK.
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::setSinkMuteState(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->setSinkMuteState(sinkID, muteState, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setSinkMuteStateAsync(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, SetSinkMuteStateAsyncCallback callback) {
+    return delegate_->setSinkMuteStateAsync(sinkID, muteState, callback);
+}
+/**
+ * This method is used to set sound properties, e.g. Equalizer Values. Since the
+ *  capabilities of the system can differ, the exact key value pairs can be
+ *  extended in each product
+(at)return E_OK on success, E_OUT_OF_RANGE if value
+ *  exceeds range, E_UNKNOWN in case of an error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::setMainSinkSoundProperty(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->setMainSinkSoundProperty(sinkID, soundProperty, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSinkSoundPropertyAsync(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, SetMainSinkSoundPropertyAsyncCallback callback) {
+    return delegate_->setMainSinkSoundPropertyAsync(sinkID, soundProperty, callback);
+}
+/**
+ * This method is used to set sound properties, e.g. Equalizer Values. Since the
+ *  capabilities of the system can differ, the exact key value pairs can be
+ *  extended in each product
+(at)return E_OK on success, E_OUT_OF_RANGE if value
+ *  exceeds range, E_UNKNOWN in case of an error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::setMainSourceSoundProperty(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->setMainSourceSoundProperty(sourceID, soundProperty, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSourceSoundPropertyAsync(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, SetMainSourceSoundPropertyAsyncCallback callback) {
+    return delegate_->setMainSourceSoundPropertyAsync(sourceID, soundProperty, callback);
+}
+/**
+ * is used to set a specific system property.
+(at)return E_OK on success,
+ *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::setSystemProperty(const am_SystemProperty_s& property, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->setSystemProperty(property, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setSystemPropertyAsync(const am_SystemProperty_s& property, SetSystemPropertyAsyncCallback callback) {
+    return delegate_->setSystemPropertyAsync(property, callback);
+}
+/**
+ * returns the actual list of MainConnections
+(at)return E_OK on success,
+ *  E_DATABASE_ERROR on error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::getListMainConnections(CommonAPI::CallStatus& callStatus, am_MainConnection_L& listConnections, am_Error_e& error) {
+    delegate_->getListMainConnections(callStatus, listConnections, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainConnectionsAsync(GetListMainConnectionsAsyncCallback callback) {
+    return delegate_->getListMainConnectionsAsync(callback);
+}
+/**
+ * returns the actual list of Sinks
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::getListMainSinks(CommonAPI::CallStatus& callStatus, am_SinkType_L& listMainSinks, am_Error_e& error) {
+    delegate_->getListMainSinks(callStatus, listMainSinks, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSinksAsync(GetListMainSinksAsyncCallback callback) {
+    return delegate_->getListMainSinksAsync(callback);
+}
+/**
+ * returns the actual list of Sources
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error) {
+    delegate_->getListMainSources(callStatus, listMainSources, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSourcesAsync(GetListMainSourcesAsyncCallback callback) {
+    return delegate_->getListMainSourcesAsync(callback);
+}
+/**
+ * This is used to retrieve all source sound properties related to a source.
+ *  Returns a vector of the sound properties and values as pair
+(at)return E_OK on
+ *  success, E_DATABASE_ERROR on error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) {
+    delegate_->getListMainSinkSoundProperties(sinkID, callStatus, listSoundProperties, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSinkSoundPropertiesAsync(const am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback) {
+    return delegate_->getListMainSinkSoundPropertiesAsync(sinkID, callback);
+}
+/**
+ * This is used to retrieve all source sound properties related to a
+ *  source.
+(at)return E_OK on success, E_DATABASE_ERROR on error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::getListMainSourceSoundProperties(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error) {
+    delegate_->getListMainSourceSoundProperties(sourceID, callStatus, listSourceProperties, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSourceSoundPropertiesAsync(const am_sourceID_t& sourceID, GetListMainSourceSoundPropertiesAsyncCallback callback) {
+    return delegate_->getListMainSourceSoundPropertiesAsync(sourceID, callback);
+}
+/**
+ * This is used to retrieve SourceClass Information of all source classes
+ *  
+(at)return E_OK on success, E_DATABASE_ERROR on error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::getListSourceClasses(CommonAPI::CallStatus& callStatus, am_SourceClass_L& listSourceClasses, am_Error_e& error) {
+    delegate_->getListSourceClasses(callStatus, listSourceClasses, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListSourceClassesAsync(GetListSourceClassesAsyncCallback callback) {
+    return delegate_->getListSourceClassesAsync(callback);
+}
+/**
+ * This is used to retrieve SinkClass Information of all sink classes 
+(at)return
+ *  E_OK on success, E_DATABASE_ERROR on error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::getListSinkClasses(CommonAPI::CallStatus& callStatus, am_SinkClass_L& listSinkClasses, am_Error_e& error) {
+    delegate_->getListSinkClasses(callStatus, listSinkClasses, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListSinkClassesAsync(GetListSinkClassesAsyncCallback callback) {
+    return delegate_->getListSinkClassesAsync(callback);
+}
+/**
+ * Retrieves a complete list of all systemProperties.
+(at)return E_OK on success,
+ *  E_DATABASE_ERROR on error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::getListSystemProperties(CommonAPI::CallStatus& callStatus, am_SystemProperty_L& listSystemProperties, am_Error_e& error) {
+    delegate_->getListSystemProperties(callStatus, listSystemProperties, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback callback) {
+    return delegate_->getListSystemPropertiesAsync(callback);
+}
+/**
+ * returns the delay in ms that the audiopath for the given mainConnection
+ *  has
+(at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+ *  yet retrieved, E_DATABASE_ERROR on read error on the database
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::getTimingInformation(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_timeSync_t& delay, am_Error_e& error) {
+    delegate_->getTimingInformation(mainConnectionID, callStatus, delay, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getTimingInformationAsync(const am_mainConnectionID_t& mainConnectionID, GetTimingInformationAsyncCallback callback) {
+    return delegate_->getTimingInformationAsync(mainConnectionID, callback);
+}
+/**
+ * Retrieves the list of MainNotifications for a sink. Does not return the
+ *  possible ones.
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::getListMainSinkNotificationConfigurations(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) {
+    delegate_->getListMainSinkNotificationConfigurations(sinkID, callStatus, listMainNotificationConfigurations, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSinkNotificationConfigurationsAsync(const am_sinkID_t& sinkID, GetListMainSinkNotificationConfigurationsAsyncCallback callback) {
+    return delegate_->getListMainSinkNotificationConfigurationsAsync(sinkID, callback);
+}
+/**
+ * Retrieves the list of MainNotifications for a source. Does not return the
+ *  possible ones.
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::getListMainSourceNotificationConfigurations(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) {
+    delegate_->getListMainSourceNotificationConfigurations(sourceID, callStatus, listMainNotificationConfigurations, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSourceNotificationConfigurationsAsync(const am_sourceID_t& sourceID, GetListMainSourceNotificationConfigurationsAsyncCallback callback) {
+    return delegate_->getListMainSourceNotificationConfigurationsAsync(sourceID, callback);
+}
+/**
+ * sets a MainNotificationConfiuration. This can be used to turn on an off
+ *  notifications an to change the mode of the configuration.
+(at)return E_OK on
+ *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::setMainSinkNotificationConfiguration(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->setMainSinkNotificationConfiguration(sinkID, mainNotificationConfiguration, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSinkNotificationConfigurationAsync(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSinkNotificationConfigurationAsyncCallback callback) {
+    return delegate_->setMainSinkNotificationConfigurationAsync(sinkID, mainNotificationConfiguration, callback);
+}
+/**
+ * sets a MainNotificationConfiuration. This can be used to turn on an off
+ *  notifications an to change the mode of the configuration.
+(at)return E_OK on
+ *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+ */
+template <typename ... _AttributeExtensions>
+void CommandControlProxy<_AttributeExtensions...>::setMainSourceNotificationConfiguration(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->setMainSourceNotificationConfiguration(sourceID, mainNotificationConfiguration, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSourceNotificationConfigurationAsync(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSourceNotificationConfigurationAsyncCallback callback) {
+    return delegate_->setMainSourceNotificationConfigurationAsync(sourceID, mainNotificationConfiguration, callback);
+}
+
+template <typename ... _AttributeExtensions>
+std::string CommandControlProxy<_AttributeExtensions...>::getAddress() const {
+    return delegate_->getAddress();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& CommandControlProxy<_AttributeExtensions...>::getDomain() const {
+    return delegate_->getDomain();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& CommandControlProxy<_AttributeExtensions...>::getServiceId() const {
+    return delegate_->getServiceId();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& CommandControlProxy<_AttributeExtensions...>::getInstanceId() const {
+    return delegate_->getInstanceId();
+}
+
+template <typename ... _AttributeExtensions>
+bool CommandControlProxy<_AttributeExtensions...>::isAvailable() const {
+    return delegate_->isAvailable();
+}
+
+template <typename ... _AttributeExtensions>
+bool CommandControlProxy<_AttributeExtensions...>::isAvailableBlocking() const {
+    return delegate_->isAvailableBlocking();
+}
+
+template <typename ... _AttributeExtensions>
+CommonAPI::ProxyStatusEvent& CommandControlProxy<_AttributeExtensions...>::getProxyStatusEvent() {
+    return delegate_->getProxyStatusEvent();
+}
+
+template <typename ... _AttributeExtensions>
+CommonAPI::InterfaceVersionAttribute& CommandControlProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
+    return delegate_->getInterfaceVersionAttribute();
+}
+
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+
+#endif // ORG_GENIVI_AM_Command_Control_PROXY_H_
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxyBase.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxyBase.h
new file mode 100644
index 0000000..767b9e1
--- /dev/null
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlProxyBase.h
@@ -0,0 +1,348 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * The interface towards the Controlling Instance (e.g HMI). It handles the
+ *  communication towards the HMI and other system components who need to interact
+ *  with the audiomanagement.
+There are two rules that have to be kept in mind
+ *  when implementing against this interface:
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Command_Control_PROXY_BASE_H_
+#define ORG_GENIVI_AM_Command_Control_PROXY_BASE_H_
+
+#include "CommandControl.h"
+
+
+#include <org/genivi/am.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/InputStream.h>
+#include <CommonAPI/OutputStream.h>
+#include <CommonAPI/SerializableStruct.h>
+#include <cstdint>
+#include <string>
+#include <vector>
+
+#include <CommonAPI/Event.h>
+#include <CommonAPI/Proxy.h>
+#include <functional>
+#include <future>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+class CommandControlProxyBase: virtual public CommonAPI::Proxy {
+ public:
+    typedef CommonAPI::Event<am_MainConnectionType_s> NewMainConnectionEvent;
+    typedef CommonAPI::Event<am_mainConnectionID_t> RemovedMainConnectionEvent;
+    typedef CommonAPI::Event<am_SinkType_s> NewSinkEvent;
+    typedef CommonAPI::Event<am_sinkID_t> RemovedSinkEvent;
+    typedef CommonAPI::Event<am_SourceType_s> NewSourceEvent;
+    typedef CommonAPI::Event<am_sourceID_t> RemovedSourceEvent;
+    typedef CommonAPI::Event<> NumberOfSinkClassesChangedEvent;
+    typedef CommonAPI::Event<> NumberOfSourceClassesChangedEvent;
+    typedef CommonAPI::Event<am_mainConnectionID_t, am_ConnectionState_e> MainConnectionStateChangedEvent;
+    typedef CommonAPI::Event<am_sinkID_t, am_MainSoundProperty_s> MainSinkSoundPropertyChangedEvent;
+    typedef CommonAPI::Event<am_sourceID_t, am_MainSoundProperty_s> MainSourceSoundPropertyChangedEvent;
+    typedef CommonAPI::Event<am_sinkID_t, am_Availability_s> SinkAvailabilityChangedEvent;
+    typedef CommonAPI::Event<am_sourceID_t, am_Availability_s> SourceAvailabilityChangedEvent;
+    typedef CommonAPI::Event<am_sinkID_t, am_mainVolume_t> VolumeChangedEvent;
+    typedef CommonAPI::Event<am_sinkID_t, am_MuteState_e> SinkMuteStateChangedEvent;
+    typedef CommonAPI::Event<am_SystemProperty_s> SystemPropertyChangedEvent;
+    typedef CommonAPI::Event<am_mainConnectionID_t, am_timeSync_t> TimingInformationChangedEvent;
+    typedef CommonAPI::Event<am_sinkID_t, am_sinkClass_t, am_MainSoundProperty_L> SinkUpdatedEvent;
+    typedef CommonAPI::Event<am_sourceID_t, am_sourceClass_t, am_MainSoundProperty_L> SourceUpdatedEvent;
+    typedef CommonAPI::Event<am_sinkID_t, am_NotificationPayload_s> SinkNotificationEvent;
+    typedef CommonAPI::Event<am_sourceID_t, am_NotificationPayload_s> SourceNotificationEvent;
+    typedef CommonAPI::Event<am_sinkID_t, am_NotificationConfiguration_s> MainSinkNotificationConfigurationChangedEvent;
+    typedef CommonAPI::Event<am_sourceID_t, am_NotificationConfiguration_s> MainSourceNotificationConfigurationChangedEvent;
+
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_mainConnectionID_t&, const am_Error_e&)> ConnectAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> DisconnectAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> SetVolumeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> VolumeStepAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> SetSinkMuteStateAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> SetMainSinkSoundPropertyAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> SetMainSourceSoundPropertyAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> SetSystemPropertyAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_MainConnection_L&, const am_Error_e&)> GetListMainConnectionsAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_SinkType_L&, const am_Error_e&)> GetListMainSinksAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_SourceType_L&, const am_Error_e&)> GetListMainSourcesAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_MainSoundProperty_L&, const am_Error_e&)> GetListMainSinkSoundPropertiesAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_MainSoundProperty_L&, const am_Error_e&)> GetListMainSourceSoundPropertiesAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_SourceClass_L&, const am_Error_e&)> GetListSourceClassesAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_SinkClass_L&, const am_Error_e&)> GetListSinkClassesAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_SystemProperty_L&, const am_Error_e&)> GetListSystemPropertiesAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_timeSync_t&, const am_Error_e&)> GetTimingInformationAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_NotificationConfiguration_L&, const am_Error_e&)> GetListMainSinkNotificationConfigurationsAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_NotificationConfiguration_L&, const am_Error_e&)> GetListMainSourceNotificationConfigurationsAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> SetMainSinkNotificationConfigurationAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> SetMainSourceNotificationConfigurationAsyncCallback;
+
+
+    /**
+     * Callback that is called when the number of connections change
+     */
+    virtual NewMainConnectionEvent& getNewMainConnectionEvent() = 0;
+    /**
+     * Callback that is called when the number of connections change
+     */
+    virtual RemovedMainConnectionEvent& getRemovedMainConnectionEvent() = 0;
+    /**
+     * Callback that is called when the number of sinks change
+     */
+    virtual NewSinkEvent& getNewSinkEvent() = 0;
+    /**
+     * Callback that is called when the number of sinks change
+     */
+    virtual RemovedSinkEvent& getRemovedSinkEvent() = 0;
+    /**
+     * Callback that is called when the number of sources change
+     */
+    virtual NewSourceEvent& getNewSourceEvent() = 0;
+    /**
+     * Callback that is called when the number of sources change
+     */
+    virtual RemovedSourceEvent& getRemovedSourceEvent() = 0;
+    /**
+     * this callback is fired if the number of sink classes changed
+     */
+    virtual NumberOfSinkClassesChangedEvent& getNumberOfSinkClassesChangedEvent() = 0;
+    /**
+     * this callback is fired if the number of source classes changed
+     */
+    virtual NumberOfSourceClassesChangedEvent& getNumberOfSourceClassesChangedEvent() = 0;
+    /**
+     * This callback is called when the ConnectionState of a connection changed.
+     */
+    virtual MainConnectionStateChangedEvent& getMainConnectionStateChangedEvent() = 0;
+    /**
+     * this callback indicates that a sinkSoundProperty has changed.
+     */
+    virtual MainSinkSoundPropertyChangedEvent& getMainSinkSoundPropertyChangedEvent() = 0;
+    /**
+     * this callback indicates that a sourceSoundProperty has changed.
+     */
+    virtual MainSourceSoundPropertyChangedEvent& getMainSourceSoundPropertyChangedEvent() = 0;
+    /**
+     * this callback is called when the availability of a sink has changed
+     */
+    virtual SinkAvailabilityChangedEvent& getSinkAvailabilityChangedEvent() = 0;
+    /**
+     * this callback is called when the availability of source has changed.
+     */
+    virtual SourceAvailabilityChangedEvent& getSourceAvailabilityChangedEvent() = 0;
+    /**
+     * this callback indicates a volume change on the indicated sink
+     */
+    virtual VolumeChangedEvent& getVolumeChangedEvent() = 0;
+    /**
+     * this callback indicates a mute state change on a sink.
+     */
+    virtual SinkMuteStateChangedEvent& getSinkMuteStateChangedEvent() = 0;
+    /**
+     * is fired if a systemProperty changed
+     */
+    virtual SystemPropertyChangedEvent& getSystemPropertyChangedEvent() = 0;
+    /**
+     * This callback is fired if the timinginformation for a mainConnectionID changed
+     */
+    virtual TimingInformationChangedEvent& getTimingInformationChangedEvent() = 0;
+    /**
+     * This callback is called when a sink is updated.
+     */
+    virtual SinkUpdatedEvent& getSinkUpdatedEvent() = 0;
+    /**
+     * This callback is called when a source is updated.
+     */
+    virtual SourceUpdatedEvent& getSourceUpdatedEvent() = 0;
+    /**
+     * This callback is called when a notificated value of a sink changes.
+     */
+    virtual SinkNotificationEvent& getSinkNotificationEvent() = 0;
+    /**
+     * This callback is called when a notifcated value of a source changes.
+     */
+    virtual SourceNotificationEvent& getSourceNotificationEvent() = 0;
+    /**
+     * This callback is triggered when a mainNotificationConfiguration is changed.
+     */
+    virtual MainSinkNotificationConfigurationChangedEvent& getMainSinkNotificationConfigurationChangedEvent() = 0;
+    /**
+     * This callback is triggered when a mainNotificationConfiguration is changed.
+     */
+    virtual MainSourceNotificationConfigurationChangedEvent& getMainSourceNotificationConfigurationChangedEvent() = 0;
+
+    /**
+     * connects a source to sink
+    (at)return E_OK on success, E_NOT_POSSIBLE on
+     *  failure, E_ALREADY_EXISTS if the connection does already exists
+     */
+    virtual void connect(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_mainConnectionID_t& mainConnectionID, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> connectAsync(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, ConnectAsyncCallback callback) = 0;
+    /**
+     * disconnects a mainConnection
+    (at)return E_OK on successes, E_NON_EXISTENT if
+     *  the connection does not exist, E_NOT_POSSIBLE on error.
+     */
+    virtual void disconnect(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> disconnectAsync(const am_mainConnectionID_t& mainConnectionID, DisconnectAsyncCallback callback) = 0;
+    /**
+     * sets the volume for a sink
+    (at)return E_OK on success, E_UNKOWN on error,
+     *  E_OUT_OF_RANGE in case the value is out of range
+     */
+    virtual void setVolume(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> setVolumeAsync(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, SetVolumeAsyncCallback callback) = 0;
+    /**
+     * This function is used to increment or decrement the current volume for a
+     *  sink.
+    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+     *  value is not in the given volume range.
+     */
+    virtual void volumeStep(const am_sinkID_t& sinkID, const int16_t& volStep, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volStep, VolumeStepAsyncCallback callback) = 0;
+    /**
+     * sets the mute state of a sink
+    (at)return E_OK on success, E_UNKNOWN on error.
+     *  If the mute state is already the desired one, the Daemon will return E_OK.
+     */
+    virtual void setSinkMuteState(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> setSinkMuteStateAsync(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, SetSinkMuteStateAsyncCallback callback) = 0;
+    /**
+     * This method is used to set sound properties, e.g. Equalizer Values. Since the
+     *  capabilities of the system can differ, the exact key value pairs can be
+     *  extended in each product
+    (at)return E_OK on success, E_OUT_OF_RANGE if value
+     *  exceeds range, E_UNKNOWN in case of an error
+     */
+    virtual void setMainSinkSoundProperty(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> setMainSinkSoundPropertyAsync(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, SetMainSinkSoundPropertyAsyncCallback callback) = 0;
+    /**
+     * This method is used to set sound properties, e.g. Equalizer Values. Since the
+     *  capabilities of the system can differ, the exact key value pairs can be
+     *  extended in each product
+    (at)return E_OK on success, E_OUT_OF_RANGE if value
+     *  exceeds range, E_UNKNOWN in case of an error
+     */
+    virtual void setMainSourceSoundProperty(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> setMainSourceSoundPropertyAsync(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, SetMainSourceSoundPropertyAsyncCallback callback) = 0;
+    /**
+     * is used to set a specific system property.
+    (at)return E_OK on success,
+     *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+     */
+    virtual void setSystemProperty(const am_SystemProperty_s& property, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> setSystemPropertyAsync(const am_SystemProperty_s& property, SetSystemPropertyAsyncCallback callback) = 0;
+    /**
+     * returns the actual list of MainConnections
+    (at)return E_OK on success,
+     *  E_DATABASE_ERROR on error
+     */
+    virtual void getListMainConnections(CommonAPI::CallStatus& callStatus, am_MainConnection_L& listConnections, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> getListMainConnectionsAsync(GetListMainConnectionsAsyncCallback callback) = 0;
+    /**
+     * returns the actual list of Sinks
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
+     */
+    virtual void getListMainSinks(CommonAPI::CallStatus& callStatus, am_SinkType_L& listMainSinks, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> getListMainSinksAsync(GetListMainSinksAsyncCallback callback) = 0;
+    /**
+     * returns the actual list of Sources
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
+     */
+    virtual void getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> getListMainSourcesAsync(GetListMainSourcesAsyncCallback callback) = 0;
+    /**
+     * This is used to retrieve all source sound properties related to a source.
+     *  Returns a vector of the sound properties and values as pair
+    (at)return E_OK on
+     *  success, E_DATABASE_ERROR on error
+     */
+    virtual void getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> getListMainSinkSoundPropertiesAsync(const am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback) = 0;
+    /**
+     * This is used to retrieve all source sound properties related to a
+     *  source.
+    (at)return E_OK on success, E_DATABASE_ERROR on error
+     */
+    virtual void getListMainSourceSoundProperties(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> getListMainSourceSoundPropertiesAsync(const am_sourceID_t& sourceID, GetListMainSourceSoundPropertiesAsyncCallback callback) = 0;
+    /**
+     * This is used to retrieve SourceClass Information of all source classes
+     *  
+    (at)return E_OK on success, E_DATABASE_ERROR on error
+     */
+    virtual void getListSourceClasses(CommonAPI::CallStatus& callStatus, am_SourceClass_L& listSourceClasses, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> getListSourceClassesAsync(GetListSourceClassesAsyncCallback callback) = 0;
+    /**
+     * This is used to retrieve SinkClass Information of all sink classes 
+    (at)return
+     *  E_OK on success, E_DATABASE_ERROR on error
+     */
+    virtual void getListSinkClasses(CommonAPI::CallStatus& callStatus, am_SinkClass_L& listSinkClasses, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> getListSinkClassesAsync(GetListSinkClassesAsyncCallback callback) = 0;
+    /**
+     * Retrieves a complete list of all systemProperties.
+    (at)return E_OK on success,
+     *  E_DATABASE_ERROR on error
+     */
+    virtual void getListSystemProperties(CommonAPI::CallStatus& callStatus, am_SystemProperty_L& listSystemProperties, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> getListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback callback) = 0;
+    /**
+     * returns the delay in ms that the audiopath for the given mainConnection
+     *  has
+    (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+     *  yet retrieved, E_DATABASE_ERROR on read error on the database
+     */
+    virtual void getTimingInformation(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_timeSync_t& delay, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> getTimingInformationAsync(const am_mainConnectionID_t& mainConnectionID, GetTimingInformationAsyncCallback callback) = 0;
+    /**
+     * Retrieves the list of MainNotifications for a sink. Does not return the
+     *  possible ones.
+     */
+    virtual void getListMainSinkNotificationConfigurations(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> getListMainSinkNotificationConfigurationsAsync(const am_sinkID_t& sinkID, GetListMainSinkNotificationConfigurationsAsyncCallback callback) = 0;
+    /**
+     * Retrieves the list of MainNotifications for a source. Does not return the
+     *  possible ones.
+     */
+    virtual void getListMainSourceNotificationConfigurations(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> getListMainSourceNotificationConfigurationsAsync(const am_sourceID_t& sourceID, GetListMainSourceNotificationConfigurationsAsyncCallback callback) = 0;
+    /**
+     * sets a MainNotificationConfiuration. This can be used to turn on an off
+     *  notifications an to change the mode of the configuration.
+    (at)return E_OK on
+     *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+     */
+    virtual void setMainSinkNotificationConfiguration(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> setMainSinkNotificationConfigurationAsync(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSinkNotificationConfigurationAsyncCallback callback) = 0;
+    /**
+     * sets a MainNotificationConfiuration. This can be used to turn on an off
+     *  notifications an to change the mode of the configuration.
+    (at)return E_OK on
+     *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+     */
+    virtual void setMainSourceNotificationConfiguration(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> setMainSourceNotificationConfigurationAsync(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSourceNotificationConfigurationAsyncCallback callback) = 0;
+};
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Command_Control_PROXY_BASE_H_
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStub.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStub.h
new file mode 100644
index 0000000..4e15ce0
--- /dev/null
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStub.h
@@ -0,0 +1,492 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * The interface towards the Controlling Instance (e.g HMI). It handles the
+ *  communication towards the HMI and other system components who need to interact
+ *  with the audiomanagement.
+There are two rules that have to be kept in mind
+ *  when implementing against this interface:
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Command_Control_STUB_H_
+#define ORG_GENIVI_AM_Command_Control_STUB_H_
+
+
+
+#include <org/genivi/am.h>
+
+#include "CommandControl.h"
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/InputStream.h>
+#include <CommonAPI/OutputStream.h>
+#include <CommonAPI/SerializableStruct.h>
+#include <cstdint>
+#include <string>
+#include <unordered_set>
+#include <vector>
+
+#include <CommonAPI/Stub.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+/**
+ * Receives messages from remote and handles all dispatching of deserialized calls
+ * to a stub for the service CommandControl. Also provides means to send broadcasts
+ * and attribute-changed-notifications of observable attributes as defined by this service.
+ * An application developer should not need to bother with this class.
+ */
+class CommandControlStubAdapter: virtual public CommonAPI::StubAdapter, public CommandControl {
+ public:
+
+    /**
+     * Sends a broadcast event for newMainConnection. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireNewMainConnectionEvent(const am_MainConnectionType_s& mainConnection) = 0;
+    /**
+     * Sends a broadcast event for removedMainConnection. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireRemovedMainConnectionEvent(const am_mainConnectionID_t& mainConnection) = 0;
+    /**
+     * Sends a broadcast event for newSink. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireNewSinkEvent(const am_SinkType_s& sink) = 0;
+    /**
+     * Sends a broadcast event for removedSink. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireRemovedSinkEvent(const am_sinkID_t& sinkID) = 0;
+    /**
+     * Sends a broadcast event for newSource. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireNewSourceEvent(const am_SourceType_s& source) = 0;
+    /**
+     * Sends a broadcast event for removedSource. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireRemovedSourceEvent(const am_sourceID_t& source) = 0;
+    /**
+     * Sends a broadcast event for numberOfSinkClassesChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireNumberOfSinkClassesChangedEvent() = 0;
+    /**
+     * Sends a broadcast event for numberOfSourceClassesChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireNumberOfSourceClassesChangedEvent() = 0;
+    /**
+     * Sends a broadcast event for mainConnectionStateChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireMainConnectionStateChangedEvent(const am_mainConnectionID_t& connectionID, const am_ConnectionState_e& connectionState) = 0;
+    /**
+     * Sends a broadcast event for mainSinkSoundPropertyChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireMainSinkSoundPropertyChangedEvent(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty) = 0;
+    /**
+     * Sends a broadcast event for mainSourceSoundPropertyChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireMainSourceSoundPropertyChangedEvent(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty) = 0;
+    /**
+     * Sends a broadcast event for sinkAvailabilityChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireSinkAvailabilityChangedEvent(const am_sinkID_t& sinkID, const am_Availability_s& availability) = 0;
+    /**
+     * Sends a broadcast event for sourceAvailabilityChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireSourceAvailabilityChangedEvent(const am_sourceID_t& sourceID, const am_Availability_s& availability) = 0;
+    /**
+     * Sends a broadcast event for volumeChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireVolumeChangedEvent(const am_sinkID_t& sinkID, const am_mainVolume_t& volume) = 0;
+    /**
+     * Sends a broadcast event for sinkMuteStateChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireSinkMuteStateChangedEvent(const am_sinkID_t& sinkID, const am_MuteState_e& muteState) = 0;
+    /**
+     * Sends a broadcast event for systemPropertyChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireSystemPropertyChangedEvent(const am_SystemProperty_s& systemProperty) = 0;
+    /**
+     * Sends a broadcast event for timingInformationChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireTimingInformationChangedEvent(const am_mainConnectionID_t& mainConnectionID, const am_timeSync_t& time) = 0;
+    /**
+     * Sends a broadcast event for sinkUpdated. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireSinkUpdatedEvent(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_MainSoundProperty_L& listMainSoundProperties) = 0;
+    /**
+     * Sends a broadcast event for sourceUpdated. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireSourceUpdatedEvent(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_MainSoundProperty_L& listMainSoundProperties) = 0;
+    /**
+     * Sends a broadcast event for sinkNotification. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireSinkNotificationEvent(const am_sinkID_t& sinkID, const am_NotificationPayload_s& notification) = 0;
+    /**
+     * Sends a broadcast event for sourceNotification. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireSourceNotificationEvent(const am_sourceID_t& sourceID, const am_NotificationPayload_s& notification) = 0;
+    /**
+     * Sends a broadcast event for mainSinkNotificationConfigurationChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireMainSinkNotificationConfigurationChangedEvent(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration) = 0;
+    /**
+     * Sends a broadcast event for mainSourceNotificationConfigurationChanged. Should not be called directly.
+     * Instead, the "fire<broadcastName>Event" methods of the stub should be used.
+     */
+    virtual void fireMainSourceNotificationConfigurationChangedEvent(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration) = 0;
+
+
+    virtual void deactivateManagedInstances() = 0;
+protected:
+    /**
+     * Defines properties for storing the ClientIds of clients / proxies that have
+     * subscribed to the selective broadcasts
+     */
+};
+
+
+/**
+ * Defines the necessary callbacks to handle remote set events related to the attributes
+ * defined in the IDL description for CommandControl.
+ * For each attribute two callbacks are defined:
+ * - a verification callback that allows to verify the requested value and to prevent setting
+ *   e.g. an invalid value ("onRemoteSet<AttributeName>").
+ * - an action callback to do local work after the attribute value has been changed
+ *   ("onRemote<AttributeName>Changed").
+ *
+ * This class and the one below are the ones an application developer needs to have
+ * a look at if he wants to implement a service.
+ */
+class CommandControlStubRemoteEvent {
+ public:
+    virtual ~CommandControlStubRemoteEvent() { }
+
+};
+
+
+/**
+ * Defines the interface that must be implemented by any class that should provide
+ * the service CommandControl to remote clients.
+ * This class and the one above are the ones an application developer needs to have
+ * a look at if he wants to implement a service.
+ */
+class CommandControlStub: public virtual CommonAPI::Stub<CommandControlStubAdapter, CommandControlStubRemoteEvent> {
+public:
+    virtual ~CommandControlStub() { }
+    virtual const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
+
+
+    /**
+     * connects a source to sink
+    (at)return E_OK on success, E_NOT_POSSIBLE on
+     *  failure, E_ALREADY_EXISTS if the connection does already exists
+     */
+    /// This is the method that will be called on remote calls on the method connect.
+    virtual void connect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_sinkID_t sinkID, am_mainConnectionID_t& mainConnectionID, am_Error_e& error) = 0;
+    /**
+     * disconnects a mainConnection
+    (at)return E_OK on successes, E_NON_EXISTENT if
+     *  the connection does not exist, E_NOT_POSSIBLE on error.
+     */
+    /// This is the method that will be called on remote calls on the method disconnect.
+    virtual void disconnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_mainConnectionID_t mainConnectionID, am_Error_e& error) = 0;
+    /**
+     * sets the volume for a sink
+    (at)return E_OK on success, E_UNKOWN on error,
+     *  E_OUT_OF_RANGE in case the value is out of range
+     */
+    /// This is the method that will be called on remote calls on the method setVolume.
+    virtual void setVolume(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_mainVolume_t volume, am_Error_e& error) = 0;
+    /**
+     * This function is used to increment or decrement the current volume for a
+     *  sink.
+    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+     *  value is not in the given volume range.
+     */
+    /// This is the method that will be called on remote calls on the method volumeStep.
+    virtual void volumeStep(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, int16_t volStep, am_Error_e& error) = 0;
+    /**
+     * sets the mute state of a sink
+    (at)return E_OK on success, E_UNKNOWN on error.
+     *  If the mute state is already the desired one, the Daemon will return E_OK.
+     */
+    /// This is the method that will be called on remote calls on the method setSinkMuteState.
+    virtual void setSinkMuteState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_MuteState_e muteState, am_Error_e& error) = 0;
+    /**
+     * This method is used to set sound properties, e.g. Equalizer Values. Since the
+     *  capabilities of the system can differ, the exact key value pairs can be
+     *  extended in each product
+    (at)return E_OK on success, E_OUT_OF_RANGE if value
+     *  exceeds range, E_UNKNOWN in case of an error
+     */
+    /// This is the method that will be called on remote calls on the method setMainSinkSoundProperty.
+    virtual void setMainSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_MainSoundProperty_s soundProperty, am_Error_e& error) = 0;
+    /**
+     * This method is used to set sound properties, e.g. Equalizer Values. Since the
+     *  capabilities of the system can differ, the exact key value pairs can be
+     *  extended in each product
+    (at)return E_OK on success, E_OUT_OF_RANGE if value
+     *  exceeds range, E_UNKNOWN in case of an error
+     */
+    /// This is the method that will be called on remote calls on the method setMainSourceSoundProperty.
+    virtual void setMainSourceSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_MainSoundProperty_s soundProperty, am_Error_e& error) = 0;
+    /**
+     * is used to set a specific system property.
+    (at)return E_OK on success,
+     *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+     */
+    /// This is the method that will be called on remote calls on the method setSystemProperty.
+    virtual void setSystemProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SystemProperty_s property, am_Error_e& error) = 0;
+    /**
+     * returns the actual list of MainConnections
+    (at)return E_OK on success,
+     *  E_DATABASE_ERROR on error
+     */
+    /// This is the method that will be called on remote calls on the method getListMainConnections.
+    virtual void getListMainConnections(const std::shared_ptr<CommonAPI::ClientId> clientId, am_MainConnection_L& listConnections, am_Error_e& error) = 0;
+    /**
+     * returns the actual list of Sinks
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
+     */
+    /// This is the method that will be called on remote calls on the method getListMainSinks.
+    virtual void getListMainSinks(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SinkType_L& listMainSinks, am_Error_e& error) = 0;
+    /**
+     * returns the actual list of Sources
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
+     */
+    /// This is the method that will be called on remote calls on the method getListMainSources.
+    virtual void getListMainSources(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SourceType_L& listMainSources, am_Error_e& error) = 0;
+    /**
+     * This is used to retrieve all source sound properties related to a source.
+     *  Returns a vector of the sound properties and values as pair
+    (at)return E_OK on
+     *  success, E_DATABASE_ERROR on error
+     */
+    /// This is the method that will be called on remote calls on the method getListMainSinkSoundProperties.
+    virtual void getListMainSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) = 0;
+    /**
+     * This is used to retrieve all source sound properties related to a
+     *  source.
+    (at)return E_OK on success, E_DATABASE_ERROR on error
+     */
+    /// This is the method that will be called on remote calls on the method getListMainSourceSoundProperties.
+    virtual void getListMainSourceSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error) = 0;
+    /**
+     * This is used to retrieve SourceClass Information of all source classes
+     *  
+    (at)return E_OK on success, E_DATABASE_ERROR on error
+     */
+    /// This is the method that will be called on remote calls on the method getListSourceClasses.
+    virtual void getListSourceClasses(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SourceClass_L& listSourceClasses, am_Error_e& error) = 0;
+    /**
+     * This is used to retrieve SinkClass Information of all sink classes 
+    (at)return
+     *  E_OK on success, E_DATABASE_ERROR on error
+     */
+    /// This is the method that will be called on remote calls on the method getListSinkClasses.
+    virtual void getListSinkClasses(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SinkClass_L& listSinkClasses, am_Error_e& error) = 0;
+    /**
+     * Retrieves a complete list of all systemProperties.
+    (at)return E_OK on success,
+     *  E_DATABASE_ERROR on error
+     */
+    /// This is the method that will be called on remote calls on the method getListSystemProperties.
+    virtual void getListSystemProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SystemProperty_L& listSystemProperties, am_Error_e& error) = 0;
+    /**
+     * returns the delay in ms that the audiopath for the given mainConnection
+     *  has
+    (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+     *  yet retrieved, E_DATABASE_ERROR on read error on the database
+     */
+    /// This is the method that will be called on remote calls on the method getTimingInformation.
+    virtual void getTimingInformation(const std::shared_ptr<CommonAPI::ClientId> clientId, am_mainConnectionID_t mainConnectionID, am_timeSync_t& delay, am_Error_e& error) = 0;
+    /**
+     * Retrieves the list of MainNotifications for a sink. Does not return the
+     *  possible ones.
+     */
+    /// This is the method that will be called on remote calls on the method getListMainSinkNotificationConfigurations.
+    virtual void getListMainSinkNotificationConfigurations(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) = 0;
+    /**
+     * Retrieves the list of MainNotifications for a source. Does not return the
+     *  possible ones.
+     */
+    /// This is the method that will be called on remote calls on the method getListMainSourceNotificationConfigurations.
+    virtual void getListMainSourceNotificationConfigurations(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) = 0;
+    /**
+     * sets a MainNotificationConfiuration. This can be used to turn on an off
+     *  notifications an to change the mode of the configuration.
+    (at)return E_OK on
+     *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+     */
+    /// This is the method that will be called on remote calls on the method setMainSinkNotificationConfiguration.
+    virtual void setMainSinkNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_NotificationConfiguration_s mainNotificationConfiguration, am_Error_e& error) = 0;
+    /**
+     * sets a MainNotificationConfiuration. This can be used to turn on an off
+     *  notifications an to change the mode of the configuration.
+    (at)return E_OK on
+     *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+     */
+    /// This is the method that will be called on remote calls on the method setMainSourceNotificationConfiguration.
+    virtual void setMainSourceNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_NotificationConfiguration_s mainNotificationConfiguration, am_Error_e& error) = 0;
+    /**
+     * Callback that is called when the number of connections change
+     */
+    /// Sends a broadcast event for newMainConnection.
+    virtual void fireNewMainConnectionEvent(const am_MainConnectionType_s& mainConnection) = 0;
+    /**
+     * Callback that is called when the number of connections change
+     */
+    /// Sends a broadcast event for removedMainConnection.
+    virtual void fireRemovedMainConnectionEvent(const am_mainConnectionID_t& mainConnection) = 0;
+    /**
+     * Callback that is called when the number of sinks change
+     */
+    /// Sends a broadcast event for newSink.
+    virtual void fireNewSinkEvent(const am_SinkType_s& sink) = 0;
+    /**
+     * Callback that is called when the number of sinks change
+     */
+    /// Sends a broadcast event for removedSink.
+    virtual void fireRemovedSinkEvent(const am_sinkID_t& sinkID) = 0;
+    /**
+     * Callback that is called when the number of sources change
+     */
+    /// Sends a broadcast event for newSource.
+    virtual void fireNewSourceEvent(const am_SourceType_s& source) = 0;
+    /**
+     * Callback that is called when the number of sources change
+     */
+    /// Sends a broadcast event for removedSource.
+    virtual void fireRemovedSourceEvent(const am_sourceID_t& source) = 0;
+    /**
+     * this callback is fired if the number of sink classes changed
+     */
+    /// Sends a broadcast event for numberOfSinkClassesChanged.
+    virtual void fireNumberOfSinkClassesChangedEvent() = 0;
+    /**
+     * this callback is fired if the number of source classes changed
+     */
+    /// Sends a broadcast event for numberOfSourceClassesChanged.
+    virtual void fireNumberOfSourceClassesChangedEvent() = 0;
+    /**
+     * This callback is called when the ConnectionState of a connection changed.
+     */
+    /// Sends a broadcast event for mainConnectionStateChanged.
+    virtual void fireMainConnectionStateChangedEvent(const am_mainConnectionID_t& connectionID, const am_ConnectionState_e& connectionState) = 0;
+    /**
+     * this callback indicates that a sinkSoundProperty has changed.
+     */
+    /// Sends a broadcast event for mainSinkSoundPropertyChanged.
+    virtual void fireMainSinkSoundPropertyChangedEvent(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty) = 0;
+    /**
+     * this callback indicates that a sourceSoundProperty has changed.
+     */
+    /// Sends a broadcast event for mainSourceSoundPropertyChanged.
+    virtual void fireMainSourceSoundPropertyChangedEvent(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty) = 0;
+    /**
+     * this callback is called when the availability of a sink has changed
+     */
+    /// Sends a broadcast event for sinkAvailabilityChanged.
+    virtual void fireSinkAvailabilityChangedEvent(const am_sinkID_t& sinkID, const am_Availability_s& availability) = 0;
+    /**
+     * this callback is called when the availability of source has changed.
+     */
+    /// Sends a broadcast event for sourceAvailabilityChanged.
+    virtual void fireSourceAvailabilityChangedEvent(const am_sourceID_t& sourceID, const am_Availability_s& availability) = 0;
+    /**
+     * this callback indicates a volume change on the indicated sink
+     */
+    /// Sends a broadcast event for volumeChanged.
+    virtual void fireVolumeChangedEvent(const am_sinkID_t& sinkID, const am_mainVolume_t& volume) = 0;
+    /**
+     * this callback indicates a mute state change on a sink.
+     */
+    /// Sends a broadcast event for sinkMuteStateChanged.
+    virtual void fireSinkMuteStateChangedEvent(const am_sinkID_t& sinkID, const am_MuteState_e& muteState) = 0;
+    /**
+     * is fired if a systemProperty changed
+     */
+    /// Sends a broadcast event for systemPropertyChanged.
+    virtual void fireSystemPropertyChangedEvent(const am_SystemProperty_s& systemProperty) = 0;
+    /**
+     * This callback is fired if the timinginformation for a mainConnectionID changed
+     */
+    /// Sends a broadcast event for timingInformationChanged.
+    virtual void fireTimingInformationChangedEvent(const am_mainConnectionID_t& mainConnectionID, const am_timeSync_t& time) = 0;
+    /**
+     * This callback is called when a sink is updated.
+     */
+    /// Sends a broadcast event for sinkUpdated.
+    virtual void fireSinkUpdatedEvent(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_MainSoundProperty_L& listMainSoundProperties) = 0;
+    /**
+     * This callback is called when a source is updated.
+     */
+    /// Sends a broadcast event for sourceUpdated.
+    virtual void fireSourceUpdatedEvent(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_MainSoundProperty_L& listMainSoundProperties) = 0;
+    /**
+     * This callback is called when a notificated value of a sink changes.
+     */
+    /// Sends a broadcast event for sinkNotification.
+    virtual void fireSinkNotificationEvent(const am_sinkID_t& sinkID, const am_NotificationPayload_s& notification) = 0;
+    /**
+     * This callback is called when a notifcated value of a source changes.
+     */
+    /// Sends a broadcast event for sourceNotification.
+    virtual void fireSourceNotificationEvent(const am_sourceID_t& sourceID, const am_NotificationPayload_s& notification) = 0;
+    /**
+     * This callback is triggered when a mainNotificationConfiguration is changed.
+     */
+    /// Sends a broadcast event for mainSinkNotificationConfigurationChanged.
+    virtual void fireMainSinkNotificationConfigurationChangedEvent(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration) = 0;
+    /**
+     * This callback is triggered when a mainNotificationConfiguration is changed.
+     */
+    /// Sends a broadcast event for mainSourceNotificationConfigurationChanged.
+    virtual void fireMainSourceNotificationConfigurationChangedEvent(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration) = 0;
+
+    using CommonAPI::Stub<CommandControlStubAdapter, CommandControlStubRemoteEvent>::initStubAdapter;
+    typedef CommonAPI::Stub<CommandControlStubAdapter, CommandControlStubRemoteEvent>::StubAdapterType StubAdapterType;
+    typedef CommonAPI::Stub<CommandControlStubAdapter, CommandControlStubRemoteEvent>::RemoteEventHandlerType RemoteEventHandlerType;
+    typedef CommandControlStubRemoteEvent RemoteEventType;
+    typedef CommandControl StubInterface;
+};
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Command_Control_STUB_H_
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.cpp b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.cpp
new file mode 100644
index 0000000..cca1a5e
--- /dev/null
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.cpp
@@ -0,0 +1,456 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+#include <org/genivi/am/CommandControlStubDefault.h>
+
+namespace org {
+namespace genivi {
+namespace am {
+
+CommandControlStubDefault::CommandControlStubDefault():
+        remoteEventHandler_(this),
+        interfaceVersion_(CommandControl::getInterfaceVersion()) {
+}
+
+const CommonAPI::Version& CommandControlStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) {
+    return interfaceVersion_;
+}
+
+CommandControlStubRemoteEvent* CommandControlStubDefault::initStubAdapter(const std::shared_ptr<CommandControlStubAdapter>& stubAdapter) {
+    CommonAPI::Stub<CommandControlStubAdapter, CommandControlStubRemoteEvent>::stubAdapter_ = stubAdapter;
+    return &remoteEventHandler_;
+}
+
+
+/**
+ * connects a source to sink
+(at)return E_OK on success, E_NOT_POSSIBLE on
+ *  failure, E_ALREADY_EXISTS if the connection does already exists
+ */
+void CommandControlStubDefault::connect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_sinkID_t sinkID, am_mainConnectionID_t& mainConnectionID, am_Error_e& error) {
+    // Call old style methods in default 
+    connect(sourceID, sinkID, mainConnectionID, error);
+}
+void CommandControlStubDefault::connect(am_sourceID_t sourceID, am_sinkID_t sinkID, am_mainConnectionID_t& mainConnectionID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * disconnects a mainConnection
+(at)return E_OK on successes, E_NON_EXISTENT if
+ *  the connection does not exist, E_NOT_POSSIBLE on error.
+ */
+void CommandControlStubDefault::disconnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_mainConnectionID_t mainConnectionID, am_Error_e& error) {
+    // Call old style methods in default 
+    disconnect(mainConnectionID, error);
+}
+void CommandControlStubDefault::disconnect(am_mainConnectionID_t mainConnectionID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * sets the volume for a sink
+(at)return E_OK on success, E_UNKOWN on error,
+ *  E_OUT_OF_RANGE in case the value is out of range
+ */
+void CommandControlStubDefault::setVolume(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_mainVolume_t volume, am_Error_e& error) {
+    // Call old style methods in default 
+    setVolume(sinkID, volume, error);
+}
+void CommandControlStubDefault::setVolume(am_sinkID_t sinkID, am_mainVolume_t volume, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * This function is used to increment or decrement the current volume for a
+ *  sink.
+(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+ *  value is not in the given volume range.
+ */
+void CommandControlStubDefault::volumeStep(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, int16_t volStep, am_Error_e& error) {
+    // Call old style methods in default 
+    volumeStep(sinkID, volStep, error);
+}
+void CommandControlStubDefault::volumeStep(am_sinkID_t sinkID, int16_t volStep, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * sets the mute state of a sink
+(at)return E_OK on success, E_UNKNOWN on error.
+ *  If the mute state is already the desired one, the Daemon will return E_OK.
+ */
+void CommandControlStubDefault::setSinkMuteState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_MuteState_e muteState, am_Error_e& error) {
+    // Call old style methods in default 
+    setSinkMuteState(sinkID, muteState, error);
+}
+void CommandControlStubDefault::setSinkMuteState(am_sinkID_t sinkID, am_MuteState_e muteState, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * This method is used to set sound properties, e.g. Equalizer Values. Since the
+ *  capabilities of the system can differ, the exact key value pairs can be
+ *  extended in each product
+(at)return E_OK on success, E_OUT_OF_RANGE if value
+ *  exceeds range, E_UNKNOWN in case of an error
+ */
+void CommandControlStubDefault::setMainSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_MainSoundProperty_s soundProperty, am_Error_e& error) {
+    // Call old style methods in default 
+    setMainSinkSoundProperty(sinkID, soundProperty, error);
+}
+void CommandControlStubDefault::setMainSinkSoundProperty(am_sinkID_t sinkID, am_MainSoundProperty_s soundProperty, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * This method is used to set sound properties, e.g. Equalizer Values. Since the
+ *  capabilities of the system can differ, the exact key value pairs can be
+ *  extended in each product
+(at)return E_OK on success, E_OUT_OF_RANGE if value
+ *  exceeds range, E_UNKNOWN in case of an error
+ */
+void CommandControlStubDefault::setMainSourceSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_MainSoundProperty_s soundProperty, am_Error_e& error) {
+    // Call old style methods in default 
+    setMainSourceSoundProperty(sourceID, soundProperty, error);
+}
+void CommandControlStubDefault::setMainSourceSoundProperty(am_sourceID_t sourceID, am_MainSoundProperty_s soundProperty, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * is used to set a specific system property.
+(at)return E_OK on success,
+ *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+ */
+void CommandControlStubDefault::setSystemProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SystemProperty_s property, am_Error_e& error) {
+    // Call old style methods in default 
+    setSystemProperty(property, error);
+}
+void CommandControlStubDefault::setSystemProperty(am_SystemProperty_s property, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * returns the actual list of MainConnections
+(at)return E_OK on success,
+ *  E_DATABASE_ERROR on error
+ */
+void CommandControlStubDefault::getListMainConnections(const std::shared_ptr<CommonAPI::ClientId> clientId, am_MainConnection_L& listConnections, am_Error_e& error) {
+    // Call old style methods in default 
+    getListMainConnections(listConnections, error);
+}
+void CommandControlStubDefault::getListMainConnections(am_MainConnection_L& listConnections, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * returns the actual list of Sinks
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
+ */
+void CommandControlStubDefault::getListMainSinks(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SinkType_L& listMainSinks, am_Error_e& error) {
+    // Call old style methods in default 
+    getListMainSinks(listMainSinks, error);
+}
+void CommandControlStubDefault::getListMainSinks(am_SinkType_L& listMainSinks, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * returns the actual list of Sources
+(at)return E_OK on success, E_DATABASE_ERROR
+ *  on error
+ */
+void CommandControlStubDefault::getListMainSources(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SourceType_L& listMainSources, am_Error_e& error) {
+    // Call old style methods in default 
+    getListMainSources(listMainSources, error);
+}
+void CommandControlStubDefault::getListMainSources(am_SourceType_L& listMainSources, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * This is used to retrieve all source sound properties related to a source.
+ *  Returns a vector of the sound properties and values as pair
+(at)return E_OK on
+ *  success, E_DATABASE_ERROR on error
+ */
+void CommandControlStubDefault::getListMainSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) {
+    // Call old style methods in default 
+    getListMainSinkSoundProperties(sinkID, listSoundProperties, error);
+}
+void CommandControlStubDefault::getListMainSinkSoundProperties(am_sinkID_t sinkID, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * This is used to retrieve all source sound properties related to a
+ *  source.
+(at)return E_OK on success, E_DATABASE_ERROR on error
+ */
+void CommandControlStubDefault::getListMainSourceSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error) {
+    // Call old style methods in default 
+    getListMainSourceSoundProperties(sourceID, listSourceProperties, error);
+}
+void CommandControlStubDefault::getListMainSourceSoundProperties(am_sourceID_t sourceID, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * This is used to retrieve SourceClass Information of all source classes
+ *  
+(at)return E_OK on success, E_DATABASE_ERROR on error
+ */
+void CommandControlStubDefault::getListSourceClasses(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SourceClass_L& listSourceClasses, am_Error_e& error) {
+    // Call old style methods in default 
+    getListSourceClasses(listSourceClasses, error);
+}
+void CommandControlStubDefault::getListSourceClasses(am_SourceClass_L& listSourceClasses, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * This is used to retrieve SinkClass Information of all sink classes 
+(at)return
+ *  E_OK on success, E_DATABASE_ERROR on error
+ */
+void CommandControlStubDefault::getListSinkClasses(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SinkClass_L& listSinkClasses, am_Error_e& error) {
+    // Call old style methods in default 
+    getListSinkClasses(listSinkClasses, error);
+}
+void CommandControlStubDefault::getListSinkClasses(am_SinkClass_L& listSinkClasses, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * Retrieves a complete list of all systemProperties.
+(at)return E_OK on success,
+ *  E_DATABASE_ERROR on error
+ */
+void CommandControlStubDefault::getListSystemProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SystemProperty_L& listSystemProperties, am_Error_e& error) {
+    // Call old style methods in default 
+    getListSystemProperties(listSystemProperties, error);
+}
+void CommandControlStubDefault::getListSystemProperties(am_SystemProperty_L& listSystemProperties, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * returns the delay in ms that the audiopath for the given mainConnection
+ *  has
+(at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+ *  yet retrieved, E_DATABASE_ERROR on read error on the database
+ */
+void CommandControlStubDefault::getTimingInformation(const std::shared_ptr<CommonAPI::ClientId> clientId, am_mainConnectionID_t mainConnectionID, am_timeSync_t& delay, am_Error_e& error) {
+    // Call old style methods in default 
+    getTimingInformation(mainConnectionID, delay, error);
+}
+void CommandControlStubDefault::getTimingInformation(am_mainConnectionID_t mainConnectionID, am_timeSync_t& delay, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * Retrieves the list of MainNotifications for a sink. Does not return the
+ *  possible ones.
+ */
+void CommandControlStubDefault::getListMainSinkNotificationConfigurations(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) {
+    // Call old style methods in default 
+    getListMainSinkNotificationConfigurations(sinkID, listMainNotificationConfigurations, error);
+}
+void CommandControlStubDefault::getListMainSinkNotificationConfigurations(am_sinkID_t sinkID, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * Retrieves the list of MainNotifications for a source. Does not return the
+ *  possible ones.
+ */
+void CommandControlStubDefault::getListMainSourceNotificationConfigurations(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) {
+    // Call old style methods in default 
+    getListMainSourceNotificationConfigurations(sourceID, listMainNotificationConfigurations, error);
+}
+void CommandControlStubDefault::getListMainSourceNotificationConfigurations(am_sourceID_t sourceID, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * sets a MainNotificationConfiuration. This can be used to turn on an off
+ *  notifications an to change the mode of the configuration.
+(at)return E_OK on
+ *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+ */
+void CommandControlStubDefault::setMainSinkNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_NotificationConfiguration_s mainNotificationConfiguration, am_Error_e& error) {
+    // Call old style methods in default 
+    setMainSinkNotificationConfiguration(sinkID, mainNotificationConfiguration, error);
+}
+void CommandControlStubDefault::setMainSinkNotificationConfiguration(am_sinkID_t sinkID, am_NotificationConfiguration_s mainNotificationConfiguration, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * sets a MainNotificationConfiuration. This can be used to turn on an off
+ *  notifications an to change the mode of the configuration.
+(at)return E_OK on
+ *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+ */
+void CommandControlStubDefault::setMainSourceNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_NotificationConfiguration_s mainNotificationConfiguration, am_Error_e& error) {
+    // Call old style methods in default 
+    setMainSourceNotificationConfiguration(sourceID, mainNotificationConfiguration, error);
+}
+void CommandControlStubDefault::setMainSourceNotificationConfiguration(am_sourceID_t sourceID, am_NotificationConfiguration_s mainNotificationConfiguration, am_Error_e& error) {
+    // No operation in default
+}
+
+
+/**
+ * Callback that is called when the number of connections change
+ */
+void CommandControlStubDefault::fireNewMainConnectionEvent(const am_MainConnectionType_s& mainConnection) {
+    stubAdapter_->fireNewMainConnectionEvent(mainConnection);
+}
+/**
+ * Callback that is called when the number of connections change
+ */
+void CommandControlStubDefault::fireRemovedMainConnectionEvent(const am_mainConnectionID_t& mainConnection) {
+    stubAdapter_->fireRemovedMainConnectionEvent(mainConnection);
+}
+/**
+ * Callback that is called when the number of sinks change
+ */
+void CommandControlStubDefault::fireNewSinkEvent(const am_SinkType_s& sink) {
+    stubAdapter_->fireNewSinkEvent(sink);
+}
+/**
+ * Callback that is called when the number of sinks change
+ */
+void CommandControlStubDefault::fireRemovedSinkEvent(const am_sinkID_t& sinkID) {
+    stubAdapter_->fireRemovedSinkEvent(sinkID);
+}
+/**
+ * Callback that is called when the number of sources change
+ */
+void CommandControlStubDefault::fireNewSourceEvent(const am_SourceType_s& source) {
+    stubAdapter_->fireNewSourceEvent(source);
+}
+/**
+ * Callback that is called when the number of sources change
+ */
+void CommandControlStubDefault::fireRemovedSourceEvent(const am_sourceID_t& source) {
+    stubAdapter_->fireRemovedSourceEvent(source);
+}
+/**
+ * this callback is fired if the number of sink classes changed
+ */
+void CommandControlStubDefault::fireNumberOfSinkClassesChangedEvent() {
+    stubAdapter_->fireNumberOfSinkClassesChangedEvent();
+}
+/**
+ * this callback is fired if the number of source classes changed
+ */
+void CommandControlStubDefault::fireNumberOfSourceClassesChangedEvent() {
+    stubAdapter_->fireNumberOfSourceClassesChangedEvent();
+}
+/**
+ * This callback is called when the ConnectionState of a connection changed.
+ */
+void CommandControlStubDefault::fireMainConnectionStateChangedEvent(const am_mainConnectionID_t& connectionID, const am_ConnectionState_e& connectionState) {
+    stubAdapter_->fireMainConnectionStateChangedEvent(connectionID, connectionState);
+}
+/**
+ * this callback indicates that a sinkSoundProperty has changed.
+ */
+void CommandControlStubDefault::fireMainSinkSoundPropertyChangedEvent(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty) {
+    stubAdapter_->fireMainSinkSoundPropertyChangedEvent(sinkID, soundProperty);
+}
+/**
+ * this callback indicates that a sourceSoundProperty has changed.
+ */
+void CommandControlStubDefault::fireMainSourceSoundPropertyChangedEvent(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty) {
+    stubAdapter_->fireMainSourceSoundPropertyChangedEvent(sourceID, soundProperty);
+}
+/**
+ * this callback is called when the availability of a sink has changed
+ */
+void CommandControlStubDefault::fireSinkAvailabilityChangedEvent(const am_sinkID_t& sinkID, const am_Availability_s& availability) {
+    stubAdapter_->fireSinkAvailabilityChangedEvent(sinkID, availability);
+}
+/**
+ * this callback is called when the availability of source has changed.
+ */
+void CommandControlStubDefault::fireSourceAvailabilityChangedEvent(const am_sourceID_t& sourceID, const am_Availability_s& availability) {
+    stubAdapter_->fireSourceAvailabilityChangedEvent(sourceID, availability);
+}
+/**
+ * this callback indicates a volume change on the indicated sink
+ */
+void CommandControlStubDefault::fireVolumeChangedEvent(const am_sinkID_t& sinkID, const am_mainVolume_t& volume) {
+    stubAdapter_->fireVolumeChangedEvent(sinkID, volume);
+}
+/**
+ * this callback indicates a mute state change on a sink.
+ */
+void CommandControlStubDefault::fireSinkMuteStateChangedEvent(const am_sinkID_t& sinkID, const am_MuteState_e& muteState) {
+    stubAdapter_->fireSinkMuteStateChangedEvent(sinkID, muteState);
+}
+/**
+ * is fired if a systemProperty changed
+ */
+void CommandControlStubDefault::fireSystemPropertyChangedEvent(const am_SystemProperty_s& systemProperty) {
+    stubAdapter_->fireSystemPropertyChangedEvent(systemProperty);
+}
+/**
+ * This callback is fired if the timinginformation for a mainConnectionID changed
+ */
+void CommandControlStubDefault::fireTimingInformationChangedEvent(const am_mainConnectionID_t& mainConnectionID, const am_timeSync_t& time) {
+    stubAdapter_->fireTimingInformationChangedEvent(mainConnectionID, time);
+}
+/**
+ * This callback is called when a sink is updated.
+ */
+void CommandControlStubDefault::fireSinkUpdatedEvent(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_MainSoundProperty_L& listMainSoundProperties) {
+    stubAdapter_->fireSinkUpdatedEvent(sinkID, sinkClassID, listMainSoundProperties);
+}
+/**
+ * This callback is called when a source is updated.
+ */
+void CommandControlStubDefault::fireSourceUpdatedEvent(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_MainSoundProperty_L& listMainSoundProperties) {
+    stubAdapter_->fireSourceUpdatedEvent(sourceID, sourceClassID, listMainSoundProperties);
+}
+/**
+ * This callback is called when a notificated value of a sink changes.
+ */
+void CommandControlStubDefault::fireSinkNotificationEvent(const am_sinkID_t& sinkID, const am_NotificationPayload_s& notification) {
+    stubAdapter_->fireSinkNotificationEvent(sinkID, notification);
+}
+/**
+ * This callback is called when a notifcated value of a source changes.
+ */
+void CommandControlStubDefault::fireSourceNotificationEvent(const am_sourceID_t& sourceID, const am_NotificationPayload_s& notification) {
+    stubAdapter_->fireSourceNotificationEvent(sourceID, notification);
+}
+/**
+ * This callback is triggered when a mainNotificationConfiguration is changed.
+ */
+void CommandControlStubDefault::fireMainSinkNotificationConfigurationChangedEvent(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration) {
+    stubAdapter_->fireMainSinkNotificationConfigurationChangedEvent(sinkID, mainNotificationConfiguration);
+}
+/**
+ * This callback is triggered when a mainNotificationConfiguration is changed.
+ */
+void CommandControlStubDefault::fireMainSourceNotificationConfigurationChangedEvent(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration) {
+    stubAdapter_->fireMainSourceNotificationConfigurationChangedEvent(sourceID, mainNotificationConfiguration);
+}
+
+
+CommandControlStubDefault::RemoteEventHandler::RemoteEventHandler(CommandControlStubDefault* defaultStub):
+        defaultStub_(defaultStub) {
+}
+
+} // namespace am
+} // namespace genivi
+} // namespace org
diff --git a/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.h b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.h
new file mode 100644
index 0000000..a6d46f8
--- /dev/null
+++ b/PluginCommandInterfaceCAPI/src-gen/org/genivi/am/CommandControlStubDefault.h
@@ -0,0 +1,336 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * The interface towards the Controlling Instance (e.g HMI). It handles the
+ *  communication towards the HMI and other system components who need to interact
+ *  with the audiomanagement.
+There are two rules that have to be kept in mind
+ *  when implementing against this interface:
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Command_Control_STUB_DEFAULT_H_
+#define ORG_GENIVI_AM_Command_Control_STUB_DEFAULT_H_
+
+
+#include <org/genivi/am/CommandControlStub.h>
+#include <sstream>
+
+namespace org {
+namespace genivi {
+namespace am {
+
+/**
+ * Provides a default implementation for CommandControlStubRemoteEvent and
+ * CommandControlStub. Method callbacks have an empty implementation,
+ * remote set calls on attributes will always change the value of the attribute
+ * to the one received.
+ *
+ * Override this stub if you only want to provide a subset of the functionality
+ * that would be defined for this service, and/or if you do not need any non-default
+ * behaviour.
+ */
+class CommandControlStubDefault : public virtual CommandControlStub {
+public:
+    CommandControlStubDefault();
+
+    CommandControlStubRemoteEvent* initStubAdapter(const std::shared_ptr<CommandControlStubAdapter>& stubAdapter);
+
+    const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId);
+
+
+    /**
+     * connects a source to sink
+    (at)return E_OK on success, E_NOT_POSSIBLE on
+     *  failure, E_ALREADY_EXISTS if the connection does already exists
+     */
+    virtual void connect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_sinkID_t sinkID, am_mainConnectionID_t& mainConnectionID, am_Error_e& error);
+    virtual void connect(am_sourceID_t sourceID, am_sinkID_t sinkID, am_mainConnectionID_t& mainConnectionID, am_Error_e& error);
+
+    /**
+     * disconnects a mainConnection
+    (at)return E_OK on successes, E_NON_EXISTENT if
+     *  the connection does not exist, E_NOT_POSSIBLE on error.
+     */
+    virtual void disconnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_mainConnectionID_t mainConnectionID, am_Error_e& error);
+    virtual void disconnect(am_mainConnectionID_t mainConnectionID, am_Error_e& error);
+
+    /**
+     * sets the volume for a sink
+    (at)return E_OK on success, E_UNKOWN on error,
+     *  E_OUT_OF_RANGE in case the value is out of range
+     */
+    virtual void setVolume(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_mainVolume_t volume, am_Error_e& error);
+    virtual void setVolume(am_sinkID_t sinkID, am_mainVolume_t volume, am_Error_e& error);
+
+    /**
+     * This function is used to increment or decrement the current volume for a
+     *  sink.
+    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the
+     *  value is not in the given volume range.
+     */
+    virtual void volumeStep(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, int16_t volStep, am_Error_e& error);
+    virtual void volumeStep(am_sinkID_t sinkID, int16_t volStep, am_Error_e& error);
+
+    /**
+     * sets the mute state of a sink
+    (at)return E_OK on success, E_UNKNOWN on error.
+     *  If the mute state is already the desired one, the Daemon will return E_OK.
+     */
+    virtual void setSinkMuteState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_MuteState_e muteState, am_Error_e& error);
+    virtual void setSinkMuteState(am_sinkID_t sinkID, am_MuteState_e muteState, am_Error_e& error);
+
+    /**
+     * This method is used to set sound properties, e.g. Equalizer Values. Since the
+     *  capabilities of the system can differ, the exact key value pairs can be
+     *  extended in each product
+    (at)return E_OK on success, E_OUT_OF_RANGE if value
+     *  exceeds range, E_UNKNOWN in case of an error
+     */
+    virtual void setMainSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_MainSoundProperty_s soundProperty, am_Error_e& error);
+    virtual void setMainSinkSoundProperty(am_sinkID_t sinkID, am_MainSoundProperty_s soundProperty, am_Error_e& error);
+
+    /**
+     * This method is used to set sound properties, e.g. Equalizer Values. Since the
+     *  capabilities of the system can differ, the exact key value pairs can be
+     *  extended in each product
+    (at)return E_OK on success, E_OUT_OF_RANGE if value
+     *  exceeds range, E_UNKNOWN in case of an error
+     */
+    virtual void setMainSourceSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_MainSoundProperty_s soundProperty, am_Error_e& error);
+    virtual void setMainSourceSoundProperty(am_sourceID_t sourceID, am_MainSoundProperty_s soundProperty, am_Error_e& error);
+
+    /**
+     * is used to set a specific system property.
+    (at)return E_OK on success,
+     *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
+     */
+    virtual void setSystemProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SystemProperty_s property, am_Error_e& error);
+    virtual void setSystemProperty(am_SystemProperty_s property, am_Error_e& error);
+
+    /**
+     * returns the actual list of MainConnections
+    (at)return E_OK on success,
+     *  E_DATABASE_ERROR on error
+     */
+    virtual void getListMainConnections(const std::shared_ptr<CommonAPI::ClientId> clientId, am_MainConnection_L& listConnections, am_Error_e& error);
+    virtual void getListMainConnections(am_MainConnection_L& listConnections, am_Error_e& error);
+
+    /**
+     * returns the actual list of Sinks
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
+     */
+    virtual void getListMainSinks(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SinkType_L& listMainSinks, am_Error_e& error);
+    virtual void getListMainSinks(am_SinkType_L& listMainSinks, am_Error_e& error);
+
+    /**
+     * returns the actual list of Sources
+    (at)return E_OK on success, E_DATABASE_ERROR
+     *  on error
+     */
+    virtual void getListMainSources(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SourceType_L& listMainSources, am_Error_e& error);
+    virtual void getListMainSources(am_SourceType_L& listMainSources, am_Error_e& error);
+
+    /**
+     * This is used to retrieve all source sound properties related to a source.
+     *  Returns a vector of the sound properties and values as pair
+    (at)return E_OK on
+     *  success, E_DATABASE_ERROR on error
+     */
+    virtual void getListMainSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error);
+    virtual void getListMainSinkSoundProperties(am_sinkID_t sinkID, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error);
+
+    /**
+     * This is used to retrieve all source sound properties related to a
+     *  source.
+    (at)return E_OK on success, E_DATABASE_ERROR on error
+     */
+    virtual void getListMainSourceSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error);
+    virtual void getListMainSourceSoundProperties(am_sourceID_t sourceID, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error);
+
+    /**
+     * This is used to retrieve SourceClass Information of all source classes
+     *  
+    (at)return E_OK on success, E_DATABASE_ERROR on error
+     */
+    virtual void getListSourceClasses(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SourceClass_L& listSourceClasses, am_Error_e& error);
+    virtual void getListSourceClasses(am_SourceClass_L& listSourceClasses, am_Error_e& error);
+
+    /**
+     * This is used to retrieve SinkClass Information of all sink classes 
+    (at)return
+     *  E_OK on success, E_DATABASE_ERROR on error
+     */
+    virtual void getListSinkClasses(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SinkClass_L& listSinkClasses, am_Error_e& error);
+    virtual void getListSinkClasses(am_SinkClass_L& listSinkClasses, am_Error_e& error);
+
+    /**
+     * Retrieves a complete list of all systemProperties.
+    (at)return E_OK on success,
+     *  E_DATABASE_ERROR on error
+     */
+    virtual void getListSystemProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_SystemProperty_L& listSystemProperties, am_Error_e& error);
+    virtual void getListSystemProperties(am_SystemProperty_L& listSystemProperties, am_Error_e& error);
+
+    /**
+     * returns the delay in ms that the audiopath for the given mainConnection
+     *  has
+    (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
+     *  yet retrieved, E_DATABASE_ERROR on read error on the database
+     */
+    virtual void getTimingInformation(const std::shared_ptr<CommonAPI::ClientId> clientId, am_mainConnectionID_t mainConnectionID, am_timeSync_t& delay, am_Error_e& error);
+    virtual void getTimingInformation(am_mainConnectionID_t mainConnectionID, am_timeSync_t& delay, am_Error_e& error);
+
+    /**
+     * Retrieves the list of MainNotifications for a sink. Does not return the
+     *  possible ones.
+     */
+    virtual void getListMainSinkNotificationConfigurations(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error);
+    virtual void getListMainSinkNotificationConfigurations(am_sinkID_t sinkID, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error);
+
+    /**
+     * Retrieves the list of MainNotifications for a source. Does not return the
+     *  possible ones.
+     */
+    virtual void getListMainSourceNotificationConfigurations(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error);
+    virtual void getListMainSourceNotificationConfigurations(am_sourceID_t sourceID, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error);
+
+    /**
+     * sets a MainNotificationConfiuration. This can be used to turn on an off
+     *  notifications an to change the mode of the configuration.
+    (at)return E_OK on
+     *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
+     */
+    virtual void setMainSinkNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_NotificationConfiguration_s mainNotificationConfiguration, am_Error_e& error);
+    virtual void setMainSinkNotificationConfiguration(am_sinkID_t sinkID, am_NotificationConfiguration_s mainNotificationConfiguration, am_Error_e& error);
+
+    /**
+     * sets a MainNotificationConfiuration. This can be used to turn on an off
+     *  notifications an to change the mode of the configuration.
+    (at)return E_OK on
+     *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
+     */
+    virtual void setMainSourceNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_NotificationConfiguration_s mainNotificationConfiguration, am_Error_e& error);
+    virtual void setMainSourceNotificationConfiguration(am_sourceID_t sourceID, am_NotificationConfiguration_s mainNotificationConfiguration, am_Error_e& error);
+
+
+    /**
+     * Callback that is called when the number of connections change
+     */
+    virtual void fireNewMainConnectionEvent(const am_MainConnectionType_s& mainConnection);
+    /**
+     * Callback that is called when the number of connections change
+     */
+    virtual void fireRemovedMainConnectionEvent(const am_mainConnectionID_t& mainConnection);
+    /**
+     * Callback that is called when the number of sinks change
+     */
+    virtual void fireNewSinkEvent(const am_SinkType_s& sink);
+    /**
+     * Callback that is called when the number of sinks change
+     */
+    virtual void fireRemovedSinkEvent(const am_sinkID_t& sinkID);
+    /**
+     * Callback that is called when the number of sources change
+     */
+    virtual void fireNewSourceEvent(const am_SourceType_s& source);
+    /**
+     * Callback that is called when the number of sources change
+     */
+    virtual void fireRemovedSourceEvent(const am_sourceID_t& source);
+    /**
+     * this callback is fired if the number of sink classes changed
+     */
+    virtual void fireNumberOfSinkClassesChangedEvent();
+    /**
+     * this callback is fired if the number of source classes changed
+     */
+    virtual void fireNumberOfSourceClassesChangedEvent();
+    /**
+     * This callback is called when the ConnectionState of a connection changed.
+     */
+    virtual void fireMainConnectionStateChangedEvent(const am_mainConnectionID_t& connectionID, const am_ConnectionState_e& connectionState);
+    /**
+     * this callback indicates that a sinkSoundProperty has changed.
+     */
+    virtual void fireMainSinkSoundPropertyChangedEvent(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty);
+    /**
+     * this callback indicates that a sourceSoundProperty has changed.
+     */
+    virtual void fireMainSourceSoundPropertyChangedEvent(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty);
+    /**
+     * this callback is called when the availability of a sink has changed
+     */
+    virtual void fireSinkAvailabilityChangedEvent(const am_sinkID_t& sinkID, const am_Availability_s& availability);
+    /**
+     * this callback is called when the availability of source has changed.
+     */
+    virtual void fireSourceAvailabilityChangedEvent(const am_sourceID_t& sourceID, const am_Availability_s& availability);
+    /**
+     * this callback indicates a volume change on the indicated sink
+     */
+    virtual void fireVolumeChangedEvent(const am_sinkID_t& sinkID, const am_mainVolume_t& volume);
+    /**
+     * this callback indicates a mute state change on a sink.
+     */
+    virtual void fireSinkMuteStateChangedEvent(const am_sinkID_t& sinkID, const am_MuteState_e& muteState);
+    /**
+     * is fired if a systemProperty changed
+     */
+    virtual void fireSystemPropertyChangedEvent(const am_SystemProperty_s& systemProperty);
+    /**
+     * This callback is fired if the timinginformation for a mainConnectionID changed
+     */
+    virtual void fireTimingInformationChangedEvent(const am_mainConnectionID_t& mainConnectionID, const am_timeSync_t& time);
+    /**
+     * This callback is called when a sink is updated.
+     */
+    virtual void fireSinkUpdatedEvent(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_MainSoundProperty_L& listMainSoundProperties);
+    /**
+     * This callback is called when a source is updated.
+     */
+    virtual void fireSourceUpdatedEvent(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_MainSoundProperty_L& listMainSoundProperties);
+    /**
+     * This callback is called when a notificated value of a sink changes.
+     */
+    virtual void fireSinkNotificationEvent(const am_sinkID_t& sinkID, const am_NotificationPayload_s& notification);
+    /**
+     * This callback is called when a notifcated value of a source changes.
+     */
+    virtual void fireSourceNotificationEvent(const am_sourceID_t& sourceID, const am_NotificationPayload_s& notification);
+    /**
+     * This callback is triggered when a mainNotificationConfiguration is changed.
+     */
+    virtual void fireMainSinkNotificationConfigurationChangedEvent(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration);
+    /**
+     * This callback is triggered when a mainNotificationConfiguration is changed.
+     */
+    virtual void fireMainSourceNotificationConfigurationChangedEvent(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration);
+
+
+protected:
+    class RemoteEventHandler: public virtual CommandControlStubRemoteEvent {
+     public:
+        RemoteEventHandler(CommandControlStubDefault* defaultStub);
+
+
+     private:
+        CommandControlStubDefault* defaultStub_;
+    };
+private:
+    CommandControlStubDefault::RemoteEventHandler remoteEventHandler_;
+
+
+    CommonAPI::Version interfaceVersion_;
+};
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Command_Control_STUB_DEFAULT_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.cpp
new file mode 100644
index 0000000..8092420
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.cpp
@@ -0,0 +1,1043 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#include "am.h"
+
+
+namespace org {
+namespace genivi {
+namespace am {
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+am_Route_s::am_Route_s(const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_RoutingElement_L& routeValue):
+        sourceID(sourceIDValue),
+        sinkID(sinkIDValue),
+        route(routeValue)
+{
+}
+
+
+bool operator==(const am_Route_s& lhs, const am_Route_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceID == rhs.sourceID &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.route == rhs.route
+    ;
+}
+
+void am_Route_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceID;
+    inputStream >> sinkID;
+    inputStream >> route;
+}
+
+void am_Route_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceID;
+    outputStream << sinkID;
+    outputStream << route;
+}
+
+am_Availability_s::am_Availability_s(const am_Availability_e& availabilityValue, const am_CustomAvailabilityReason_t& availabilityReasonValue):
+        availability(availabilityValue),
+        availabilityReason(availabilityReasonValue)
+{
+}
+
+
+bool operator==(const am_Availability_s& lhs, const am_Availability_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.availability == rhs.availability &&
+        lhs.availabilityReason == rhs.availabilityReason
+    ;
+}
+
+void am_Availability_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> availability;
+    inputStream >> availabilityReason;
+}
+
+void am_Availability_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << availability;
+    outputStream << availabilityReason;
+}
+
+am_ClassProperty_s::am_ClassProperty_s(const am_CustomClassProperty_t& classPropertyValue, const int16_t& valueValue):
+        classProperty(classPropertyValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.classProperty == rhs.classProperty &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_ClassProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> classProperty;
+    inputStream >> value;
+}
+
+void am_ClassProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << classProperty;
+    outputStream << value;
+}
+
+am_Crossfader_s::am_Crossfader_s(const am_crossfaderID_t& crossfaderIDValue, const std::string& nameValue, const am_sinkID_t& sinkID_AValue, const am_sinkID_t& sinkID_BValue, const am_sourceID_t& sourceIDValue, const am_HotSink_e& hotSinkValue):
+        crossfaderID(crossfaderIDValue),
+        name(nameValue),
+        sinkID_A(sinkID_AValue),
+        sinkID_B(sinkID_BValue),
+        sourceID(sourceIDValue),
+        hotSink(hotSinkValue)
+{
+}
+
+
+bool operator==(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.crossfaderID == rhs.crossfaderID &&
+        lhs.name == rhs.name &&
+        lhs.sinkID_A == rhs.sinkID_A &&
+        lhs.sinkID_B == rhs.sinkID_B &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.hotSink == rhs.hotSink
+    ;
+}
+
+void am_Crossfader_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> crossfaderID;
+    inputStream >> name;
+    inputStream >> sinkID_A;
+    inputStream >> sinkID_B;
+    inputStream >> sourceID;
+    inputStream >> hotSink;
+}
+
+void am_Crossfader_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << crossfaderID;
+    outputStream << name;
+    outputStream << sinkID_A;
+    outputStream << sinkID_B;
+    outputStream << sourceID;
+    outputStream << hotSink;
+}
+
+am_Gateway_s::am_Gateway_s(const am_gatewayID_t& gatewayIDValue, const std::string& nameValue, const am_sinkID_t& sinkIDValue, const am_sourceID_t& sourceIDValue, const am_domainID_t& domainSinkIDValue, const am_domainID_t& domainSourceIDValue, const am_domainID_t& controlDomainIDValue, const am_ConnectionFormat_L& listSourceFormatsValue, const am_ConnectionFormat_L& listSinkFormatsValue, const am_Convertion_L& convertionMatrixValue):
+        gatewayID(gatewayIDValue),
+        name(nameValue),
+        sinkID(sinkIDValue),
+        sourceID(sourceIDValue),
+        domainSinkID(domainSinkIDValue),
+        domainSourceID(domainSourceIDValue),
+        controlDomainID(controlDomainIDValue),
+        listSourceFormats(listSourceFormatsValue),
+        listSinkFormats(listSinkFormatsValue),
+        convertionMatrix(convertionMatrixValue)
+{
+}
+
+
+bool operator==(const am_Gateway_s& lhs, const am_Gateway_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.gatewayID == rhs.gatewayID &&
+        lhs.name == rhs.name &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.domainSinkID == rhs.domainSinkID &&
+        lhs.domainSourceID == rhs.domainSourceID &&
+        lhs.controlDomainID == rhs.controlDomainID &&
+        lhs.listSourceFormats == rhs.listSourceFormats &&
+        lhs.listSinkFormats == rhs.listSinkFormats &&
+        lhs.convertionMatrix == rhs.convertionMatrix
+    ;
+}
+
+void am_Gateway_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> gatewayID;
+    inputStream >> name;
+    inputStream >> sinkID;
+    inputStream >> sourceID;
+    inputStream >> domainSinkID;
+    inputStream >> domainSourceID;
+    inputStream >> controlDomainID;
+    inputStream >> listSourceFormats;
+    inputStream >> listSinkFormats;
+    inputStream >> convertionMatrix;
+}
+
+void am_Gateway_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << gatewayID;
+    outputStream << name;
+    outputStream << sinkID;
+    outputStream << sourceID;
+    outputStream << domainSinkID;
+    outputStream << domainSourceID;
+    outputStream << controlDomainID;
+    outputStream << listSourceFormats;
+    outputStream << listSinkFormats;
+    outputStream << convertionMatrix;
+}
+
+am_Converter_s::am_Converter_s(const am_converterID_t& converterIDValue, const std::string& nameValue, const am_sinkID_t& sinkIDValue, const am_sourceID_t& sourceIDValue, const am_domainID_t& domainIDValue, const am_ConnectionFormat_L& listSourceFormatsValue, const am_ConnectionFormat_L& listSinkFormatsValue, const am_Convertion_L& convertionMatrixValue):
+        converterID(converterIDValue),
+        name(nameValue),
+        sinkID(sinkIDValue),
+        sourceID(sourceIDValue),
+        domainID(domainIDValue),
+        listSourceFormats(listSourceFormatsValue),
+        listSinkFormats(listSinkFormatsValue),
+        convertionMatrix(convertionMatrixValue)
+{
+}
+
+
+bool operator==(const am_Converter_s& lhs, const am_Converter_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.converterID == rhs.converterID &&
+        lhs.name == rhs.name &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.domainID == rhs.domainID &&
+        lhs.listSourceFormats == rhs.listSourceFormats &&
+        lhs.listSinkFormats == rhs.listSinkFormats &&
+        lhs.convertionMatrix == rhs.convertionMatrix
+    ;
+}
+
+void am_Converter_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> converterID;
+    inputStream >> name;
+    inputStream >> sinkID;
+    inputStream >> sourceID;
+    inputStream >> domainID;
+    inputStream >> listSourceFormats;
+    inputStream >> listSinkFormats;
+    inputStream >> convertionMatrix;
+}
+
+void am_Converter_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << converterID;
+    outputStream << name;
+    outputStream << sinkID;
+    outputStream << sourceID;
+    outputStream << domainID;
+    outputStream << listSourceFormats;
+    outputStream << listSinkFormats;
+    outputStream << convertionMatrix;
+}
+
+am_RoutingElement_s::am_RoutingElement_s(const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_domainID_t& domainIDValue, const am_CustomConnectionFormat_t& connectionFormatValue):
+        sourceID(sourceIDValue),
+        sinkID(sinkIDValue),
+        domainID(domainIDValue),
+        connectionFormat(connectionFormatValue)
+{
+}
+
+
+bool operator==(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceID == rhs.sourceID &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.domainID == rhs.domainID &&
+        lhs.connectionFormat == rhs.connectionFormat
+    ;
+}
+
+void am_RoutingElement_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceID;
+    inputStream >> sinkID;
+    inputStream >> domainID;
+    inputStream >> connectionFormat;
+}
+
+void am_RoutingElement_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceID;
+    outputStream << sinkID;
+    outputStream << domainID;
+    outputStream << connectionFormat;
+}
+
+am_SoundProperty_s::am_SoundProperty_s(const am_CustomSoundPropertyType_t& typeValue, const int16_t& valueValue):
+        type(typeValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_SoundProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> value;
+}
+
+void am_SoundProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << value;
+}
+
+am_SystemProperty_s::am_SystemProperty_s(const am_CustomSystemPropertyType_t& typeValue, const int16_t& valueValue):
+        type(typeValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_SystemProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> value;
+}
+
+void am_SystemProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << value;
+}
+
+am_SinkClass_s::am_SinkClass_s(const am_sinkClass_t& sinkClassIDValue, const std::string& nameValue, const am_ClassProperty_L& listClassPropertiesValue):
+        sinkClassID(sinkClassIDValue),
+        name(nameValue),
+        listClassProperties(listClassPropertiesValue)
+{
+}
+
+
+bool operator==(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sinkClassID == rhs.sinkClassID &&
+        lhs.name == rhs.name &&
+        lhs.listClassProperties == rhs.listClassProperties
+    ;
+}
+
+void am_SinkClass_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sinkClassID;
+    inputStream >> name;
+    inputStream >> listClassProperties;
+}
+
+void am_SinkClass_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sinkClassID;
+    outputStream << name;
+    outputStream << listClassProperties;
+}
+
+am_SourceClass_s::am_SourceClass_s(const am_sourceClass_t& sourceClassIDValue, const std::string& nameValue, const am_ClassProperty_L& listClassPropertiesValue):
+        sourceClassID(sourceClassIDValue),
+        name(nameValue),
+        listClassProperties(listClassPropertiesValue)
+{
+}
+
+
+bool operator==(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceClassID == rhs.sourceClassID &&
+        lhs.name == rhs.name &&
+        lhs.listClassProperties == rhs.listClassProperties
+    ;
+}
+
+void am_SourceClass_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceClassID;
+    inputStream >> name;
+    inputStream >> listClassProperties;
+}
+
+void am_SourceClass_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceClassID;
+    outputStream << name;
+    outputStream << listClassProperties;
+}
+
+am_SourceType_s::am_SourceType_s(const am_sourceID_t& sourceIDValue, const std::string& nameValue, const am_Availability_s& availabilityValue, const am_sourceClass_t& sourceClassIDValue):
+        sourceID(sourceIDValue),
+        name(nameValue),
+        availability(availabilityValue),
+        sourceClassID(sourceClassIDValue)
+{
+}
+
+
+bool operator==(const am_SourceType_s& lhs, const am_SourceType_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceID == rhs.sourceID &&
+        lhs.name == rhs.name &&
+        lhs.availability == rhs.availability &&
+        lhs.sourceClassID == rhs.sourceClassID
+    ;
+}
+
+void am_SourceType_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceID;
+    inputStream >> name;
+    inputStream >> availability;
+    inputStream >> sourceClassID;
+}
+
+void am_SourceType_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceID;
+    outputStream << name;
+    outputStream << availability;
+    outputStream << sourceClassID;
+}
+
+am_SinkType_s::am_SinkType_s(const am_sinkID_t& sinkIDValue, const std::string& nameValue, const am_Availability_s& availabilityValue, const am_mainVolume_t& volumeValue, const am_MuteState_e& muteStateValue, const am_sinkClass_t& sinkClassIDValue):
+        sinkID(sinkIDValue),
+        name(nameValue),
+        availability(availabilityValue),
+        volume(volumeValue),
+        muteState(muteStateValue),
+        sinkClassID(sinkClassIDValue)
+{
+}
+
+
+bool operator==(const am_SinkType_s& lhs, const am_SinkType_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sinkID == rhs.sinkID &&
+        lhs.name == rhs.name &&
+        lhs.availability == rhs.availability &&
+        lhs.volume == rhs.volume &&
+        lhs.muteState == rhs.muteState &&
+        lhs.sinkClassID == rhs.sinkClassID
+    ;
+}
+
+void am_SinkType_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sinkID;
+    inputStream >> name;
+    inputStream >> availability;
+    inputStream >> volume;
+    inputStream >> muteState;
+    inputStream >> sinkClassID;
+}
+
+void am_SinkType_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sinkID;
+    outputStream << name;
+    outputStream << availability;
+    outputStream << volume;
+    outputStream << muteState;
+    outputStream << sinkClassID;
+}
+
+am_Handle_s::am_Handle_s(const am_Handle_e& handleTypeValue, const uint16_t& handleValue):
+        handleType(handleTypeValue),
+        handle(handleValue)
+{
+}
+
+
+bool operator==(const am_Handle_s& lhs, const am_Handle_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.handleType == rhs.handleType &&
+        lhs.handle == rhs.handle
+    ;
+}
+
+void am_Handle_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> handleType;
+    inputStream >> handle;
+}
+
+void am_Handle_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << handleType;
+    outputStream << handle;
+}
+
+am_MainSoundProperty_s::am_MainSoundProperty_s(const am_CustomMainSoundPropertyType_t& typeValue, const int16_t& valueValue):
+        type(typeValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_MainSoundProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> value;
+}
+
+void am_MainSoundProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << value;
+}
+
+am_MainConnectionType_s::am_MainConnectionType_s(const am_mainConnectionID_t& mainConnectionIDValue, const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_timeSync_t& delayValue, const am_ConnectionState_e& connectionStateValue):
+        mainConnectionID(mainConnectionIDValue),
+        sourceID(sourceIDValue),
+        sinkID(sinkIDValue),
+        delay(delayValue),
+        connectionState(connectionStateValue)
+{
+}
+
+
+bool operator==(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.mainConnectionID == rhs.mainConnectionID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.delay == rhs.delay &&
+        lhs.connectionState == rhs.connectionState
+    ;
+}
+
+void am_MainConnectionType_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> mainConnectionID;
+    inputStream >> sourceID;
+    inputStream >> sinkID;
+    inputStream >> delay;
+    inputStream >> connectionState;
+}
+
+void am_MainConnectionType_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << mainConnectionID;
+    outputStream << sourceID;
+    outputStream << sinkID;
+    outputStream << delay;
+    outputStream << connectionState;
+}
+
+am_MainConnection_s::am_MainConnection_s(const am_mainConnectionID_t& mainConnectionIDValue, const am_ConnectionState_e& connectionStateValue, const am_sinkID_t& sinkIDValue, const am_sourceID_t& sourceIDValue, const am_timeSync_t& delayValue, const am_ConnectionID_L& listConnectionIDValue):
+        mainConnectionID(mainConnectionIDValue),
+        connectionState(connectionStateValue),
+        sinkID(sinkIDValue),
+        sourceID(sourceIDValue),
+        delay(delayValue),
+        listConnectionID(listConnectionIDValue)
+{
+}
+
+
+bool operator==(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.mainConnectionID == rhs.mainConnectionID &&
+        lhs.connectionState == rhs.connectionState &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.delay == rhs.delay &&
+        lhs.listConnectionID == rhs.listConnectionID
+    ;
+}
+
+void am_MainConnection_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> mainConnectionID;
+    inputStream >> connectionState;
+    inputStream >> sinkID;
+    inputStream >> sourceID;
+    inputStream >> delay;
+    inputStream >> listConnectionID;
+}
+
+void am_MainConnection_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << mainConnectionID;
+    outputStream << connectionState;
+    outputStream << sinkID;
+    outputStream << sourceID;
+    outputStream << delay;
+    outputStream << listConnectionID;
+}
+
+am_NotificationPayload_s::am_NotificationPayload_s(const am_CustomNotificationType_t& typeValue, const int16_t& valueValue):
+        type(typeValue),
+        value(valueValue)
+{
+}
+
+
+bool operator==(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.value == rhs.value
+    ;
+}
+
+void am_NotificationPayload_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> value;
+}
+
+void am_NotificationPayload_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << value;
+}
+
+am_NotificationConfiguration_s::am_NotificationConfiguration_s(const am_CustomNotificationType_t& typeValue, const am_NotificationStatus_e& statusValue, const int16_t& parameterValue):
+        type(typeValue),
+        status(statusValue),
+        parameter(parameterValue)
+{
+}
+
+
+bool operator==(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.status == rhs.status &&
+        lhs.parameter == rhs.parameter
+    ;
+}
+
+void am_NotificationConfiguration_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> status;
+    inputStream >> parameter;
+}
+
+void am_NotificationConfiguration_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << status;
+    outputStream << parameter;
+}
+
+am_Sink_s::am_Sink_s(const am_sinkID_t& sinkIDValue, const std::string& nameValue, const am_domainID_t& domainIDValue, const am_sinkClass_t& sinkClassIDValue, const am_volume_t& volumeValue, const bool& visibleValue, const am_Availability_s& availableValue, const am_MuteState_e& muteStateValue, const am_mainVolume_t& mainVolumeValue, const am_SoundProperty_L& listSoundPropertiesValue, const am_ConnectionFormat_L& listConnectionFormatsValue, const am_MainSoundProperty_L& listMainSoundPropertiesValue, const am_NotificationConfiguration_L& listMainNotificationConfigurationsValue, const am_NotificationConfiguration_L& listNotificationConfigurationsValue):
+        sinkID(sinkIDValue),
+        name(nameValue),
+        domainID(domainIDValue),
+        sinkClassID(sinkClassIDValue),
+        volume(volumeValue),
+        visible(visibleValue),
+        available(availableValue),
+        muteState(muteStateValue),
+        mainVolume(mainVolumeValue),
+        listSoundProperties(listSoundPropertiesValue),
+        listConnectionFormats(listConnectionFormatsValue),
+        listMainSoundProperties(listMainSoundPropertiesValue),
+        listMainNotificationConfigurations(listMainNotificationConfigurationsValue),
+        listNotificationConfigurations(listNotificationConfigurationsValue)
+{
+}
+
+
+bool operator==(const am_Sink_s& lhs, const am_Sink_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sinkID == rhs.sinkID &&
+        lhs.name == rhs.name &&
+        lhs.domainID == rhs.domainID &&
+        lhs.sinkClassID == rhs.sinkClassID &&
+        lhs.volume == rhs.volume &&
+        lhs.visible == rhs.visible &&
+        lhs.available == rhs.available &&
+        lhs.muteState == rhs.muteState &&
+        lhs.mainVolume == rhs.mainVolume &&
+        lhs.listSoundProperties == rhs.listSoundProperties &&
+        lhs.listConnectionFormats == rhs.listConnectionFormats &&
+        lhs.listMainSoundProperties == rhs.listMainSoundProperties &&
+        lhs.listMainNotificationConfigurations == rhs.listMainNotificationConfigurations &&
+        lhs.listNotificationConfigurations == rhs.listNotificationConfigurations
+    ;
+}
+
+void am_Sink_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sinkID;
+    inputStream >> name;
+    inputStream >> domainID;
+    inputStream >> sinkClassID;
+    inputStream >> volume;
+    inputStream >> visible;
+    inputStream >> available;
+    inputStream >> muteState;
+    inputStream >> mainVolume;
+    inputStream >> listSoundProperties;
+    inputStream >> listConnectionFormats;
+    inputStream >> listMainSoundProperties;
+    inputStream >> listMainNotificationConfigurations;
+    inputStream >> listNotificationConfigurations;
+}
+
+void am_Sink_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sinkID;
+    outputStream << name;
+    outputStream << domainID;
+    outputStream << sinkClassID;
+    outputStream << volume;
+    outputStream << visible;
+    outputStream << available;
+    outputStream << muteState;
+    outputStream << mainVolume;
+    outputStream << listSoundProperties;
+    outputStream << listConnectionFormats;
+    outputStream << listMainSoundProperties;
+    outputStream << listMainNotificationConfigurations;
+    outputStream << listNotificationConfigurations;
+}
+
+am_Source_s::am_Source_s(const am_sourceID_t& sourceIDValue, const am_domainID_t& domainIDValue, const std::string& nameValue, const am_sourceClass_t& sourceClassIDValue, const am_SourceState_e& sourceStateValue, const am_volume_t& volumeValue, const bool& visibleValue, const am_Availability_s& availableValue, const am_InterruptState_e& interruptStateValue, const am_SoundProperty_L& listSoundPropertiesValue, const am_ConnectionFormat_L& listConnectionFormatsValue, const am_MainSoundProperty_L& listMainSoundPropertiesValue, const am_NotificationConfiguration_L& listMainNotificationConfigurationsValue, const am_NotificationConfiguration_L& listNotificationConfigurationsValue):
+        sourceID(sourceIDValue),
+        domainID(domainIDValue),
+        name(nameValue),
+        sourceClassID(sourceClassIDValue),
+        sourceState(sourceStateValue),
+        volume(volumeValue),
+        visible(visibleValue),
+        available(availableValue),
+        interruptState(interruptStateValue),
+        listSoundProperties(listSoundPropertiesValue),
+        listConnectionFormats(listConnectionFormatsValue),
+        listMainSoundProperties(listMainSoundPropertiesValue),
+        listMainNotificationConfigurations(listMainNotificationConfigurationsValue),
+        listNotificationConfigurations(listNotificationConfigurationsValue)
+{
+}
+
+
+bool operator==(const am_Source_s& lhs, const am_Source_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.sourceID == rhs.sourceID &&
+        lhs.domainID == rhs.domainID &&
+        lhs.name == rhs.name &&
+        lhs.sourceClassID == rhs.sourceClassID &&
+        lhs.sourceState == rhs.sourceState &&
+        lhs.volume == rhs.volume &&
+        lhs.visible == rhs.visible &&
+        lhs.available == rhs.available &&
+        lhs.interruptState == rhs.interruptState &&
+        lhs.listSoundProperties == rhs.listSoundProperties &&
+        lhs.listConnectionFormats == rhs.listConnectionFormats &&
+        lhs.listMainSoundProperties == rhs.listMainSoundProperties &&
+        lhs.listMainNotificationConfigurations == rhs.listMainNotificationConfigurations &&
+        lhs.listNotificationConfigurations == rhs.listNotificationConfigurations
+    ;
+}
+
+void am_Source_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> sourceID;
+    inputStream >> domainID;
+    inputStream >> name;
+    inputStream >> sourceClassID;
+    inputStream >> sourceState;
+    inputStream >> volume;
+    inputStream >> visible;
+    inputStream >> available;
+    inputStream >> interruptState;
+    inputStream >> listSoundProperties;
+    inputStream >> listConnectionFormats;
+    inputStream >> listMainSoundProperties;
+    inputStream >> listMainNotificationConfigurations;
+    inputStream >> listNotificationConfigurations;
+}
+
+void am_Source_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << sourceID;
+    outputStream << domainID;
+    outputStream << name;
+    outputStream << sourceClassID;
+    outputStream << sourceState;
+    outputStream << volume;
+    outputStream << visible;
+    outputStream << available;
+    outputStream << interruptState;
+    outputStream << listSoundProperties;
+    outputStream << listConnectionFormats;
+    outputStream << listMainSoundProperties;
+    outputStream << listMainNotificationConfigurations;
+    outputStream << listNotificationConfigurations;
+}
+
+am_Domain_s::am_Domain_s(const am_domainID_t& domainIDValue, const std::string& nameValue, const std::string& busnameValue, const std::string& nodenameValue, const bool& earlyValue, const bool& completeValue, const am_DomainState_e& stateValue):
+        domainID(domainIDValue),
+        name(nameValue),
+        busname(busnameValue),
+        nodename(nodenameValue),
+        early(earlyValue),
+        complete(completeValue),
+        state(stateValue)
+{
+}
+
+
+bool operator==(const am_Domain_s& lhs, const am_Domain_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.domainID == rhs.domainID &&
+        lhs.name == rhs.name &&
+        lhs.busname == rhs.busname &&
+        lhs.nodename == rhs.nodename &&
+        lhs.early == rhs.early &&
+        lhs.complete == rhs.complete &&
+        lhs.state == rhs.state
+    ;
+}
+
+void am_Domain_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> domainID;
+    inputStream >> name;
+    inputStream >> busname;
+    inputStream >> nodename;
+    inputStream >> early;
+    inputStream >> complete;
+    inputStream >> state;
+}
+
+void am_Domain_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << domainID;
+    outputStream << name;
+    outputStream << busname;
+    outputStream << nodename;
+    outputStream << early;
+    outputStream << complete;
+    outputStream << state;
+}
+
+am_EarlyData_s::am_EarlyData_s(const am_EarlyDataType_e& typeValue, const am_DataType_u& sinksourceValue, const am_EarlyData_u& dataValue):
+        type(typeValue),
+        sinksource(sinksourceValue),
+        data(dataValue)
+{
+}
+
+
+bool operator==(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.type == rhs.type &&
+        lhs.sinksource == rhs.sinksource &&
+        lhs.data == rhs.data
+    ;
+}
+
+void am_EarlyData_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> type;
+    inputStream >> sinksource;
+    inputStream >> data;
+}
+
+void am_EarlyData_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << type;
+    outputStream << sinksource;
+    outputStream << data;
+}
+
+am_Connection_s::am_Connection_s(const am_connectionID_t& connectionIDValue, const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_timeSync_t& delayValue, const am_CustomConnectionFormat_t& connectionFormatValue):
+        connectionID(connectionIDValue),
+        sourceID(sourceIDValue),
+        sinkID(sinkIDValue),
+        delay(delayValue),
+        connectionFormat(connectionFormatValue)
+{
+}
+
+
+bool operator==(const am_Connection_s& lhs, const am_Connection_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.connectionID == rhs.connectionID &&
+        lhs.sourceID == rhs.sourceID &&
+        lhs.sinkID == rhs.sinkID &&
+        lhs.delay == rhs.delay &&
+        lhs.connectionFormat == rhs.connectionFormat
+    ;
+}
+
+void am_Connection_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> connectionID;
+    inputStream >> sourceID;
+    inputStream >> sinkID;
+    inputStream >> delay;
+    inputStream >> connectionFormat;
+}
+
+void am_Connection_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << connectionID;
+    outputStream << sourceID;
+    outputStream << sinkID;
+    outputStream << delay;
+    outputStream << connectionFormat;
+}
+
+am_Volumes_s::am_Volumes_s(const am_VolumeType_e& volumeTypeValue, const am_DataType_u& volumeIDValue, const am_volume_t& volumeValue, const am_CustomRampType_t& rampValue, const am_time_t& timeValue):
+        volumeType(volumeTypeValue),
+        volumeID(volumeIDValue),
+        volume(volumeValue),
+        ramp(rampValue),
+        time(timeValue)
+{
+}
+
+
+bool operator==(const am_Volumes_s& lhs, const am_Volumes_s& rhs) {
+    if (&lhs == &rhs)
+        return true;
+
+    return
+        lhs.volumeType == rhs.volumeType &&
+        lhs.volumeID == rhs.volumeID &&
+        lhs.volume == rhs.volume &&
+        lhs.ramp == rhs.ramp &&
+        lhs.time == rhs.time
+    ;
+}
+
+void am_Volumes_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
+    inputStream >> volumeType;
+    inputStream >> volumeID;
+    inputStream >> volume;
+    inputStream >> ramp;
+    inputStream >> time;
+}
+
+void am_Volumes_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
+    outputStream << volumeType;
+    outputStream << volumeID;
+    outputStream << volume;
+    outputStream << ramp;
+    outputStream << time;
+}
+
+
+
+} // namespace am
+} // namespace genivi
+} // namespace org
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.h
new file mode 100644
index 0000000..e75db5d
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am.h
@@ -0,0 +1,2551 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * @author Christian Linke
+ */
+#ifndef ORG_GENIVI_am_H_
+#define ORG_GENIVI_am_H_
+
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/InputStream.h>
+#include <CommonAPI/OutputStream.h>
+#include <CommonAPI/SerializableStruct.h>
+#include <CommonAPI/SerializableVariant.h>
+#include <CommonAPI/types.h>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <vector>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+
+namespace am {
+    /**
+     * a source ID
+     */
+    /**
+     * a source ID
+     */
+    typedef uint16_t am_sourceID_t;
+    /**
+     * a mainConnection ID
+     */
+    /**
+     * a mainConnection ID
+     */
+    typedef uint16_t am_mainConnectionID_t;
+    /**
+     * offset time that is introduced in milli seconds.
+     */
+    /**
+     * offset time that is introduced in milli seconds.
+     */
+    typedef int16_t am_timeSync_t;
+    /**
+     * a sink ID
+     */
+    /**
+     * a sink ID
+     */
+    typedef uint16_t am_sinkID_t;
+    /**
+     * represents the connection state
+     */
+    enum class am_ConnectionState_e: int32_t {
+        CS_UNKNOWN = 0,
+        /**
+         * This means the connection is just building up
+         */
+        CS_CONNECTING = 1,
+        /**
+         * the connection is ready to be used
+         */
+        CS_CONNECTED = 2,
+        /**
+         * the connection is in the course to be knocked down
+         */
+        CS_DISCONNECTING = 3,
+        /**
+         * only relevant for connectionStatechanged. Is send after the connection was
+         *  removed
+         */
+        CS_DISCONNECTED = 4,
+        /**
+         * this means the connection is still build up but unused at the moment
+         */
+        CS_SUSPENDED = 5,
+        CS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_ConnectionState_eComparator;
+    /**
+     * this type holds all information of connections relevant to the HMI
+     */
+    /**
+     * this type holds all information of connections relevant to the HMI
+     */
+    struct am_MainConnectionType_s: CommonAPI::SerializableStruct {
+        /**
+         * the ID of the mainconnection
+         */
+         am_mainConnectionID_t mainConnectionID;
+        /**
+         * the sourceID where the connection starts
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the sinkID where the connection ends
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the delay of the mainconnection
+         */
+         am_timeSync_t delay;
+        /**
+         * the current connection state
+         */
+         am_ConnectionState_e connectionState;
+    
+        am_MainConnectionType_s() = default;
+        am_MainConnectionType_s(const am_mainConnectionID_t& mainConnectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_timeSync_t& delay, const am_ConnectionState_e& connectionState);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeInt32Type();
+        }
+    };
+    typedef std::vector<am_MainConnectionType_s> am_MainConnection_L;
+    /**
+     * product specific identifier of property
+     */
+    /**
+     * product specific identifier of property
+     */
+    typedef uint16_t am_CustomClassProperty_t;
+    /**
+     * describes class properties
+     */
+    /**
+     * describes class properties
+     */
+    struct am_ClassProperty_s: CommonAPI::SerializableStruct {
+        /**
+         * the property as enum
+         */
+         am_CustomClassProperty_t classProperty;
+        /**
+         * the value of the property
+         */
+         int16_t value;
+    
+        am_ClassProperty_s() = default;
+        am_ClassProperty_s(const am_CustomClassProperty_t& classProperty, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_ClassProperty_s> am_ClassProperty_L;
+    typedef uint16_t am_sinkClass_t;
+    /**
+     * struct describing sinkclasses
+     */
+    /**
+     * struct describing sinkclasses
+     */
+    struct am_SinkClass_s: CommonAPI::SerializableStruct {
+        /**
+         * the ID of the sinkClass
+         */
+         am_sinkClass_t sinkClassID;
+        /**
+         * the name of the sinkClass - must be unique in the system
+         */
+         std::string name;
+        /**
+         * the list of the class properties. These are pairs of  a project specific enum
+         *  describing the type of the value and an integer holding the real value.
+         */
+         am_ClassProperty_L listClassProperties;
+    
+        am_SinkClass_s() = default;
+        am_SinkClass_s(const am_sinkClass_t& sinkClassID, const std::string& name, const am_ClassProperty_L& listClassProperties);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    typedef std::vector<am_SinkClass_s> am_SinkClass_L;
+    /**
+     * This is the volume presented on the command interface. It is in the duty of the
+     *  Controller to change the volumes given here into meaningful values on the
+     *  routing interface.
+    The range of this type is customer specific.
+     */
+    /**
+     * This is the volume presented on the command interface. It is in the duty of the
+     *  Controller to change the volumes given here into meaningful values on the
+     *  routing interface.
+    The range of this type is customer specific.
+     */
+    typedef int16_t am_mainVolume_t;
+    /**
+     * This  project specific value gives the information about reason for reason for
+     *  Source/Sink change
+     */
+    /**
+     * This  project specific value gives the information about reason for reason for
+     *  Source/Sink change
+     */
+    typedef uint16_t am_CustomAvailabilityReason_t;
+    /**
+     * with the help of this enum, sinks and sources can report their availability
+     *  state
+     */
+    enum class am_Availability_e: int32_t {
+        /**
+         * default
+         */
+        A_UNKNOWN = 0,
+        /**
+         * The source / sink is available
+         */
+        A_AVAILABLE = 1,
+        /**
+         * the source / sink is not available
+         */
+        A_UNAVAILABLE = 2,
+        A_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_Availability_eComparator;
+    enum class am_MuteState_e: int32_t {
+        /**
+         * default
+         */
+        MS_UNKNOWN = 0,
+        /**
+         * the source / sink is muted
+         */
+        MS_MUTED = 1,
+        /**
+         * the source / sink is unmuted
+         */
+        MS_UNMUTED = 2,
+        MS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_MuteState_eComparator;
+    /**
+     * this describes the availability of a sink or a source together with the latest
+     *  change
+     */
+    /**
+     * this describes the availability of a sink or a source together with the latest
+     *  change
+     */
+    struct am_Availability_s: CommonAPI::SerializableStruct {
+        /**
+         * the current availability state
+         */
+         am_Availability_e availability;
+        /**
+         * the reason for the last change. This can be used to trigger events that deal
+         *  with state changes.
+         */
+         am_CustomAvailabilityReason_t availabilityReason;
+    
+        am_Availability_s() = default;
+        am_Availability_s(const am_Availability_e& availability, const am_CustomAvailabilityReason_t& availabilityReason);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    /**
+     * this type holds all information of sinks relevant to the HMI
+     */
+    /**
+     * this type holds all information of sinks relevant to the HMI
+     */
+    struct am_SinkType_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the sink, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_sinkID_t sinkID;
+        /**
+         * The name of the sink. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * This attribute reflects the availability of the sink. There are several reasons
+         *  why a sink could be not available for the moment: for example the shutdown of
+         *  a sink because of overtemperature or over- &amp; undervoltage. The
+         *  availability consists of two pieces of information:
+        
+            Availablility: the
+         *  status itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
+           
+         *  AvailabilityReason: this informs about the last reason for a change in
+         *  availability. The reasons itself are product specific.
+         */
+         am_Availability_s availability;
+        /**
+         * This is the representation of the Volume for the commandInterface. It is used
+         *  by the HMI to set the volume of a sink, the AudioManagerController has to
+         *  transform this into real source and sink volumes.
+         */
+         am_mainVolume_t volume;
+         am_MuteState_e muteState;
+        /**
+         * The sinkClassID references to a sinkClass. With the help of classification,
+         *  rules can be setup to define the system behaviour.
+         */
+         am_sinkClass_t sinkClassID;
+    
+        am_SinkType_s() = default;
+        am_SinkType_s(const am_sinkID_t& sinkID, const std::string& name, const am_Availability_s& availability, const am_mainVolume_t& volume, const am_MuteState_e& muteState, const am_sinkClass_t& sinkClassID);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    typedef std::vector<am_SinkType_s> am_SinkType_L;
+    typedef uint16_t am_sourceClass_t;
+    /**
+     * struct describing source classes
+     */
+    /**
+     * struct describing source classes
+     */
+    struct am_SourceClass_s: CommonAPI::SerializableStruct {
+        /**
+         * the source ID
+         */
+         am_sourceClass_t sourceClassID;
+        /**
+         * the name of the sourceClass - must be unique in the system
+         */
+         std::string name;
+        /**
+         * the list of the class properties. These are pairs of  a project specific enum
+         *  describing the type of the value and an integer holding the real value.
+         */
+         am_ClassProperty_L listClassProperties;
+    
+        am_SourceClass_s() = default;
+        am_SourceClass_s(const am_sourceClass_t& sourceClassID, const std::string& name, const am_ClassProperty_L& listClassProperties);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    typedef std::vector<am_SourceClass_s> am_SourceClass_L;
+    /**
+     * this type holds all information of sources relevant to the HMI
+     */
+    /**
+     * this type holds all information of sources relevant to the HMI
+     */
+    struct am_SourceType_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the source, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_sourceID_t sourceID;
+        /**
+         * The name of the source. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * the availability of the source
+         */
+         am_Availability_s availability;
+        /**
+         * the sourceClassID, indicates the class the source is in. This information can
+         *  be used by the Controller to implement different behaviour for different
+         *  classes.
+         */
+         am_sourceClass_t sourceClassID;
+    
+        am_SourceType_s() = default;
+        am_SourceType_s(const am_sourceID_t& sourceID, const std::string& name, const am_Availability_s& availability, const am_sourceClass_t& sourceClassID);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    typedef std::vector<am_SourceType_s> am_SourceType_L;
+    /**
+     * describes the different system properties. Project specific
+     */
+    /**
+     * describes the different system properties. Project specific
+     */
+    typedef uint16_t am_CustomSystemPropertyType_t;
+    /**
+     * struct describing system properties
+     */
+    /**
+     * struct describing system properties
+     */
+    struct am_SystemProperty_s: CommonAPI::SerializableStruct {
+        /**
+         * the type that is set
+         */
+         am_CustomSystemPropertyType_t type;
+        /**
+         * the value
+         */
+         int16_t value;
+    
+        am_SystemProperty_s() = default;
+        am_SystemProperty_s(const am_CustomSystemPropertyType_t& type, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_SystemProperty_s> am_SystemProperty_L;
+    /**
+     * a connection ID
+     */
+    /**
+     * a connection ID
+     */
+    typedef uint16_t am_connectionID_t;
+    typedef std::vector<am_connectionID_t> am_ConnectionID_L;
+    /**
+     * The unit is 0.1 db steps,The smallest value -3000 (=AM_MUTE). The minimum and
+     *  maximum can be limited by actual project.
+     */
+    /**
+     * The unit is 0.1 db steps,The smallest value -3000 (=AM_MUTE). The minimum and
+     *  maximum can be limited by actual project.
+     */
+    typedef int16_t am_volume_t;
+    /**
+     * Project specific sound properties.
+     */
+    /**
+     * Project specific sound properties.
+     */
+    typedef uint16_t am_CustomSoundPropertyType_t;
+    /**
+     * This enum characterizes the data of the EarlyData_t
+     */
+    enum class am_EarlyDataType_e: int32_t {
+        /**
+         * default
+         */
+        ES_UNKNOWN = 0,
+        /**
+         * the source volume
+         */
+        ED_SOURCE_VOLUME = 1,
+        /**
+         * the sink volume
+         */
+        ED_SINK_VOLUME = 2,
+        /**
+         * a source property
+         */
+        ED_SOURCE_PROPERTY = 3,
+        /**
+         * a sink property
+         */
+        ED_SINK_PROPERTY = 4,
+        ED_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_EarlyDataType_eComparator;
+    /**
+     * struct describing the sound property
+     */
+    /**
+     * struct describing the sound property
+     */
+    struct am_SoundProperty_s: CommonAPI::SerializableStruct {
+        /**
+         * the type of the property - a project specific enum
+         */
+         am_CustomSoundPropertyType_t type;
+        /**
+         * the actual value of the property
+         */
+         int16_t value;
+    
+        am_SoundProperty_s() = default;
+        am_SoundProperty_s(const am_CustomSoundPropertyType_t& type, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    /**
+     * data type depends of am_EarlyDataType_e:
+    volume_t in case of ED_SOURCE_VOLUME,
+     *  ED_SINK_VOLUME 
+    soundProperty_t in case of ED_SOURCE_PROPERTY,
+     *  ED_SINK_PROPERTY
+     */
+    /**
+     * data type depends of am_EarlyDataType_e:
+    volume_t in case of ED_SOURCE_VOLUME,
+     *  ED_SINK_VOLUME 
+    soundProperty_t in case of ED_SOURCE_PROPERTY,
+     *  ED_SINK_PROPERTY
+     */
+    typedef CommonAPI::Variant<am_volume_t, am_SoundProperty_s>  am_EarlyData_u;
+    /**
+     * data type depends of am_EarlyDataType_e:
+    sourceID in case of ED_SOURCE_VOLUME,
+     *  ED_SOURCE_PROPERTY
+    sinkID in case of ED_SINK_VOLUME, ED_SINK_PROPERTY
+     */
+    /**
+     * data type depends of am_EarlyDataType_e:
+    sourceID in case of ED_SOURCE_VOLUME,
+     *  ED_SOURCE_PROPERTY
+    sinkID in case of ED_SINK_VOLUME, ED_SINK_PROPERTY
+     */
+    typedef CommonAPI::Variant<am_sinkID_t, am_sourceID_t>  am_DataType_u;
+    struct am_EarlyData_s: CommonAPI::SerializableStruct {
+         am_EarlyDataType_e type;
+         am_DataType_u sinksource;
+         am_EarlyData_u data;
+    
+        am_EarlyData_s() = default;
+        am_EarlyData_s(const am_EarlyDataType_e& type, const am_DataType_u& sinksource, const am_EarlyData_u& data);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeVariantType();
+            typeOutputStream.writeVariantType();
+        }
+    };
+    typedef std::vector<am_EarlyData_s> am_EarlyData_L;
+    /**
+     * Here are all SoundProperties that can be set via the CommandInterface. Product
+     *  specific
+     */
+    /**
+     * Here are all SoundProperties that can be set via the CommandInterface. Product
+     *  specific
+     */
+    typedef uint16_t am_CustomMainSoundPropertyType_t;
+    /**
+     * struct describung mainsound property
+     */
+    /**
+     * struct describung mainsound property
+     */
+    struct am_MainSoundProperty_s: CommonAPI::SerializableStruct {
+        /**
+         * the type of the property
+         */
+         am_CustomMainSoundPropertyType_t type;
+        /**
+         * the actual value
+         */
+         int16_t value;
+    
+        am_MainSoundProperty_s() = default;
+        am_MainSoundProperty_s(const am_CustomMainSoundPropertyType_t& type, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_MainSoundProperty_s> am_MainSoundProperty_L;
+    /**
+     * gives the type of the Notification.
+     */
+    /**
+     * gives the type of the Notification.
+     */
+    typedef uint16_t am_CustomNotificationType_t;
+    enum class am_NotificationStatus_e: int32_t {
+        NS_UNKNOWN = 0,
+        /**
+         * No notification, the function is turned off
+         */
+        NS_OFF = 1,
+        /**
+         * Periodic notifications are sent out. The period in ms is given by
+         *  am_NotificationParameter
+         */
+        NS_PERIODIC = 2,
+        /**
+         * The notification is sent out when the minimum given by am_NotificationParameter
+         *  is reached.
+         */
+        NS_MINIMUM = 3,
+        /**
+         * The notification is sent out when the maximum given by am_NotificationParameter
+         *  is reached.
+         */
+        NS_MAXIMUM = 4,
+        /**
+         * The notification is sent out when a change happened. The Resolution of the
+         *  change is defined by am_NotificationParameter.
+         */
+        NS_CHANGE_ = 5,
+        NS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_NotificationStatus_eComparator;
+    /**
+     * This struct holds information about the configuration for notifications
+     */
+    /**
+     * This struct holds information about the configuration for notifications
+     */
+    struct am_NotificationConfiguration_s: CommonAPI::SerializableStruct {
+        /**
+         * The notification type of the notification
+         */
+         am_CustomNotificationType_t type;
+        /**
+         * The Notification status. This can be periodic, min/max value based or even off
+         *  for example
+         */
+         am_NotificationStatus_e status;
+        /**
+         * This gives additional information to the notification status. 
+        Relation between
+         *  notification status and the value:
+        NS_PERIODIC - the period in ms
+        NS_MINIMUM
+         *  - the minimum value that triggers the notification
+        NS_MAXIMUM - the maximum
+         *  value that triggers the notifcation
+        NS_CHANGE - the resolution of the change
+         *  value
+         */
+         int16_t parameter;
+    
+        am_NotificationConfiguration_s() = default;
+        am_NotificationConfiguration_s(const am_CustomNotificationType_t& type, const am_NotificationStatus_e& status, const int16_t& parameter);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_NotificationConfiguration_s> am_NotificationConfiguration_L;
+    /**
+     * a domain ID
+     */
+    /**
+     * a domain ID
+     */
+    typedef uint16_t am_domainID_t;
+    /**
+     * This project specific value classifies the format in which data is exchanged
+     *  within a connection.
+     */
+    /**
+     * This project specific value classifies the format in which data is exchanged
+     *  within a connection.
+     */
+    typedef uint16_t am_CustomConnectionFormat_t;
+    /**
+     * This represents one "hopp" in a route
+     */
+    /**
+     * This represents one "hopp" in a route
+     */
+    struct am_RoutingElement_s: CommonAPI::SerializableStruct {
+        /**
+         * the source ID
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the sinkID
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the domainID the routeElement is in
+         */
+         am_domainID_t domainID;
+        /**
+         * the connectionformat that is used for the route
+         */
+         am_CustomConnectionFormat_t connectionFormat;
+    
+        am_RoutingElement_s() = default;
+        am_RoutingElement_s(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_domainID_t& domainID, const am_CustomConnectionFormat_t& connectionFormat);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    typedef std::vector<am_RoutingElement_s> am_RoutingElement_L;
+    typedef std::vector<am_SoundProperty_s> am_SoundProperty_L;
+    /**
+     * time in ms!
+     */
+    /**
+     * time in ms!
+     */
+    typedef int16_t am_time_t;
+    /**
+     * For products, different ramp types can be defined here.
+    It is in the
+     *  responsibility of the product to make sure that the routing plugins are aware
+     *  of the ramp types used.
+     */
+    /**
+     * For products, different ramp types can be defined here.
+    It is in the
+     *  responsibility of the product to make sure that the routing plugins are aware
+     *  of the ramp types used.
+     */
+    typedef uint16_t am_CustomRampType_t;
+    /**
+     * This datatype determines if a sourceID or a sinkID is used in the union
+     *  following
+     */
+    enum class am_VolumeType_e: int32_t {
+        VT_UNKNOWN = 0,
+        /**
+         * the following type is a sink
+         */
+        VT_SINK = 1,
+        /**
+         * the following type is a source
+         */
+        VT_SOURCE = 2,
+        VT_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_VolumeType_eComparator;
+    /**
+     * This types describe a mixed description for source and sinks volumes.
+     */
+    /**
+     * This types describe a mixed description for source and sinks volumes.
+     */
+    struct am_Volumes_s: CommonAPI::SerializableStruct {
+        /**
+         * describes the type of the volume: source or sink.
+         */
+         am_VolumeType_e volumeType;
+        /**
+         * either sourceID or sinkID
+         */
+         am_DataType_u volumeID;
+        /**
+         * The volume
+         */
+         am_volume_t volume;
+        /**
+         * the ramp that shall be driven
+         */
+         am_CustomRampType_t ramp;
+        /**
+         * the time for the ramp
+         */
+         am_time_t time;
+    
+        am_Volumes_s() = default;
+        am_Volumes_s(const am_VolumeType_e& volumeType, const am_DataType_u& volumeID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeVariantType();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    typedef std::vector<am_Volumes_s> am_Volumes_L;
+    typedef std::vector<am_CustomConnectionFormat_t> am_ConnectionFormat_L;
+    typedef bool am_bool_t;
+    typedef std::vector<am_bool_t> am_Convertion_L;
+    /**
+     * a gateway ID
+     */
+    /**
+     * a gateway ID
+     */
+    typedef uint16_t am_gatewayID_t;
+    /**
+     * a converter ID
+     */
+    /**
+     * a converter ID
+     */
+    typedef uint16_t am_converterID_t;
+    /**
+     * a crossfader ID
+     */
+    /**
+     * a crossfader ID
+     */
+    typedef uint16_t am_crossfaderID_t;
+    /**
+     * speed
+     */
+    /**
+     * speed
+     */
+    typedef uint16_t am_speed_t;
+    /**
+     * describes the active sink of a crossfader.
+     */
+    enum class am_HotSink_e: int32_t {
+        /**
+         * default
+         */
+        HS_UNKNOWN = 0,
+        /**
+         * sinkA is active
+         */
+        HS_SINKA = 1,
+        /**
+         * sinkB is active
+         */
+        HS_SINKB = 2,
+        /**
+         * the crossfader is in the transition state
+         */
+        HS_INTERMEDIATE = 3,
+        HS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_HotSink_eComparator;
+    enum class am_DomainState_e: int32_t {
+        /**
+         * default
+         */
+        DS_UNKNOWN = 0,
+        /**
+         * the domain is controlled by the daemon
+         */
+        DS_CONTROLLED = 1,
+        /**
+         * the domain is independent starting up
+         */
+        DS_INDEPENDENT_STARTUP = 1,
+        /**
+         * the domain is independent running down
+         */
+        DS_INDEPENDENT_RUNDOWN = 2,
+        DS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_DomainState_eComparator;
+    /**
+     * the errors of the audiomanager. All possible errors are in here. This enum is
+     *  used widely as return parameter.
+     */
+    enum class am_Error_e: int32_t {
+        /**
+         * no error - positive reply
+         */
+        E_OK = 0,
+        /**
+         * default
+         */
+        E_UNKNOWN = 1,
+        /**
+         * value out of range
+         */
+        E_OUT_OF_RANGE = 2,
+        /**
+         * not used
+         */
+        E_NOT_USED = 3,
+        /**
+         * a database error occurred
+         */
+        E_DATABASE_ERROR = 4,
+        /**
+         * the desired object already exists
+         */
+        E_ALREADY_EXISTS = 5,
+        /**
+         * there is no change
+         */
+        E_NO_CHANGE = 6,
+        /**
+         * the desired action is not possible
+         */
+        E_NOT_POSSIBLE = 7,
+        /**
+         * the desired object is non existent
+         */
+        E_NON_EXISTENT = 8,
+        /**
+         * the asynchronous action was aborted
+         */
+        E_ABORTED = 9,
+        /**
+         * This error is returned in case a connect is issued with a connectionFormat that
+         *  cannot be selected for the connection. This could be either due to the
+         *  capabilities of a source or a sink or gateway compatibilities for example
+         */
+        E_WRONG_FORMAT = 10,
+        E_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_Error_eComparator;
+    enum class am_InterruptState_e: int32_t {
+        /**
+         * default
+         */
+        IS_UNKNOWN = 0,
+        /**
+         * the interrupt state is off - no interrupt
+         */
+        IS_OFF = 1,
+        /**
+         * the interrupt state is interrupted - the interrupt is active
+         */
+        IS_INTERRUPTED = 2,
+        IS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_InterruptState_eComparator;
+    /**
+     * This enumeration is used to define the type of the action that is correlated to
+     *  a handle.
+     */
+    enum class am_Handle_e: int32_t {
+        H_UNKNOWN = 0,
+        H_CONNECT = 1,
+        H_DISCONNECT = 2,
+        H_SETSOURCESTATE = 3,
+        H_SETSINKVOLUME = 4,
+        H_SETSOURCEVOLUME = 5,
+        H_SETSINKSOUNDPROPERTY = 6,
+        H_SETSOURCESOUNDPROPERTY = 7,
+        H_SETSINKSOUNDPROPERTIES = 8,
+        H_SETSOURCESOUNDPROPERTIES = 9,
+        H_CROSSFADE = 10,
+        H_SETVOLUMES = 11,
+        H_SETSINKNOTIFICATION = 12,
+        H_SETSOURCENOTIFICATION = 13,
+        H_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_Handle_eComparator;
+    /**
+     * The source state reflects the state of the source
+     */
+    enum class am_SourceState_e: int32_t {
+        SS_UNKNNOWN = 0,
+        /**
+         * The source can be activly heared
+         */
+        SS_ON = 1,
+        /**
+         * The source cannot be heared
+         */
+        SS_OFF = 2,
+        /**
+         * The source is paused. Meaning it cannot be heared but should be prepared to
+         *  play again soon.
+         */
+        SS_PAUSED = 3,
+        SS_MAX
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_SourceState_eComparator;
+    /**
+     * This enum describes the ready state of the routing part
+     */
+    enum class am_RoutingReady_e: int32_t {
+        RR_UNKNOWN = 0,
+        RR_READY = 1,
+        RR_RUNDOWN = 2
+    };
+    
+    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
+    struct am_RoutingReady_eComparator;
+    /**
+     * a list of routing elements that lead from source to sink
+     */
+    /**
+     * a list of routing elements that lead from source to sink
+     */
+    struct am_Route_s: CommonAPI::SerializableStruct {
+        /**
+         * the sourceID where the route starts
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the sinkID where the route ends
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the actual route as list of routing elements
+         */
+         am_RoutingElement_L route;
+    
+        am_Route_s() = default;
+        am_Route_s(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_RoutingElement_L& route);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct describes the attribiutes of a crossfader.
+     */
+    /**
+     * This struct describes the attribiutes of a crossfader.
+     */
+    struct am_Crossfader_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the crossfader, it is unique in the system. There are 2 ways,
+         *  ID can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManager daemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_crossfaderID_t crossfaderID;
+        /**
+         * The name of the crossfader. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * The sinkID of the SinkA. Sinks shall be registered before registering the
+         *  crossfader.
+         */
+         am_sinkID_t sinkID_A;
+        /**
+         * The sinkID of the SinkB. Sinks shall be registered before registering the
+         *  crossfader.
+         */
+         am_sinkID_t sinkID_B;
+        /**
+         * The sourceID of the crossfader source. The source shall be registered before
+         *  the crossfader.
+         */
+         am_sourceID_t sourceID;
+        /**
+         * This enum can have 3 states:
+        
+            HS_SINKA sinkA is the current hot one, sinkB
+         *  is not audible
+            HS_SINKB sinkB is the current hot one, sinkB is not
+         *  audible
+            HS_INTERMEDIATE the fader is stuck in between a cross-fading
+         *  action. This could be due to an abort or an error. Before using the
+         *  crossfader, it must be set to either HS_SINKA or HS_SINKB.
+         */
+         am_HotSink_e hotSink;
+    
+        am_Crossfader_s() = default;
+        am_Crossfader_s(const am_crossfaderID_t& crossfaderID, const std::string& name, const am_sinkID_t& sinkID_A, const am_sinkID_t& sinkID_B, const am_sourceID_t& sourceID, const am_HotSink_e& hotSink);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt32Type();
+        }
+    };
+    /**
+     * This struct describes the attributes of a gateway.
+     */
+    /**
+     * This struct describes the attributes of a gateway.
+     */
+    struct am_Gateway_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the gateway, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_gatewayID_t gatewayID;
+        /**
+         * The name of the gateway. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * The sinkID of the gateway sink-end. The sink is a full blown sink with
+         *  connectionFormats, sinkClassIDs etc... It makes sense to register the sinks of
+         *  a gateway as non-visible. Care needs to be taken that the connectionsFormats
+         *  match with the ones in the conversionMatrix. If the sink is located in the
+         *  controllingDomain, the ID needs to be retrieved by registering the sink before
+         *  registering the gateway. In case the sink is in a different domain, the ID
+         *  needs to be retrieved via peeking.
+         */
+         am_sinkID_t sinkID;
+        /**
+         * The sourceID of the gateway sink-end. The sink is a full blown source with
+         *  connectionFormats, sinkClassIDs etc... It makes sense to register the sources
+         *  of a gateway as non-visible. Care needs to be taken that the
+         *  connectionsFormats match with the ones in the conversionMatrix. If the source
+         *  is located in the controllingDomain, the ID needs to be retrieved by
+         *  registering the source before registering the gateway. In case the source is
+         *  in a different domain, the ID needs to be retrieved via peeking.
+         */
+         am_sourceID_t sourceID;
+        /**
+         * The ID of the sink. If the domain is the same like the controlling domain, the
+         *  ID is known due to registration. If the domain is different, the ID needs to
+         *  be retrieved via peeking.
+         */
+         am_domainID_t domainSinkID;
+        /**
+         * The ID of the source. If the domain is the same like the controlling domain,
+         *  the ID is known due to registration. If the domain is different, the ID needs
+         *  to be retrieved via peeking.
+         */
+         am_domainID_t domainSourceID;
+        /**
+         * This is the ID of the domain that registers the gateway.
+         */
+         am_domainID_t controlDomainID;
+        /**
+         * This is the list of available formats on the source side of the gateway. It is
+         *  not defined during the gateway registration but copied from the source
+         *  registration.
+         */
+         am_ConnectionFormat_L listSourceFormats;
+        /**
+         * This is the list of available formats on the sink side of the gateway. It is
+         *  not defined during the gateway registration but copied from the sink
+         *  registration.
+         */
+         am_ConnectionFormat_L listSinkFormats;
+        /**
+         * This is matrix holding information about the conversion capability of the
+         *  gateway, it's length is defined by the length(listSinkFormats) x
+         *  length(listSourceFormats).
+        If a SinkFormat can be converted into a
+         *  SourceFormat, the vector will hold a 1, if no conversion is possible, a
+         *  0.
+        The data is stored row orientated, where the rows are related to the
+         *  sinksFormats and the columns to the sourceFormats. The first value will hold
+         *  the conversion information from the first sourceFormat to the first sinkFormat
+         *  for example and the seventh value the information about the 3rd sinkFormat to
+         *  the 1st sourceFormat in case we would have 3 sourceFormats.
+         */
+         am_Convertion_L convertionMatrix;
+    
+        am_Gateway_s() = default;
+        am_Gateway_s(const am_gatewayID_t& gatewayID, const std::string& name, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_domainID_t& domainSinkID, const am_domainID_t& domainSourceID, const am_domainID_t& controlDomainID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct describes the attributes of a gateway.
+     */
+    /**
+     * This struct describes the attributes of a gateway.
+     */
+    struct am_Converter_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the gateway, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_converterID_t converterID;
+        /**
+         * The name of the gateway. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * The sinkID of the gateway sink-end. The sink is a full blown sink with
+         *  connectionFormats, sinkClassIDs etc... It makes sense to register the sinks of
+         *  a gateway as non-visible. Care needs to be taken that the connectionsFormats
+         *  match with the ones in the conversionMatrix. If the sink is located in the
+         *  controllingDomain, the ID needs to be retrieved by registering the sink before
+         *  registering the gateway. In case the sink is in a different domain, the ID
+         *  needs to be retrieved via peeking.
+         */
+         am_sinkID_t sinkID;
+        /**
+         * The sourceID of the gateway sink-end. The sink is a full blown source with
+         *  connectionFormats, sinkClassIDs etc... It makes sense to register the sources
+         *  of a gateway as non-visible. Care needs to be taken that the
+         *  connectionsFormats match with the ones in the conversionMatrix. If the source
+         *  is located in the controllingDomain, the ID needs to be retrieved by
+         *  registering the source before registering the gateway. In case the source is
+         *  in a different domain, the ID needs to be retrieved via peeking.
+         */
+         am_sourceID_t sourceID;
+        /**
+         * The ID of the sink. If the domain is the same like the controlling domain, the
+         *  ID is known due to registration. If the domain is different, the ID needs to
+         *  be retrieved via peeking.
+         */
+         am_domainID_t domainID;
+        /**
+         * This is the list of available formats on the source side of the gateway. It is
+         *  not defined during the gateway registration but copied from the source
+         *  registration.
+         */
+         am_ConnectionFormat_L listSourceFormats;
+        /**
+         * This is the list of available formats on the sink side of the gateway. It is
+         *  not defined during the gateway registration but copied from the sink
+         *  registration.
+         */
+         am_ConnectionFormat_L listSinkFormats;
+        /**
+         * This is matrix holding information about the conversion capability of the
+         *  gateway, it's length is defined by the length(listSinkFormats) x
+         *  length(listSourceFormats).
+        If a SinkFormat can be converted into a
+         *  SourceFormat, the vector will hold a 1, if no conversion is possible, a
+         *  0.
+        The data is stored row orientated, where the rows are related to the
+         *  sinksFormats and the columns to the sourceFormats. The first value will hold
+         *  the conversion information from the first sourceFormat to the first sinkFormat
+         *  for example and the seventh value the information about the 3rd sinkFormat to
+         *  the 1st sourceFormat in case we would have 3 sourceFormats.
+         */
+         am_Convertion_L convertionMatrix;
+    
+        am_Converter_s() = default;
+        am_Converter_s(const am_converterID_t& converterID, const std::string& name, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_domainID_t& domainID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * a handle is used for asynchronous operations and is uniquely assigned for each
+     *  of this operations
+     */
+    /**
+     * a handle is used for asynchronous operations and is uniquely assigned for each
+     *  of this operations
+     */
+    struct am_Handle_s: CommonAPI::SerializableStruct {
+        /**
+         * the handletype
+         */
+         am_Handle_e handleType;
+        /**
+         * the handle as value
+         */
+         uint16_t handle;
+    
+        am_Handle_s() = default;
+        am_Handle_s(const am_Handle_e& handleType, const uint16_t& handle);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+    /**
+     * struct that holds attribiutes of a mainconnection
+     */
+    /**
+     * struct that holds attribiutes of a mainconnection
+     */
+    struct am_MainConnection_s: CommonAPI::SerializableStruct {
+        /**
+         * the assigned ID
+         */
+         am_mainConnectionID_t mainConnectionID;
+        /**
+         * the current connection state
+         */
+         am_ConnectionState_e connectionState;
+        /**
+         * the sinkID
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the sourceID
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the delay of the connection
+         */
+         am_timeSync_t delay;
+        /**
+         * the list of sub connection IDs the mainconnection consists of
+         */
+         am_ConnectionID_L listConnectionID;
+    
+        am_MainConnection_s() = default;
+        am_MainConnection_s(const am_mainConnectionID_t& mainConnectionID, const am_ConnectionState_e& connectionState, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_timeSync_t& delay, const am_ConnectionID_L& listConnectionID);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct holds the payload of a notification.
+     */
+    /**
+     * This struct holds the payload of a notification.
+     */
+    struct am_NotificationPayload_s: CommonAPI::SerializableStruct {
+        /**
+         * This defines the notification type
+         */
+         am_CustomNotificationType_t type;
+        /**
+         * This is finally the value of the notification. It's meaning depends on the
+         *  notificationType
+         */
+         int16_t value;
+    
+        am_NotificationPayload_s() = default;
+        am_NotificationPayload_s(const am_CustomNotificationType_t& type, const int16_t& value);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+        }
+    };
+    /**
+     * This struct describes the attribiutes of a sink
+     */
+    /**
+     * This struct describes the attribiutes of a sink
+     */
+    struct am_Sink_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the sink, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_sinkID_t sinkID;
+        /**
+         * The name of the sink. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * The domainID is the domain the sink belongs to. A sink can only be in one
+         *  domain.
+         */
+         am_domainID_t domainID;
+        /**
+         * The sinkClassID references to a sinkClass. With the help of classification,
+         *  rules can be setup to define the system behaviour.
+         */
+         am_sinkClass_t sinkClassID;
+        /**
+         * This is the volume of the sink. It is set by the AudioManagerController.
+         */
+         am_volume_t volume;
+        /**
+         * This Boolean flag indicates whether a sink is visible to the commandInterface
+         *  or not. If the User must have the possibility to choose the source in the HMI,
+         *  it must be visible. But there are also good reasons for invisible sinks, for
+         *  example if the sink is part of a crossfader or gateway. HMI relevant changes
+         *  in visible sinks will be automatically reported by the daemon to the
+         *  commandInterface.
+         */
+         bool visible;
+        /**
+         * This attribute reflects the availability of the sink. There are several reasons
+         *  why a sink could be not available for the moment: for example the shutdown of
+         *  a sink because of overtemperature or over- &amp; undervoltage. The
+         *  availability consists of two pieces of information:
+        
+            Availablility: the
+         *  status itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
+           
+         *  AvailabilityReason: this informs about the last reason for a change in
+         *  availability. The reasons itself are product specific.
+         */
+         am_Availability_s available;
+        /**
+         * This attribute reflects the muteState of the sink. The information is not the
+         *  "real" state of the sink, but the HMI representation for he commandInterface
+         *  controlled by the AudioManagerController.
+         */
+         am_MuteState_e muteState;
+        /**
+         * This is the representation of the Volume for the commandInterface. It is used
+         *  by the HMI to set the volume of a sink, the AudioManagerController has to
+         *  transform this into real source and sink volumes.
+         */
+         am_mainVolume_t mainVolume;
+        /**
+         * This is the list of soundProperties, that the sink is capable of. The
+         *  soundProperties itself are project specific. For sinks, a possible
+         *  soundProperty could be for example settings.
+         */
+         am_SoundProperty_L listSoundProperties;
+        /**
+         * This list holds information about the formats that the Source is capable of
+         *  supporting when delivering audio.
+         */
+         am_ConnectionFormat_L listConnectionFormats;
+        /**
+         * This is the list of the available mainSoundProperties. The principle is the
+         *  same than with soundProperties, but they are only visible to the
+         *  CommandInterface.
+         */
+         am_MainSoundProperty_L listMainSoundProperties;
+        /**
+         * This is the list of the MainNotificationConfigurations. These notifications
+         *  work on the level of command interface.
+         */
+         am_NotificationConfiguration_L listMainNotificationConfigurations;
+        /**
+         * This is the list of the NotificationConfigurations. These notifications work on
+         *  the level of RoutingPlugins.
+         */
+         am_NotificationConfiguration_L listNotificationConfigurations;
+    
+        am_Sink_s() = default;
+        am_Sink_s(const am_sinkID_t& sinkID, const std::string& name, const am_domainID_t& domainID, const am_sinkClass_t& sinkClassID, const am_volume_t& volume, const bool& visible, const am_Availability_s& available, const am_MuteState_e& muteState, const am_mainVolume_t& mainVolume, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, const am_NotificationConfiguration_L& listMainNotificationConfigurations, const am_NotificationConfiguration_L& listNotificationConfigurations);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct describes the attribiutes of a source
+     */
+    /**
+     * This struct describes the attribiutes of a source
+     */
+    struct am_Source_s: CommonAPI::SerializableStruct {
+        /**
+         * This is the ID of the source, it is unique in the system. There are 2 ways, ID
+         *  can be created: either it is assigned during the registration process (in a
+         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
+         *  is a fixed (the project has to ensure the uniqueness of the ID).
+         */
+         am_sourceID_t sourceID;
+        /**
+         * The domainID is the domain the source belongs to. A source can only be in one
+         *  domain.
+         */
+         am_domainID_t domainID;
+        /**
+         * The name of the source. Must be unique in the whole system.
+         */
+         std::string name;
+        /**
+         * the sourceClassID, indicates the class the source is in. This information can
+         *  be used by the Controller to implement different behaviour for different
+         *  classes.
+         */
+         am_sourceClass_t sourceClassID;
+        /**
+         * The source state is an indication towards the source if it is actively heard or
+         *  not. The source can use this information to implement features like automatic
+         *  spin down of CD's in case the CD is not the active source or AF following of a
+         *  tuner that is not actively heard. The source state is set by the
+         *  AudioManagerController.There are 3 possible states:
+        
+            SS_ON: the source is
+         *  active
+            SS_OFF: the source is off
+            SS_PAUSED: the source is paused and
+         *  not active.
+         */
+         am_SourceState_e sourceState;
+        /**
+         * This is the volume of the source. It is set by the AudioManagerController. It
+         *  is used to adopt different audiolevels in a system and mixing of sources (e.g.
+         *  navigation hints &amp; music).
+         */
+         am_volume_t volume;
+        /**
+         * This Boolean flag indicates whether a source is visible to the commandInterface
+         *  or not. If the User must have the possibility to choose the source in the HMI,
+         *  it must be visible. But there are also good reasons for invisible sources, for
+         *  example if the source is part of a crossfader or gateway. HMI relevant changes
+         *  in visible sources will be automatically reported by the daemon to the
+         *  commandInterface.
+         */
+         bool visible;
+        /**
+         * This attribute reflects the availability of the source. There are several
+         *  reasons why a source could be not available for the moment. For example a CD
+         *  player which has no CD entered in the slot can be unavailable, or a USB player
+         *  with no or unreadable stick attached. Other scenarios involve the shutdown of
+         *  a source because of overtemperature or over- &amp; undervoltage. The
+         *  availability consists of two informations:
+        
+            Availablility: the status
+         *  itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
+           
+         *  AvailabilityReason: this informs about the last reason for a change in
+         *  availability. The reasons itself are product specific.
+         */
+         am_Availability_s available;
+        /**
+         * Some special sources can have special behaviors, the are so called "Low Level
+         *  Interrupts". Here the current status is documented. The information can be
+         *  used by the AudioManagerController to react to the changes by for example
+         *  lowering the volume of the mainSources. The two states are
+        
+            IS_OFF: the
+         *  interrupt is not active at the moment
+            IS_INTERRUPTED: the interrupt is
+         *  playing at the moment.
+         */
+         am_InterruptState_e interruptState;
+        /**
+         * This is the list of soundProperties, that the source is capable of. The
+         *  soundProperties itself are project specific. For sources, a possible
+         *  soundProperty could be navigation volume offset, for example.
+         */
+         am_SoundProperty_L listSoundProperties;
+        /**
+         * This list holds information about the formats that the Source is capable of
+         *  supporting when delivering audio.
+         */
+         am_ConnectionFormat_L listConnectionFormats;
+        /**
+         * This is the list of the available mainSoundProperties. The principle is the
+         *  same than with soundProperties, but they are only visible to the
+         *  CommandInterface.
+         */
+         am_MainSoundProperty_L listMainSoundProperties;
+        /**
+         * The list of MainNotificationConfigurations. These notifications work on the
+         *  level of CommandInterface.
+         */
+         am_NotificationConfiguration_L listMainNotificationConfigurations;
+        /**
+         * The list of MainNotificationConfigurations. These notifications work on the
+         *  level of RoutingInterface.
+         */
+         am_NotificationConfiguration_L listNotificationConfigurations;
+    
+        am_Source_s() = default;
+        am_Source_s(const am_sourceID_t& sourceID, const am_domainID_t& domainID, const std::string& name, const am_sourceClass_t& sourceClassID, const am_SourceState_e& sourceState, const am_volume_t& volume, const bool& visible, const am_Availability_s& available, const am_InterruptState_e& interruptState, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, const am_NotificationConfiguration_L& listMainNotificationConfigurations, const am_NotificationConfiguration_L& listNotificationConfigurations);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.writeInt32Type();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+            typeOutputStream.beginWriteVectorType();
+            typeOutputStream.beginWriteStructType();
+            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
+            typeOutputStream.endWriteStructType();
+            typeOutputStream.endWriteVectorType();
+        }
+    };
+    /**
+     * This struct describes the attribiutes of a domain
+     */
+    /**
+     * This struct describes the attribiutes of a domain
+     */
+    struct am_Domain_s: CommonAPI::SerializableStruct {
+        /**
+         * the domain ID
+         */
+         am_domainID_t domainID;
+        /**
+         * the name of the domain
+         */
+         std::string name;
+        /**
+         * the busname. This is equal to a plugin name and is used to dispatch messages to
+         *  the elements of a plugin
+         */
+         std::string busname;
+        /**
+         * the name of the node
+         */
+         std::string nodename;
+        /**
+         * indicated if the domain is independent at startup or not
+         */
+         bool early;
+        /**
+         * indicates if the domain registration is complete or not
+         */
+         bool complete;
+        /**
+         * the current domain state
+         */
+         am_DomainState_e state;
+    
+        am_Domain_s() = default;
+        am_Domain_s(const am_domainID_t& domainID, const std::string& name, const std::string& busname, const std::string& nodename, const bool& early, const bool& complete, const am_DomainState_e& state);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeStringType();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.writeBoolType();
+            typeOutputStream.writeInt32Type();
+        }
+    };
+    /**
+     * a connection
+     */
+    /**
+     * a connection
+     */
+    struct am_Connection_s: CommonAPI::SerializableStruct {
+        /**
+         * the assigned ID
+         */
+         am_connectionID_t connectionID;
+        /**
+         * the source the audio flows from
+         */
+         am_sourceID_t sourceID;
+        /**
+         * the sink the audio flows to
+         */
+         am_sinkID_t sinkID;
+        /**
+         * the delay of the conneciton
+         */
+         am_timeSync_t delay;
+        /**
+         * the used connectionformat
+         */
+         am_CustomConnectionFormat_t connectionFormat;
+    
+        am_Connection_s() = default;
+        am_Connection_s(const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_timeSync_t& delay, const am_CustomConnectionFormat_t& connectionFormat);
+    
+    
+        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
+        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
+    
+        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeUInt16Type();
+            typeOutputStream.writeInt16Type();
+            typeOutputStream.writeUInt16Type();
+        }
+    };
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Availability_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Availability_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_Availability_eComparator {
+    inline bool operator()(const am_Availability_e& lhs, const am_Availability_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_HotSink_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_HotSink_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_HotSink_eComparator {
+    inline bool operator()(const am_HotSink_e& lhs, const am_HotSink_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_ConnectionState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_ConnectionState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_ConnectionState_eComparator {
+    inline bool operator()(const am_ConnectionState_e& lhs, const am_ConnectionState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_DomainState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_DomainState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_DomainState_eComparator {
+    inline bool operator()(const am_DomainState_e& lhs, const am_DomainState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_EarlyDataType_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_EarlyDataType_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_EarlyDataType_eComparator {
+    inline bool operator()(const am_EarlyDataType_e& lhs, const am_EarlyDataType_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Error_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Error_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_Error_eComparator {
+    inline bool operator()(const am_Error_e& lhs, const am_Error_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_MuteState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_MuteState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_MuteState_eComparator {
+    inline bool operator()(const am_MuteState_e& lhs, const am_MuteState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_InterruptState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_InterruptState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_InterruptState_eComparator {
+    inline bool operator()(const am_InterruptState_e& lhs, const am_InterruptState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_VolumeType_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_VolumeType_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_VolumeType_eComparator {
+    inline bool operator()(const am_VolumeType_e& lhs, const am_VolumeType_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_NotificationStatus_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_NotificationStatus_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_NotificationStatus_eComparator {
+    inline bool operator()(const am_NotificationStatus_e& lhs, const am_NotificationStatus_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Handle_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Handle_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_Handle_eComparator {
+    inline bool operator()(const am_Handle_e& lhs, const am_Handle_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_SourceState_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_SourceState_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_SourceState_eComparator {
+    inline bool operator()(const am_SourceState_e& lhs, const am_SourceState_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_RoutingReady_e& enumValue) {
+    return inputStream.readEnumValue<int32_t>(enumValue);
+}
+
+inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_RoutingReady_e& enumValue) {
+    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
+}
+
+struct am_RoutingReady_eComparator {
+    inline bool operator()(const am_RoutingReady_e& lhs, const am_RoutingReady_e& rhs) const {
+        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
+    }
+};
+
+bool operator==(const am_Route_s& lhs, const am_Route_s& rhs);
+inline bool operator!=(const am_Route_s& lhs, const am_Route_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Availability_s& lhs, const am_Availability_s& rhs);
+inline bool operator!=(const am_Availability_s& lhs, const am_Availability_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs);
+inline bool operator!=(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs);
+inline bool operator!=(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Gateway_s& lhs, const am_Gateway_s& rhs);
+inline bool operator!=(const am_Gateway_s& lhs, const am_Gateway_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Converter_s& lhs, const am_Converter_s& rhs);
+inline bool operator!=(const am_Converter_s& lhs, const am_Converter_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs);
+inline bool operator!=(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs);
+inline bool operator!=(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs);
+inline bool operator!=(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs);
+inline bool operator!=(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs);
+inline bool operator!=(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SourceType_s& lhs, const am_SourceType_s& rhs);
+inline bool operator!=(const am_SourceType_s& lhs, const am_SourceType_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_SinkType_s& lhs, const am_SinkType_s& rhs);
+inline bool operator!=(const am_SinkType_s& lhs, const am_SinkType_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Handle_s& lhs, const am_Handle_s& rhs);
+inline bool operator!=(const am_Handle_s& lhs, const am_Handle_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs);
+inline bool operator!=(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs);
+inline bool operator!=(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs);
+inline bool operator!=(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs);
+inline bool operator!=(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs);
+inline bool operator!=(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Sink_s& lhs, const am_Sink_s& rhs);
+inline bool operator!=(const am_Sink_s& lhs, const am_Sink_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Source_s& lhs, const am_Source_s& rhs);
+inline bool operator!=(const am_Source_s& lhs, const am_Source_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Domain_s& lhs, const am_Domain_s& rhs);
+inline bool operator!=(const am_Domain_s& lhs, const am_Domain_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs);
+inline bool operator!=(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Connection_s& lhs, const am_Connection_s& rhs);
+inline bool operator!=(const am_Connection_s& lhs, const am_Connection_s& rhs) {
+    return !(lhs == rhs);
+}
+bool operator==(const am_Volumes_s& lhs, const am_Volumes_s& rhs);
+inline bool operator!=(const am_Volumes_s& lhs, const am_Volumes_s& rhs) {
+    return !(lhs == rhs);
+}
+
+
+static inline const char* getTypeCollectionName() {
+    static const char* typeCollectionName = "org.genivi.am";
+    return typeCollectionName;
+}
+
+inline CommonAPI::Version getTypeCollectionVersion() {
+    return CommonAPI::Version(2, 0);
+}
+
+} // namespace am
+
+} // namespace genivi
+} // namespace org
+
+namespace CommonAPI {
+
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_Availability_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_Availability_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Availability_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_Availability_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Availability_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_HotSink_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_HotSink_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_HotSink_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_HotSink_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_HotSink_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_ConnectionState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_ConnectionState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_ConnectionState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_ConnectionState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_ConnectionState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_DomainState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_DomainState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_DomainState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_DomainState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_DomainState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_EarlyDataType_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_EarlyDataType_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_EarlyDataType_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_EarlyDataType_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_EarlyDataType_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_Error_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_Error_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Error_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_Error_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Error_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_MuteState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_MuteState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_MuteState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_MuteState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_MuteState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_InterruptState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_InterruptState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_InterruptState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_InterruptState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_InterruptState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_VolumeType_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_VolumeType_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_VolumeType_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_VolumeType_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_VolumeType_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_NotificationStatus_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_NotificationStatus_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_NotificationStatus_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_NotificationStatus_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_NotificationStatus_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_Handle_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_Handle_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Handle_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_Handle_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Handle_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_SourceState_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_SourceState_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_SourceState_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_SourceState_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_SourceState_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+    template<>
+    struct BasicTypeWriter<org::genivi::am::am_RoutingReady_e> {
+        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
+            typeStream.writeInt32EnumType();
+        }
+    };
+    
+    template<>
+    struct InputStreamVectorHelper<org::genivi::am::am_RoutingReady_e> {
+        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_RoutingReady_e>& vectorValue) {
+            inputStream.beginReadInt32EnumVector();
+        }
+    };
+    
+    template <>
+    struct OutputStreamVectorHelper<org::genivi::am::am_RoutingReady_e> {
+        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_RoutingReady_e>& vectorValue) {
+            outputStream.beginWriteInt32EnumVector(vectorValue.size());
+        }
+    };
+
+}
+
+
+namespace std {
+    //Hash for am_Availability_e
+    template<>
+    struct hash<org::genivi::am::am_Availability_e> {
+        inline size_t operator()(const org::genivi::am::am_Availability_e& am_Availability_e) const {
+            return static_cast<int32_t>(am_Availability_e);
+        }
+    };
+    //Hash for am_HotSink_e
+    template<>
+    struct hash<org::genivi::am::am_HotSink_e> {
+        inline size_t operator()(const org::genivi::am::am_HotSink_e& am_HotSink_e) const {
+            return static_cast<int32_t>(am_HotSink_e);
+        }
+    };
+    //Hash for am_ConnectionState_e
+    template<>
+    struct hash<org::genivi::am::am_ConnectionState_e> {
+        inline size_t operator()(const org::genivi::am::am_ConnectionState_e& am_ConnectionState_e) const {
+            return static_cast<int32_t>(am_ConnectionState_e);
+        }
+    };
+    //Hash for am_DomainState_e
+    template<>
+    struct hash<org::genivi::am::am_DomainState_e> {
+        inline size_t operator()(const org::genivi::am::am_DomainState_e& am_DomainState_e) const {
+            return static_cast<int32_t>(am_DomainState_e);
+        }
+    };
+    //Hash for am_EarlyDataType_e
+    template<>
+    struct hash<org::genivi::am::am_EarlyDataType_e> {
+        inline size_t operator()(const org::genivi::am::am_EarlyDataType_e& am_EarlyDataType_e) const {
+            return static_cast<int32_t>(am_EarlyDataType_e);
+        }
+    };
+    //Hash for am_Error_e
+    template<>
+    struct hash<org::genivi::am::am_Error_e> {
+        inline size_t operator()(const org::genivi::am::am_Error_e& am_Error_e) const {
+            return static_cast<int32_t>(am_Error_e);
+        }
+    };
+    //Hash for am_MuteState_e
+    template<>
+    struct hash<org::genivi::am::am_MuteState_e> {
+        inline size_t operator()(const org::genivi::am::am_MuteState_e& am_MuteState_e) const {
+            return static_cast<int32_t>(am_MuteState_e);
+        }
+    };
+    //Hash for am_InterruptState_e
+    template<>
+    struct hash<org::genivi::am::am_InterruptState_e> {
+        inline size_t operator()(const org::genivi::am::am_InterruptState_e& am_InterruptState_e) const {
+            return static_cast<int32_t>(am_InterruptState_e);
+        }
+    };
+    //Hash for am_VolumeType_e
+    template<>
+    struct hash<org::genivi::am::am_VolumeType_e> {
+        inline size_t operator()(const org::genivi::am::am_VolumeType_e& am_VolumeType_e) const {
+            return static_cast<int32_t>(am_VolumeType_e);
+        }
+    };
+    //Hash for am_NotificationStatus_e
+    template<>
+    struct hash<org::genivi::am::am_NotificationStatus_e> {
+        inline size_t operator()(const org::genivi::am::am_NotificationStatus_e& am_NotificationStatus_e) const {
+            return static_cast<int32_t>(am_NotificationStatus_e);
+        }
+    };
+    //Hash for am_Handle_e
+    template<>
+    struct hash<org::genivi::am::am_Handle_e> {
+        inline size_t operator()(const org::genivi::am::am_Handle_e& am_Handle_e) const {
+            return static_cast<int32_t>(am_Handle_e);
+        }
+    };
+    //Hash for am_SourceState_e
+    template<>
+    struct hash<org::genivi::am::am_SourceState_e> {
+        inline size_t operator()(const org::genivi::am::am_SourceState_e& am_SourceState_e) const {
+            return static_cast<int32_t>(am_SourceState_e);
+        }
+    };
+    //Hash for am_RoutingReady_e
+    template<>
+    struct hash<org::genivi::am::am_RoutingReady_e> {
+        inline size_t operator()(const org::genivi::am::am_RoutingReady_e& am_RoutingReady_e) const {
+            return static_cast<int32_t>(am_RoutingReady_e);
+        }
+    };
+}
+
+#endif // ORG_GENIVI_am_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControl.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControl.h
new file mode 100644
index 0000000..41ad727
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControl.h
@@ -0,0 +1,63 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * This class implements everything from Audiomanager -&gt; RoutingAdapter
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_H_
+#define ORG_GENIVI_AM_Routing_Control_H_
+
+
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/types.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+class RoutingControl {
+ public:
+    virtual ~RoutingControl() { }
+
+    static inline const char* getInterfaceId();
+    static inline CommonAPI::Version getInterfaceVersion();
+};
+
+const char* RoutingControl::getInterfaceId() {
+    static const char* interfaceId = "org.genivi.am.RoutingControl";
+    return interfaceId;
+}
+
+CommonAPI::Version RoutingControl::getInterfaceVersion() {
+    return CommonAPI::Version(2, 0);
+}
+
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+namespace CommonAPI {
+
+}
+
+
+namespace std {
+    //hashes for types
+
+    //hashes for error types
+}
+
+#endif // ORG_GENIVI_AM_Routing_Control_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.cpp
new file mode 100644
index 0000000..6ebe6b5
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.cpp
@@ -0,0 +1,407 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * This class implements everything from Audiomanager -&gt; RoutingAdapter
+ * @author Christian Mueller
+ */
+#include "RoutingControlDBusProxy.h"
+
+namespace org {
+namespace genivi {
+namespace am {
+
+std::shared_ptr<CommonAPI::DBus::DBusProxy> createRoutingControlDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection) {
+    return std::make_shared<RoutingControlDBusProxy>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection);
+}
+
+INITIALIZER(registerRoutingControlDBusProxy) {
+    CommonAPI::DBus::DBusFactory::registerProxyFactoryMethod(RoutingControl::getInterfaceId(),
+       &createRoutingControlDBusProxy);
+}
+
+RoutingControlDBusProxy::RoutingControlDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection):
+        CommonAPI::DBus::DBusProxy(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyconnection)
+    {
+    }
+
+
+
+/**
+ * aborts an asynchronous action.
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_NON_EXISTENT if handle was not found
+ */
+void RoutingControlDBusProxy::asyncAbort(const am_Handle_s& handle, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncAbort",
+        "(iq)",
+        handle,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncAbortAsync(const am_Handle_s& handle, AsyncAbortAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncAbort",
+        "(iq)",
+        handle, 
+        std::move(callback));
+}
+/**
+ * connects a source to a sink
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+ */
+void RoutingControlDBusProxy::asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t, am_sourceID_t, am_sinkID_t, am_CustomConnectionFormat_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncConnect",
+        "(iq)qqqq",
+        handle, connectionID, sourceID, sinkID, connectionFormat,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, AsyncConnectAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t, am_sourceID_t, am_sinkID_t, am_CustomConnectionFormat_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncConnect",
+        "(iq)qqqq",
+        handle, connectionID, sourceID, sinkID, connectionFormat, 
+        std::move(callback));
+}
+/**
+ * disconnect a connection with given connectionID
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+ */
+void RoutingControlDBusProxy::asyncDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncDisconnect",
+        "(iq)q",
+        handle, connectionID,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, AsyncDisconnectAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncDisconnect",
+        "(iq)q",
+        handle, connectionID, 
+        std::move(callback));
+}
+/**
+ * this method is used to set the volume of a sink. This function is used to drive
+ *  ramps, to mute or unmute or directly set the value. The difference is made
+ *  through the ramptype.
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_OUT_OF_RANGE if new volume is out of range
+ */
+void RoutingControlDBusProxy::asyncSetSinkVolume(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncSetSinkVolume",
+        "(iq)qnqn",
+        handle, sinkID, volume, ramp, time,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetSinkVolumeAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, AsyncSetSinkVolumeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncSetSinkVolume",
+        "(iq)qnqn",
+        handle, sinkID, volume, ramp, time, 
+        std::move(callback));
+}
+/**
+ * sets the volume of a source. This method is used to set the volume of a sink.
+ *  This function is used to drive ramps, to mute or unmute or directly set the
+ *  value. The difference is made through the ramptype.
+(at)return E_OK on
+ *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+ *  range.
+triggers the acknowledge ackSourceVolumeChange
+ */
+void RoutingControlDBusProxy::asyncSetSourceVolume(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncSetSourceVolume",
+        "(iq)qnqn",
+        handle, sourceID, volume, ramp, time,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetSourceVolumeAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, AsyncSetSourceVolumeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncSetSourceVolume",
+        "(iq)qnqn",
+        handle, sourceID, volume, ramp, time, 
+        std::move(callback));
+}
+/**
+ * This function is used to set the source state of a particular
+ *  source.
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+void RoutingControlDBusProxy::asyncSetSourceState(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_SourceState_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncSetSourceState",
+        "(iq)qi",
+        handle, sourceID, state,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_SourceState_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncSetSourceState",
+        "(iq)qi",
+        handle, sourceID, state, 
+        std::move(callback));
+}
+/**
+ * this function sets the sinksoundproperty.
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+void RoutingControlDBusProxy::asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_SoundProperty_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncSetSinkSoundProperties",
+        "(iq)qa(qn)",
+        handle, sinkID, listSoundProperties,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_SoundProperty_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncSetSinkSoundProperties",
+        "(iq)qa(qn)",
+        handle, sinkID, listSoundProperties, 
+        std::move(callback));
+}
+/**
+ * this function sets the sinksoundproperty.
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+void RoutingControlDBusProxy::asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_SoundProperty_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncSetSinkSoundProperty",
+        "(iq)q(qn)",
+        handle, sinkID, soundProperty,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, AsyncSetSinkSoundPropertyAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_SoundProperty_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncSetSinkSoundProperty",
+        "(iq)q(qn)",
+        handle, sinkID, soundProperty, 
+        std::move(callback));
+}
+/**
+ * this function sets the sourcesoundproperty.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+void RoutingControlDBusProxy::asyncSetSourceSoundProperties(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_SoundProperty_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncSetSourceSoundProperties",
+        "(iq)qa(qn)",
+        handle, sourceID, listSoundProperties,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, AsyncSetSourceSoundPropertiesAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_SoundProperty_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncSetSourceSoundProperties",
+        "(iq)qa(qn)",
+        handle, sourceID, listSoundProperties, 
+        std::move(callback));
+}
+/**
+ * this function sets the sourcesoundproperty.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+void RoutingControlDBusProxy::asyncSetSourceSoundProperty(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_SoundProperty_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncSetSourceSoundProperty",
+        "(iq)q(qn)",
+        handle, sourceID, soundProperty,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, AsyncSetSourceSoundPropertyAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_SoundProperty_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncSetSourceSoundProperty",
+        "(iq)q(qn)",
+        handle, sourceID, soundProperty, 
+        std::move(callback));
+}
+/**
+ * this function triggers crossfading.
+(at)return E_OK on success, E_UNKNOWN on
+ *  error
+ */
+void RoutingControlDBusProxy::asyncCrossFade(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_CustomRampType_t& rampType, const am_time_t& time, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_crossfaderID_t, am_HotSink_e, am_CustomRampType_t, am_time_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncCrossFade",
+        "(iq)qiqn",
+        handle, crossfaderID, hotSink, rampType, time,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncCrossFadeAsync(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_CustomRampType_t& rampType, const am_time_t& time, AsyncCrossFadeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_crossfaderID_t, am_HotSink_e, am_CustomRampType_t, am_time_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncCrossFade",
+        "(iq)qiqn",
+        handle, crossfaderID, hotSink, rampType, time, 
+        std::move(callback));
+}
+/**
+ * this function is used for early and late audio functions to set the domain
+ *  state
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+void RoutingControlDBusProxy::setDomainState(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_DomainState_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "setDomainState",
+        "qi",
+        domainID, domainState,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::setDomainStateAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, SetDomainStateAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_DomainState_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "setDomainState",
+        "qi",
+        domainID, domainState, 
+        std::move(callback));
+}
+void RoutingControlDBusProxy::asyncSetVolumes(const am_Handle_s& handle, const am_Volumes_L& volumes, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Volumes_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncSetVolumes",
+        "(iq)a(i(yv)nqn)",
+        handle, volumes,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& volumes, AsyncSetVolumesAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Volumes_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncSetVolumes",
+        "(iq)a(i(yv)nqn)",
+        handle, volumes, 
+        std::move(callback));
+}
+void RoutingControlDBusProxy::asyncSetSinkNotificationConfiguration(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_NotificationConfiguration_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncSetSinkNotificationConfiguration",
+        "(iq)q(qin)",
+        handle, sinkID, notificationConfiguration,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSinkNotificationConfigurationAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_NotificationConfiguration_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncSetSinkNotificationConfiguration",
+        "(iq)q(qin)",
+        handle, sinkID, notificationConfiguration, 
+        std::move(callback));
+}
+void RoutingControlDBusProxy::asyncSetSourceNotificationConfiguration(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_NotificationConfiguration_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "asyncSetSourceNotificationConfiguration",
+        "(iq)q(qin)",
+        handle, sourceID, notificationConfiguration,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlDBusProxy::asyncSetSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSourceNotificationConfigurationAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_NotificationConfiguration_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "asyncSetSourceNotificationConfiguration",
+        "(iq)q(qin)",
+        handle, sourceID, notificationConfiguration, 
+        std::move(callback));
+}
+
+
+
+void RoutingControlDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
+    ownVersionMajor = 2;
+    ownVersionMinor = 0;
+}
+
+} // namespace am
+} // namespace genivi
+} // namespace org
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.h
new file mode 100644
index 0000000..468f939
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusProxy.h
@@ -0,0 +1,157 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * This class implements everything from Audiomanager -&gt; RoutingAdapter
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_DBUS_PROXY_H_
+#define ORG_GENIVI_AM_Routing_Control_DBUS_PROXY_H_
+
+#include <org/genivi/am/RoutingControlProxyBase.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/DBus/DBusFactory.h>
+#include <CommonAPI/DBus/DBusProxy.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+#include <string>
+
+namespace org {
+namespace genivi {
+namespace am {
+
+class RoutingControlDBusProxy: virtual public RoutingControlProxyBase, virtual public CommonAPI::DBus::DBusProxy {
+ public:
+    RoutingControlDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection);
+
+    virtual ~RoutingControlDBusProxy() { }
+
+
+
+    /**
+     * aborts an asynchronous action.
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_NON_EXISTENT if handle was not found
+     */
+    virtual void asyncAbort(const am_Handle_s& handle, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncAbortAsync(const am_Handle_s& handle, AsyncAbortAsyncCallback callback);
+    /**
+     * connects a source to a sink
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+     */
+    virtual void asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, AsyncConnectAsyncCallback callback);
+    /**
+     * disconnect a connection with given connectionID
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+     */
+    virtual void asyncDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, AsyncDisconnectAsyncCallback callback);
+    /**
+     * this method is used to set the volume of a sink. This function is used to drive
+     *  ramps, to mute or unmute or directly set the value. The difference is made
+     *  through the ramptype.
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_OUT_OF_RANGE if new volume is out of range
+     */
+    virtual void asyncSetSinkVolume(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncSetSinkVolumeAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, AsyncSetSinkVolumeAsyncCallback callback);
+    /**
+     * sets the volume of a source. This method is used to set the volume of a sink.
+     *  This function is used to drive ramps, to mute or unmute or directly set the
+     *  value. The difference is made through the ramptype.
+    (at)return E_OK on
+     *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+     *  range.
+    triggers the acknowledge ackSourceVolumeChange
+     */
+    virtual void asyncSetSourceVolume(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceVolumeAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, AsyncSetSourceVolumeAsyncCallback callback);
+    /**
+     * This function is used to set the source state of a particular
+     *  source.
+    (at)return E_OK on success, E_UNKNOWN on error
+     */
+    virtual void asyncSetSourceState(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback);
+    /**
+     * this function sets the sinksoundproperty.
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    virtual void asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback);
+    /**
+     * this function sets the sinksoundproperty.
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    virtual void asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, AsyncSetSinkSoundPropertyAsyncCallback callback);
+    /**
+     * this function sets the sourcesoundproperty.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    virtual void asyncSetSourceSoundProperties(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, AsyncSetSourceSoundPropertiesAsyncCallback callback);
+    /**
+     * this function sets the sourcesoundproperty.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    virtual void asyncSetSourceSoundProperty(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, AsyncSetSourceSoundPropertyAsyncCallback callback);
+    /**
+     * this function triggers crossfading.
+    (at)return E_OK on success, E_UNKNOWN on
+     *  error
+     */
+    virtual void asyncCrossFade(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_CustomRampType_t& rampType, const am_time_t& time, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncCrossFadeAsync(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_CustomRampType_t& rampType, const am_time_t& time, AsyncCrossFadeAsyncCallback callback);
+    /**
+     * this function is used for early and late audio functions to set the domain
+     *  state
+    (at)return E_OK on success, E_UNKNOWN on error
+     */
+    virtual void setDomainState(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> setDomainStateAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, SetDomainStateAsyncCallback callback);
+    virtual void asyncSetVolumes(const am_Handle_s& handle, const am_Volumes_L& volumes, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& volumes, AsyncSetVolumesAsyncCallback callback);
+    virtual void asyncSetSinkNotificationConfiguration(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncSetSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSinkNotificationConfigurationAsyncCallback callback);
+    virtual void asyncSetSourceNotificationConfiguration(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSourceNotificationConfigurationAsyncCallback callback);
+
+
+    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;
+
+ private:
+
+
+};
+
+
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Routing_Control_DBUS_PROXY_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.cpp
new file mode 100644
index 0000000..f08a30f
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.cpp
@@ -0,0 +1,477 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+#include "RoutingControlDBusStubAdapter.h"
+#include <org/genivi/am/RoutingControl.h>
+
+namespace org {
+namespace genivi {
+namespace am {
+
+std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createRoutingControlDBusStubAdapter(
+                   const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                   const std::string& commonApiAddress,
+                   const std::string& interfaceName,
+                   const std::string& busName,
+                   const std::string& objectPath,
+                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection,
+                   const std::shared_ptr<CommonAPI::StubBase>& stubBase) {
+    return std::make_shared<RoutingControlDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
+}
+
+INITIALIZER(registerRoutingControlDBusStubAdapter) {
+    CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(RoutingControl::getInterfaceId(),
+                                                               &createRoutingControlDBusStubAdapter);
+}
+
+
+
+RoutingControlDBusStubAdapterInternal::~RoutingControlDBusStubAdapterInternal() {
+    deactivateManagedInstances();
+    RoutingControlDBusStubAdapterHelper::deinit();
+}
+
+void RoutingControlDBusStubAdapterInternal::deactivateManagedInstances() {
+
+}
+
+const char* RoutingControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
+    static const std::string introspectionData =
+        "<method name=\"getInterfaceVersion\">\n"
+            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
+        "</method>\n"
+        /**
+         * aborts an asynchronous action.
+        (at)return E_OK on success, E_UNKNOWN on error,
+         *  E_NON_EXISTENT if handle was not found
+         */
+        "<method name=\"asyncAbort\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * connects a source to a sink
+        (at)return E_OK on success, E_UNKNOWN on error,
+         *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+         */
+        "<method name=\"asyncConnect\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"connectionID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"connectionFormat\" type=\"q\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * disconnect a connection with given connectionID
+        (at)return E_OK on success,
+         *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+         */
+        "<method name=\"asyncDisconnect\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"connectionID\" type=\"q\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * this method is used to set the volume of a sink. This function is used to drive
+         *  ramps, to mute or unmute or directly set the value. The difference is made
+         *  through the ramptype.
+        (at)return E_OK on success, E_UNKNOWN on error,
+         *  E_OUT_OF_RANGE if new volume is out of range
+         */
+        "<method name=\"asyncSetSinkVolume\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
+            "<arg name=\"ramp\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"time\" type=\"n\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * sets the volume of a source. This method is used to set the volume of a sink.
+         *  This function is used to drive ramps, to mute or unmute or directly set the
+         *  value. The difference is made through the ramptype.
+        (at)return E_OK on
+         *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+         *  range.
+        triggers the acknowledge ackSourceVolumeChange
+         */
+        "<method name=\"asyncSetSourceVolume\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
+            "<arg name=\"ramp\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"time\" type=\"n\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * This function is used to set the source state of a particular
+         *  source.
+        (at)return E_OK on success, E_UNKNOWN on error
+         */
+        "<method name=\"asyncSetSourceState\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"state\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * this function sets the sinksoundproperty.
+        (at)return E_OK on success, E_UNKNOWN
+         *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+         */
+        "<method name=\"asyncSetSinkSoundProperties\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"listSoundProperties\" type=\"a(qn)\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * this function sets the sinksoundproperty.
+        (at)return E_OK on success, E_UNKNOWN
+         *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+         */
+        "<method name=\"asyncSetSinkSoundProperty\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"soundProperty\" type=\"(qn)\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * this function sets the sourcesoundproperty.
+        (at)return E_OK on success,
+         *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+         */
+        "<method name=\"asyncSetSourceSoundProperties\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"listSoundProperties\" type=\"a(qn)\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * this function sets the sourcesoundproperty.
+        (at)return E_OK on success,
+         *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+         */
+        "<method name=\"asyncSetSourceSoundProperty\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"soundProperty\" type=\"(qn)\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * this function triggers crossfading.
+        (at)return E_OK on success, E_UNKNOWN on
+         *  error
+         */
+        "<method name=\"asyncCrossFade\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"crossfaderID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"hotSink\" type=\"i\" direction=\"in\" />\n"
+            "<arg name=\"rampType\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"time\" type=\"n\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * this function is used for early and late audio functions to set the domain
+         *  state
+        (at)return E_OK on success, E_UNKNOWN on error
+         */
+        "<method name=\"setDomainState\">\n"
+            "<arg name=\"domainID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"domainState\" type=\"i\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        "<method name=\"asyncSetVolumes\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"volumes\" type=\"a(i(yv)nqn)\" direction=\"in\" />\n"
+        "</method>\n"
+        "<method name=\"asyncSetSinkNotificationConfiguration\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"notificationConfiguration\" type=\"(qin)\" direction=\"in\" />\n"
+        "</method>\n"
+        "<method name=\"asyncSetSourceNotificationConfiguration\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"notificationConfiguration\" type=\"(qin)\" direction=\"in\" />\n"
+        "</method>\n"
+
+    ;
+    return introspectionData.c_str();
+}
+
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        RoutingControlStub,
+        CommonAPI::Version
+        > RoutingControlDBusStubAdapterInternal::getRoutingControlInterfaceVersionStubDispatcher(&RoutingControlStub::getInterfaceVersion, "uu");
+
+
+
+/**
+ * aborts an asynchronous action.
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_NON_EXISTENT if handle was not found
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncAbortStubDispatcher(&RoutingControlStub::asyncAbort, "");
+/**
+ * connects a source to a sink
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_connectionID_t, am_sourceID_t, am_sinkID_t, am_CustomConnectionFormat_t>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncConnectStubDispatcher(&RoutingControlStub::asyncConnect, "");
+/**
+ * disconnect a connection with given connectionID
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_connectionID_t>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncDisconnectStubDispatcher(&RoutingControlStub::asyncDisconnect, "");
+/**
+ * this method is used to set the volume of a sink. This function is used to drive
+ *  ramps, to mute or unmute or directly set the value. The difference is made
+ *  through the ramptype.
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_OUT_OF_RANGE if new volume is out of range
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncSetSinkVolumeStubDispatcher(&RoutingControlStub::asyncSetSinkVolume, "");
+/**
+ * sets the volume of a source. This method is used to set the volume of a sink.
+ *  This function is used to drive ramps, to mute or unmute or directly set the
+ *  value. The difference is made through the ramptype.
+(at)return E_OK on
+ *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+ *  range.
+triggers the acknowledge ackSourceVolumeChange
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncSetSourceVolumeStubDispatcher(&RoutingControlStub::asyncSetSourceVolume, "");
+/**
+ * This function is used to set the source state of a particular
+ *  source.
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_SourceState_e>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncSetSourceStateStubDispatcher(&RoutingControlStub::asyncSetSourceState, "");
+/**
+ * this function sets the sinksoundproperty.
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_SoundProperty_L>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncSetSinkSoundPropertiesStubDispatcher(&RoutingControlStub::asyncSetSinkSoundProperties, "");
+/**
+ * this function sets the sinksoundproperty.
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_SoundProperty_s>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncSetSinkSoundPropertyStubDispatcher(&RoutingControlStub::asyncSetSinkSoundProperty, "");
+/**
+ * this function sets the sourcesoundproperty.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_SoundProperty_L>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncSetSourceSoundPropertiesStubDispatcher(&RoutingControlStub::asyncSetSourceSoundProperties, "");
+/**
+ * this function sets the sourcesoundproperty.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_SoundProperty_s>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncSetSourceSoundPropertyStubDispatcher(&RoutingControlStub::asyncSetSourceSoundProperty, "");
+/**
+ * this function triggers crossfading.
+(at)return E_OK on success, E_UNKNOWN on
+ *  error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_crossfaderID_t, am_HotSink_e, am_CustomRampType_t, am_time_t>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncCrossFadeStubDispatcher(&RoutingControlStub::asyncCrossFade, "");
+/**
+ * this function is used for early and late audio functions to set the domain
+ *  state
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_domainID_t, am_DomainState_e>,
+    std::tuple<am_Error_e>
+    > RoutingControlDBusStubAdapterInternal::setDomainStateStubDispatcher(&RoutingControlStub::setDomainState, "i");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_Volumes_L>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncSetVolumesStubDispatcher(&RoutingControlStub::asyncSetVolumes, "");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_NotificationConfiguration_s>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncSetSinkNotificationConfigurationStubDispatcher(&RoutingControlStub::asyncSetSinkNotificationConfiguration, "");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_NotificationConfiguration_s>,
+    std::tuple<>
+    > RoutingControlDBusStubAdapterInternal::asyncSetSourceNotificationConfigurationStubDispatcher(&RoutingControlStub::asyncSetSourceNotificationConfiguration, "");
+
+
+
+
+
+const RoutingControlDBusStubAdapterHelper::StubDispatcherTable& RoutingControlDBusStubAdapterInternal::getStubDispatcherTable() {
+    return stubDispatcherTable_;
+}
+
+const CommonAPI::DBus::StubAttributeTable& RoutingControlDBusStubAdapterInternal::getStubAttributeTable() {
+    return stubAttributeTable_;
+}
+
+RoutingControlDBusStubAdapterInternal::RoutingControlDBusStubAdapterInternal(
+        const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+        const std::string& commonApiAddress,
+        const std::string& dbusInterfaceName,
+        const std::string& dbusBusName,
+        const std::string& dbusObjectPath,
+        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+        const std::shared_ptr<CommonAPI::StubBase>& stub):
+        CommonAPI::DBus::DBusStubAdapter(
+                factory,
+                commonApiAddress,
+                dbusInterfaceName,
+                dbusBusName,
+                dbusObjectPath,
+                dbusConnection,
+                false),
+        RoutingControlDBusStubAdapterHelper(
+            factory,
+            commonApiAddress,
+            dbusInterfaceName,
+            dbusBusName,
+            dbusObjectPath,
+            dbusConnection,
+            std::dynamic_pointer_cast<RoutingControlStub>(stub),
+            false),
+        stubDispatcherTable_({
+            /**
+             * aborts an asynchronous action.
+            (at)return E_OK on success, E_UNKNOWN on error,
+             *  E_NON_EXISTENT if handle was not found
+             */
+            { { "asyncAbort", "(iq)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncAbortStubDispatcher },
+            /**
+             * connects a source to a sink
+            (at)return E_OK on success, E_UNKNOWN on error,
+             *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+             */
+            { { "asyncConnect", "(iq)qqqq" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncConnectStubDispatcher },
+            /**
+             * disconnect a connection with given connectionID
+            (at)return E_OK on success,
+             *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+             */
+            { { "asyncDisconnect", "(iq)q" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncDisconnectStubDispatcher },
+            /**
+             * this method is used to set the volume of a sink. This function is used to drive
+             *  ramps, to mute or unmute or directly set the value. The difference is made
+             *  through the ramptype.
+            (at)return E_OK on success, E_UNKNOWN on error,
+             *  E_OUT_OF_RANGE if new volume is out of range
+             */
+            { { "asyncSetSinkVolume", "(iq)qnqn" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSinkVolumeStubDispatcher },
+            /**
+             * sets the volume of a source. This method is used to set the volume of a sink.
+             *  This function is used to drive ramps, to mute or unmute or directly set the
+             *  value. The difference is made through the ramptype.
+            (at)return E_OK on
+             *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+             *  range.
+            triggers the acknowledge ackSourceVolumeChange
+             */
+            { { "asyncSetSourceVolume", "(iq)qnqn" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSourceVolumeStubDispatcher },
+            /**
+             * This function is used to set the source state of a particular
+             *  source.
+            (at)return E_OK on success, E_UNKNOWN on error
+             */
+            { { "asyncSetSourceState", "(iq)qi" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSourceStateStubDispatcher },
+            /**
+             * this function sets the sinksoundproperty.
+            (at)return E_OK on success, E_UNKNOWN
+             *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+             */
+            { { "asyncSetSinkSoundProperties", "(iq)qa(qn)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSinkSoundPropertiesStubDispatcher },
+            /**
+             * this function sets the sinksoundproperty.
+            (at)return E_OK on success, E_UNKNOWN
+             *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+             */
+            { { "asyncSetSinkSoundProperty", "(iq)q(qn)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSinkSoundPropertyStubDispatcher },
+            /**
+             * this function sets the sourcesoundproperty.
+            (at)return E_OK on success,
+             *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+             */
+            { { "asyncSetSourceSoundProperties", "(iq)qa(qn)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSourceSoundPropertiesStubDispatcher },
+            /**
+             * this function sets the sourcesoundproperty.
+            (at)return E_OK on success,
+             *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+             */
+            { { "asyncSetSourceSoundProperty", "(iq)q(qn)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSourceSoundPropertyStubDispatcher },
+            /**
+             * this function triggers crossfading.
+            (at)return E_OK on success, E_UNKNOWN on
+             *  error
+             */
+            { { "asyncCrossFade", "(iq)qiqn" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncCrossFadeStubDispatcher },
+            /**
+             * this function is used for early and late audio functions to set the domain
+             *  state
+            (at)return E_OK on success, E_UNKNOWN on error
+             */
+            { { "setDomainState", "qi" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::setDomainStateStubDispatcher },
+            { { "asyncSetVolumes", "(iq)a(i(yv)nqn)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetVolumesStubDispatcher },
+            { { "asyncSetSinkNotificationConfiguration", "(iq)q(qin)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSinkNotificationConfigurationStubDispatcher },
+            { { "asyncSetSourceNotificationConfiguration", "(iq)q(qin)" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::asyncSetSourceNotificationConfigurationStubDispatcher }
+            }),
+        stubAttributeTable_() {
+
+    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::am::RoutingControlDBusStubAdapterInternal::getRoutingControlInterfaceVersionStubDispatcher });
+}
+
+const bool RoutingControlDBusStubAdapterInternal::hasFreedesktopProperties() {
+    return false;
+}
+
+} // namespace am
+} // namespace genivi
+} // namespace org
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.h
new file mode 100644
index 0000000..9ee7957
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlDBusStubAdapter.h
@@ -0,0 +1,250 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * This class implements everything from Audiomanager -&gt; RoutingAdapter
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_DBUS_STUB_ADAPTER_H_
+#define ORG_GENIVI_AM_Routing_Control_DBUS_STUB_ADAPTER_H_
+
+#include <org/genivi/am/RoutingControlStub.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/DBus/DBusStubAdapterHelper.h>
+#include <CommonAPI/DBus/DBusStubAdapter.h>
+#include <CommonAPI/DBus/DBusFactory.h>
+#include <CommonAPI/DBus/DBusServicePublisher.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+typedef CommonAPI::DBus::DBusStubAdapterHelper<RoutingControlStub> RoutingControlDBusStubAdapterHelper;
+
+class RoutingControlDBusStubAdapterInternal: public virtual RoutingControlStubAdapter, public RoutingControlDBusStubAdapterHelper {
+ public:
+    RoutingControlDBusStubAdapterInternal(
+            const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+            const std::string& commonApiAddress,
+            const std::string& dbusInterfaceName,
+            const std::string& dbusBusName,
+            const std::string& dbusObjectPath,
+            const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+            const std::shared_ptr<CommonAPI::StubBase>& stub);
+
+    ~RoutingControlDBusStubAdapterInternal();
+
+    virtual const bool hasFreedesktopProperties();
+
+
+
+
+    const RoutingControlDBusStubAdapterHelper::StubDispatcherTable& getStubDispatcherTable();
+    const CommonAPI::DBus::StubAttributeTable& getStubAttributeTable();
+
+    void deactivateManagedInstances();
+
+
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        RoutingControlStub,
+        CommonAPI::Version
+        > getRoutingControlInterfaceVersionStubDispatcher;
+
+
+
+/**
+ * aborts an asynchronous action.
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_NON_EXISTENT if handle was not found
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s>,
+    std::tuple<>
+    > asyncAbortStubDispatcher;
+/**
+ * connects a source to a sink
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_connectionID_t, am_sourceID_t, am_sinkID_t, am_CustomConnectionFormat_t>,
+    std::tuple<>
+    > asyncConnectStubDispatcher;
+/**
+ * disconnect a connection with given connectionID
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_connectionID_t>,
+    std::tuple<>
+    > asyncDisconnectStubDispatcher;
+/**
+ * this method is used to set the volume of a sink. This function is used to drive
+ *  ramps, to mute or unmute or directly set the value. The difference is made
+ *  through the ramptype.
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_OUT_OF_RANGE if new volume is out of range
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
+    std::tuple<>
+    > asyncSetSinkVolumeStubDispatcher;
+/**
+ * sets the volume of a source. This method is used to set the volume of a sink.
+ *  This function is used to drive ramps, to mute or unmute or directly set the
+ *  value. The difference is made through the ramptype.
+(at)return E_OK on
+ *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+ *  range.
+triggers the acknowledge ackSourceVolumeChange
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
+    std::tuple<>
+    > asyncSetSourceVolumeStubDispatcher;
+/**
+ * This function is used to set the source state of a particular
+ *  source.
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_SourceState_e>,
+    std::tuple<>
+    > asyncSetSourceStateStubDispatcher;
+/**
+ * this function sets the sinksoundproperty.
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_SoundProperty_L>,
+    std::tuple<>
+    > asyncSetSinkSoundPropertiesStubDispatcher;
+/**
+ * this function sets the sinksoundproperty.
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_SoundProperty_s>,
+    std::tuple<>
+    > asyncSetSinkSoundPropertyStubDispatcher;
+/**
+ * this function sets the sourcesoundproperty.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_SoundProperty_L>,
+    std::tuple<>
+    > asyncSetSourceSoundPropertiesStubDispatcher;
+/**
+ * this function sets the sourcesoundproperty.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_SoundProperty_s>,
+    std::tuple<>
+    > asyncSetSourceSoundPropertyStubDispatcher;
+/**
+ * this function triggers crossfading.
+(at)return E_OK on success, E_UNKNOWN on
+ *  error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_crossfaderID_t, am_HotSink_e, am_CustomRampType_t, am_time_t>,
+    std::tuple<>
+    > asyncCrossFadeStubDispatcher;
+/**
+ * this function is used for early and late audio functions to set the domain
+ *  state
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_domainID_t, am_DomainState_e>,
+    std::tuple<am_Error_e>
+    > setDomainStateStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_Volumes_L>,
+    std::tuple<>
+    > asyncSetVolumesStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_NotificationConfiguration_s>,
+    std::tuple<>
+    > asyncSetSinkNotificationConfigurationStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_NotificationConfiguration_s>,
+    std::tuple<>
+    > asyncSetSourceNotificationConfigurationStubDispatcher;
+
+
+
+
+ protected:
+    virtual const char* getMethodsDBusIntrospectionXmlData() const;
+
+ private:
+    RoutingControlDBusStubAdapterHelper::StubDispatcherTable stubDispatcherTable_;
+    CommonAPI::DBus::StubAttributeTable stubAttributeTable_;
+};
+
+class RoutingControlDBusStubAdapter: public RoutingControlDBusStubAdapterInternal, public std::enable_shared_from_this<RoutingControlDBusStubAdapter> {
+public:
+    RoutingControlDBusStubAdapter(
+                         const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                         const std::string& commonApiAddress,
+                         const std::string& dbusInterfaceName,
+                         const std::string& dbusBusName,
+                         const std::string& dbusObjectPath,
+                         const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+                         const std::shared_ptr<CommonAPI::StubBase>& stub) :
+            CommonAPI::DBus::DBusStubAdapter(
+                            factory,
+                            commonApiAddress,
+                            dbusInterfaceName,
+                            dbusBusName,
+                            dbusObjectPath,
+                            dbusConnection,
+                            false),
+            RoutingControlDBusStubAdapterInternal(
+                            factory,
+                            commonApiAddress,
+                            dbusInterfaceName,
+                            dbusBusName,
+                            dbusObjectPath,
+                            dbusConnection,
+                            stub) { }
+};
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Routing_Control_DBUS_STUB_ADAPTER_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserver.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserver.h
new file mode 100644
index 0000000..7327326
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserver.h
@@ -0,0 +1,63 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * Routing Receive sendInterface description.
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_Observer_H_
+#define ORG_GENIVI_AM_Routing_Control_Observer_H_
+
+
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/types.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+class RoutingControlObserver {
+ public:
+    virtual ~RoutingControlObserver() { }
+
+    static inline const char* getInterfaceId();
+    static inline CommonAPI::Version getInterfaceVersion();
+};
+
+const char* RoutingControlObserver::getInterfaceId() {
+    static const char* interfaceId = "org.genivi.am.RoutingControlObserver";
+    return interfaceId;
+}
+
+CommonAPI::Version RoutingControlObserver::getInterfaceVersion() {
+    return CommonAPI::Version(2, 0);
+}
+
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+namespace CommonAPI {
+
+}
+
+
+namespace std {
+    //hashes for types
+
+    //hashes for error types
+}
+
+#endif // ORG_GENIVI_AM_Routing_Control_Observer_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.cpp
new file mode 100644
index 0000000..36d9ee2
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.cpp
@@ -0,0 +1,1135 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * Routing Receive sendInterface description.
+ * @author Christian Mueller
+ */
+#include "RoutingControlObserverDBusProxy.h"
+
+namespace org {
+namespace genivi {
+namespace am {
+
+std::shared_ptr<CommonAPI::DBus::DBusProxy> createRoutingControlObserverDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection) {
+    return std::make_shared<RoutingControlObserverDBusProxy>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection);
+}
+
+INITIALIZER(registerRoutingControlObserverDBusProxy) {
+    CommonAPI::DBus::DBusFactory::registerProxyFactoryMethod(RoutingControlObserver::getInterfaceId(),
+       &createRoutingControlObserverDBusProxy);
+}
+
+RoutingControlObserverDBusProxy::RoutingControlObserverDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection):
+        CommonAPI::DBus::DBusProxy(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyconnection)
+,routingReady_(*this, "onRoutingReadyAttributeChanged", "i", "getRoutingReadyAttribute")
+    {
+    }
+
+RoutingControlObserverDBusProxy::RoutingReadyAttribute& RoutingControlObserverDBusProxy::getRoutingReadyAttribute() {
+    return routingReady_;
+}
+
+
+/**
+ * acknowledges a asyncConnect
+ */
+void RoutingControlObserverDBusProxy::ackConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackConnect",
+        "(iq)qi",
+        handle, connectionID, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckConnectAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackConnect",
+        "(iq)qi",
+        handle, connectionID, error, 
+        std::move(callback));
+}
+/**
+ * acknowledges a asyncDisconnect
+ */
+void RoutingControlObserverDBusProxy::ackDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackDisconnect",
+        "(iq)qi",
+        handle, connectionID, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckDisconnectAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackDisconnect",
+        "(iq)qi",
+        handle, connectionID, error, 
+        std::move(callback));
+}
+/**
+ * acknowledges a asyncsetSinkVolume
+ */
+void RoutingControlObserverDBusProxy::ackSetSinkVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_volume_t, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackSetSinkVolumeChange",
+        "(iq)ni",
+        handle, volume, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSinkVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSinkVolumeChangeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_volume_t, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackSetSinkVolumeChange",
+        "(iq)ni",
+        handle, volume, error, 
+        std::move(callback));
+}
+/**
+ * acknowledges a asyncsetSourceVolume
+ */
+void RoutingControlObserverDBusProxy::ackSetSourceVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_volume_t, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackSetSourceVolumeChange",
+        "(iq)ni",
+        handle, volume, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSourceVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSourceVolumeChangeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_volume_t, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackSetSourceVolumeChange",
+        "(iq)ni",
+        handle, volume, error, 
+        std::move(callback));
+}
+/**
+ * acknowlegde for asyncSetSourceState
+ */
+void RoutingControlObserverDBusProxy::ackSetSourceState(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackSetSourceState",
+        "(iq)i",
+        handle, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSourceStateAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceStateAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackSetSourceState",
+        "(iq)i",
+        handle, error, 
+        std::move(callback));
+}
+/**
+ * acknowledges asyncSetSinkSoundProperties
+ */
+void RoutingControlObserverDBusProxy::ackSetSinkSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackSetSinkSoundProperties",
+        "(iq)i",
+        handle, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertiesAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackSetSinkSoundProperties",
+        "(iq)i",
+        handle, error, 
+        std::move(callback));
+}
+/**
+ * acknowledges asyncSetSinkSoundProperty
+ */
+void RoutingControlObserverDBusProxy::ackSetSinkSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackSetSinkSoundProperty",
+        "(iq)i",
+        handle, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertyAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackSetSinkSoundProperty",
+        "(iq)i",
+        handle, error, 
+        std::move(callback));
+}
+/**
+ * acknowledges asyncSetSourceSoundProperties
+ */
+void RoutingControlObserverDBusProxy::ackSetSourceSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackSetSourceSoundProperties",
+        "(iq)i",
+        handle, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertiesAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackSetSourceSoundProperties",
+        "(iq)i",
+        handle, error, 
+        std::move(callback));
+}
+/**
+ * acknowledges asyncSetSourceSoundProperty
+ */
+void RoutingControlObserverDBusProxy::ackSetSourceSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackSetSourceSoundProperty",
+        "(iq)i",
+        handle, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertyAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackSetSourceSoundProperty",
+        "(iq)i",
+        handle, error, 
+        std::move(callback));
+}
+/**
+ * acknowledges asyncCrossFade
+ */
+void RoutingControlObserverDBusProxy::ackCrossFading(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_HotSink_e, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackCrossFading",
+        "(iq)ii",
+        handle, hotSink, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackCrossFadingAsync(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, AckCrossFadingAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_HotSink_e, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackCrossFading",
+        "(iq)ii",
+        handle, hotSink, error, 
+        std::move(callback));
+}
+/**
+ * acknowledges a volume tick. This can be used to display volumechanges during
+ *  ramps
+ */
+void RoutingControlObserverDBusProxy::ackSourceVolumeTick(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_volume_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackSourceVolumeTick",
+        "(iq)qn",
+        handle, sourceID, volume,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSourceVolumeTickAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_volume_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackSourceVolumeTick",
+        "(iq)qn",
+        handle, sourceID, volume, 
+        std::move(callback));
+}
+/**
+ * acknowledges a volume tick. This can be used to display volumechanges during
+ *  ramps
+ */
+void RoutingControlObserverDBusProxy::ackSinkVolumeTick(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_volume_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackSinkVolumeTick",
+        "(iq)qn",
+        handle, sinkID, volume,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSinkVolumeTickAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_volume_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackSinkVolumeTick",
+        "(iq)qn",
+        handle, sinkID, volume, 
+        std::move(callback));
+}
+/**
+ * This function returns the ID to the given domainName. If already a domain is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the domain. The other parameters of the domain
+ *  will be overwritten when the domain is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+void RoutingControlObserverDBusProxy::peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "peekDomain",
+        "s",
+        name,
+        callStatus
+        , domainID, error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "peekDomain",
+        "s",
+        name, 
+        std::move(callback));
+}
+/**
+ * registers a domain
+(at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+void RoutingControlObserverDBusProxy::registerDomain(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Domain_s, std::string, std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "registerDomain",
+        "(qsssbbi)ss",
+        domainData, returnBusname, returnInterface,
+        callStatus
+        , domainID, error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerDomainAsync(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, RegisterDomainAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Domain_s, std::string, std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "registerDomain",
+        "(qsssbbi)ss",
+        domainData, returnBusname, returnInterface, 
+        std::move(callback));
+}
+/**
+ * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+ *  domain will be removed as well.
+(at)return E_OK on succes, E_NON_EXISTENT if
+ *  not found E_UNKOWN on error
+ */
+void RoutingControlObserverDBusProxy::deregisterDomain(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "deregisterDomain",
+        "q",
+        domainID,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterDomainAsync(const am_domainID_t& domainID, DeregisterDomainAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "deregisterDomain",
+        "q",
+        domainID, 
+        std::move(callback));
+}
+/**
+ * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+void RoutingControlObserverDBusProxy::registerGateway(const am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gatewayID_t& gatewayID, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Gateway_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_gatewayID_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "registerGateway",
+        "(qsqqqqqaqaqab)",
+        gatewayData,
+        callStatus
+        , gatewayID, error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerGatewayAsync(const am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Gateway_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_gatewayID_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "registerGateway",
+        "(qsqqqqqaqaqab)",
+        gatewayData, 
+        std::move(callback));
+}
+/**
+ * registers a converter. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+void RoutingControlObserverDBusProxy::registerConverter(const am_Converter_s& converterData, CommonAPI::CallStatus& callStatus, am_converterID_t& converterID, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Converter_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_converterID_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "registerConverter",
+        "(qsqqqaqaqab)",
+        converterData,
+        callStatus
+        , converterID, error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerConverterAsync(const am_Converter_s& converterData, RegisterConverterAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Converter_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_converterID_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "registerConverter",
+        "(qsqqqaqaqab)",
+        converterData, 
+        std::move(callback));
+}
+/**
+ * deregisters a gateway. Also removes all sinks and sources of the controlling
+ *  domain.
+(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+ *  error
+ */
+void RoutingControlObserverDBusProxy::deregisterGateway(const am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_gatewayID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "deregisterGateway",
+        "q",
+        gatewayID,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterGatewayAsync(const am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_gatewayID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "deregisterGateway",
+        "q",
+        gatewayID, 
+        std::move(callback));
+}
+/**
+ * deregisters a converter. Also removes all sinks and sources of the controlling
+ *  domain.
+ */
+void RoutingControlObserverDBusProxy::deregisterConverter(const am_converterID_t& converterID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_converterID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "deregisterConverter",
+        "q",
+        converterID,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterConverterAsync(const am_converterID_t& converterID, DeregisterConverterAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_converterID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "deregisterConverter",
+        "q",
+        converterID, 
+        std::move(callback));
+}
+/**
+ * This function returns the ID to the given sinkName. If already a sink is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the sink. The other parameters of the sink will
+ *  be overwritten when the sink is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+void RoutingControlObserverDBusProxy::peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "peekSink",
+        "s",
+        name,
+        callStatus
+        , sinkID, error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "peekSink",
+        "s",
+        name, 
+        std::move(callback));
+}
+/**
+ * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+ *  is copied to the gatewayInformation
+(at)return E_OK on succes,
+ *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+ */
+void RoutingControlObserverDBusProxy::registerSink(const am_Sink_s& sinkData, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Sink_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "registerSink",
+        "(qsqqnb(iq)ina(qn)aqa(qn)a(qin)a(qin))",
+        sinkData,
+        callStatus
+        , sinkID, error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerSinkAsync(const am_Sink_s& sinkData, RegisterSinkAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Sink_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "registerSink",
+        "(qsqqnb(iq)ina(qn)aqa(qn)a(qin)a(qin))",
+        sinkData, 
+        std::move(callback));
+}
+/**
+ * deregisters a sink.
+(at)return E_OK on succes, E_NON_EXISTENT if not found
+ *  E_UNKOWN on error
+ */
+void RoutingControlObserverDBusProxy::deregisterSink(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "deregisterSink",
+        "q",
+        sinkID,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterSinkAsync(const am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "deregisterSink",
+        "q",
+        sinkID, 
+        std::move(callback));
+}
+/**
+ * This function returns the ID to the given sourceName. If already a source is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the source. The other parameters of the source
+ *  will be overwritten when the source is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+void RoutingControlObserverDBusProxy::peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "peekSource",
+        "s",
+        name,
+        callStatus
+        , sourceID, error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "peekSource",
+        "s",
+        name, 
+        std::move(callback));
+}
+/**
+ * registers a source.  If the source is part of a gateway, the
+ *  listconnectionFormats is copied to the gatewayInformation
+(at)return E_OK on
+ *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+ *  already exists
+ */
+void RoutingControlObserverDBusProxy::registerSource(const am_Source_s& sourceData, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Source_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "registerSource",
+        "(qqsqinb(iq)ia(qn)aqa(qn)a(qin)a(qin))",
+        sourceData,
+        callStatus
+        , sourceID, error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerSourceAsync(const am_Source_s& sourceData, RegisterSourceAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Source_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "registerSource",
+        "(qqsqinb(iq)ia(qn)aqa(qn)a(qin)a(qin))",
+        sourceData, 
+        std::move(callback));
+}
+/**
+ * deregisters a source
+(at)return E_OK on succes, E_NON_EXISTENT if not found
+ *  E_UNKOWN on error
+ */
+void RoutingControlObserverDBusProxy::deregisterSource(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "deregisterSource",
+        "q",
+        sourceID,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterSourceAsync(const am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "deregisterSource",
+        "q",
+        sourceID, 
+        std::move(callback));
+}
+/**
+ * this function registers a crossfader.
+(at)return E_OK on succes,
+ *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+ */
+void RoutingControlObserverDBusProxy::registerCrossfader(const am_Crossfader_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_crossfaderID_t& crossfaderID, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Crossfader_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_crossfaderID_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "registerCrossfader",
+        "(qsqqqi)",
+        crossfaderData,
+        callStatus
+        , crossfaderID, error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerCrossfaderAsync(const am_Crossfader_s& crossfaderData, RegisterCrossfaderAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Crossfader_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_crossfaderID_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "registerCrossfader",
+        "(qsqqqi)",
+        crossfaderData, 
+        std::move(callback));
+}
+/**
+ * this function deregisters a crossfader. removes all sources and sinks assiated
+ *  as well.
+(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+ *  error
+ */
+void RoutingControlObserverDBusProxy::deregisterCrossfader(const am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_crossfaderID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "deregisterCrossfader",
+        "q",
+        crossfaderID,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterCrossfaderAsync(const am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_crossfaderID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "deregisterCrossfader",
+        "q",
+        crossfaderID, 
+        std::move(callback));
+}
+/**
+ * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+ *  determine the SinkClassIDs of a sinkClass.
+(at)return E_OK on succes,
+ *  E_DATABASE_ERROR on error
+ */
+void RoutingControlObserverDBusProxy::peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceClass_t& sourceClassID, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_sourceClass_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "peekSourceClassID",
+        "s",
+        name,
+        callStatus
+        , sourceClassID, error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_sourceClass_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "peekSourceClassID",
+        "s",
+        name, 
+        std::move(callback));
+}
+/**
+ * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+ *  determine the SinkClassIDs of a sinkClass.
+(at)return E_OK on succes,
+ *  E_DATABASE_ERROR on error
+ */
+void RoutingControlObserverDBusProxy::peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkClass_t& sinkClassID, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_sinkClass_t, am_Error_e> >::callMethodWithReply(
+        *this,
+        "peekSinkClassID",
+        "s",
+        name,
+        callStatus
+        , sinkClassID, error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_sinkClass_t, am_Error_e> >::callMethodAsync(
+        *this,
+        "peekSinkClassID",
+        "s",
+        name, 
+        std::move(callback));
+}
+/**
+ * is called when a low level interrupt changes it status.
+ */
+void RoutingControlObserverDBusProxy::hookInterruptStatusChange(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_InterruptState_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "hookInterruptStatusChange",
+        "qi",
+        sourceID, interruptState,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookInterruptStatusChangeAsync(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, HookInterruptStatusChangeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_InterruptState_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "hookInterruptStatusChange",
+        "qi",
+        sourceID, interruptState, 
+        std::move(callback));
+}
+/**
+ * This hook is called when all elements from a domain are registered.
+Is used by
+ *  the Controller to know when all expected domains are finally registered
+ */
+void RoutingControlObserverDBusProxy::hookDomainRegistrationComplete(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "hookDomainRegistrationComplete",
+        "q",
+        domainID,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookDomainRegistrationCompleteAsync(const am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "hookDomainRegistrationComplete",
+        "q",
+        domainID, 
+        std::move(callback));
+}
+/**
+ * is called when a sink changes its availability
+ */
+void RoutingControlObserverDBusProxy::hookSinkAvailablityStatusChange(const am_sinkID_t& sinkID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Availability_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "hookSinkAvailablityStatusChange",
+        "q(iq)",
+        sinkID, availability,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookSinkAvailablityStatusChangeAsync(const am_sinkID_t& sinkID, const am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Availability_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "hookSinkAvailablityStatusChange",
+        "q(iq)",
+        sinkID, availability, 
+        std::move(callback));
+}
+/**
+ * is called when a source changes its availability
+ */
+void RoutingControlObserverDBusProxy::hookSourceAvailablityStatusChange(const am_sourceID_t& sourceID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Availability_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "hookSourceAvailablityStatusChange",
+        "q(iq)",
+        sourceID, availability,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookSourceAvailablityStatusChangeAsync(const am_sourceID_t& sourceID, const am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Availability_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "hookSourceAvailablityStatusChange",
+        "q(iq)",
+        sourceID, availability, 
+        std::move(callback));
+}
+/**
+ * is called when a domain changes its status. This used for early domains only
+ */
+void RoutingControlObserverDBusProxy::hookDomainStateChange(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_DomainState_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "hookDomainStateChange",
+        "qi",
+        domainID, domainState,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookDomainStateChangeAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_DomainState_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "hookDomainStateChange",
+        "qi",
+        domainID, domainState, 
+        std::move(callback));
+}
+/**
+ * is called when the timinginformation (delay) changed for a connection.
+ */
+void RoutingControlObserverDBusProxy::hookTimingInformationChanged(const am_connectionID_t& connectionID, const am_timeSync_t& delay, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_connectionID_t, am_timeSync_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "hookTimingInformationChanged",
+        "qn",
+        connectionID, delay,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookTimingInformationChangedAsync(const am_connectionID_t& connectionID, const am_timeSync_t& delay, HookTimingInformationChangedAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_connectionID_t, am_timeSync_t>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "hookTimingInformationChanged",
+        "qn",
+        connectionID, delay, 
+        std::move(callback));
+}
+/**
+ * this function is used to send out all data that has been changed in an early
+ *  state.
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+void RoutingControlObserverDBusProxy::sendChangedData(const am_EarlyData_L& earlyData, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_EarlyData_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "sendChangedData",
+        "a(i(yv)(yv))",
+        earlyData,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::sendChangedDataAsync(const am_EarlyData_L& earlyData, SendChangedDataAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_EarlyData_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "sendChangedData",
+        "a(i(yv)(yv))",
+        earlyData, 
+        std::move(callback));
+}
+/**
+ * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  gatewayID is not valid.
+ */
+void RoutingControlObserverDBusProxy::updateGateway(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_gatewayID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "updateGateway",
+        "qaqaqab",
+        gatewayID, listSourceFormats, listSinkFormats, convertionMatrix,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::updateGatewayAsync(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateGatewayAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_gatewayID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "updateGateway",
+        "qaqaqab",
+        gatewayID, listSourceFormats, listSinkFormats, convertionMatrix, 
+        std::move(callback));
+}
+/**
+ * updates data of an converter. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  converterID is not valid.
+ */
+void RoutingControlObserverDBusProxy::updateConverter(const am_converterID_t& converterID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_converterID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "updateConverter",
+        "qaqaqab",
+        converterID, listSourceFormats, listSinkFormats, convertionMatrix,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::updateConverterAsync(const am_converterID_t& converterID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateConverterAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_converterID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "updateConverter",
+        "qaqaqab",
+        converterID, listSourceFormats, listSinkFormats, convertionMatrix, 
+        std::move(callback));
+}
+/**
+ * updates data of an sink. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  sinkID is not valid.
+ */
+void RoutingControlObserverDBusProxy::updateSink(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_sinkClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "updateSink",
+        "qqa(qn)aqa(qn)",
+        sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::updateSinkAsync(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_sinkClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "updateSink",
+        "qqa(qn)aqa(qn)",
+        sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, 
+        std::move(callback));
+}
+/**
+ * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  sourceID in the struct is not valid. 
+Please note that only the following data
+ *  out of am_Source_s have effect when they are
+ *  changed:
+sourceClassID,
+listSoundProperties,
+listConnectionFormats,
+ * 
+listMainSoundProperties
+ */
+void RoutingControlObserverDBusProxy::updateSource(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_sourceClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
+        *this,
+        "updateSource",
+        "qqa(qn)aqa(qn)",
+        sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties,
+        callStatus
+        , error);
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::updateSourceAsync(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_sourceClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
+                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
+        *this,
+        "updateSource",
+        "qqa(qn)aqa(qn)",
+        sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, 
+        std::move(callback));
+}
+/**
+ * acknowledges a asyncSetSinkVolumes
+ */
+void RoutingControlObserverDBusProxy::ackSetVolumes(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Volumes_L, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackSetVolumes",
+        "(iq)a(i(yv)nqn)i",
+        handle, listvolumes, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, AckSetVolumesAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Volumes_L, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackSetVolumes",
+        "(iq)a(i(yv)nqn)i",
+        handle, listvolumes, error, 
+        std::move(callback));
+}
+/**
+ * The acknowledge of the SinkNotificationConfiguration
+ */
+void RoutingControlObserverDBusProxy::ackSinkNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackSinkNotificationConfiguration",
+        "(iq)i",
+        handle, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSinkNotificationConfigurationAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackSinkNotificationConfiguration",
+        "(iq)i",
+        handle, error, 
+        std::move(callback));
+}
+/**
+ * The acknowledge of the SourceNotificationConfiguration
+ */
+void RoutingControlObserverDBusProxy::ackSourceNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "ackSourceNotificationConfiguration",
+        "(iq)i",
+        handle, error,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSourceNotificationConfigurationAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "ackSourceNotificationConfiguration",
+        "(iq)i",
+        handle, error, 
+        std::move(callback));
+}
+/**
+ * is called whenever a notified value needs to be send
+ */
+void RoutingControlObserverDBusProxy::hookSinkNotificationDataChange(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_NotificationPayload_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "hookSinkNotificationDataChange",
+        "q(qn)",
+        sinkID, payload,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookSinkNotificationDataChangeAsync(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_NotificationPayload_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "hookSinkNotificationDataChange",
+        "q(qn)",
+        sinkID, payload, 
+        std::move(callback));
+}
+/**
+ * is called whenever a notified value needs to be send
+ */
+void RoutingControlObserverDBusProxy::hookSourceNotificationDataChange(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_NotificationPayload_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "hookSourceNotificationDataChange",
+        "q(qn)",
+        sourceID, payload,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookSourceNotificationDataChangeAsync(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_NotificationPayload_s>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "hookSourceNotificationDataChange",
+        "q(qn)",
+        sourceID, payload, 
+        std::move(callback));
+}
+void RoutingControlObserverDBusProxy::confirmRoutingRundown(const std::string& domainName, CommonAPI::CallStatus& callStatus) {
+    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
+        *this,
+        "confirmRoutingRundown",
+        "s",
+        domainName,
+        callStatus
+        );
+}
+std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::confirmRoutingRundownAsync(const std::string& domainName, ConfirmRoutingRundownAsyncCallback callback) {
+    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
+                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
+        *this,
+        "confirmRoutingRundown",
+        "s",
+        domainName, 
+        std::move(callback));
+}
+
+
+
+void RoutingControlObserverDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
+    ownVersionMajor = 2;
+    ownVersionMinor = 0;
+}
+
+} // namespace am
+} // namespace genivi
+} // namespace org
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.h
new file mode 100644
index 0000000..c72d2cd
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusProxy.h
@@ -0,0 +1,357 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * Routing Receive sendInterface description.
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_Observer_DBUS_PROXY_H_
+#define ORG_GENIVI_AM_Routing_Control_Observer_DBUS_PROXY_H_
+
+#include <org/genivi/am/RoutingControlObserverProxyBase.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/DBus/DBusFactory.h>
+#include <CommonAPI/DBus/DBusProxy.h>
+#include <CommonAPI/DBus/DBusAttribute.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+#include <string>
+
+namespace org {
+namespace genivi {
+namespace am {
+
+class RoutingControlObserverDBusProxy: virtual public RoutingControlObserverProxyBase, virtual public CommonAPI::DBus::DBusProxy {
+ public:
+    RoutingControlObserverDBusProxy(
+                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                    const std::string& commonApiAddress,
+                    const std::string& interfaceName,
+                    const std::string& busName,
+                    const std::string& objectPath,
+                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection);
+
+    virtual ~RoutingControlObserverDBusProxy() { }
+
+    virtual RoutingReadyAttribute& getRoutingReadyAttribute();
+
+
+    /**
+     * acknowledges a asyncConnect
+     */
+    virtual void ackConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckConnectAsyncCallback callback);
+    /**
+     * acknowledges a asyncDisconnect
+     */
+    virtual void ackDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckDisconnectAsyncCallback callback);
+    /**
+     * acknowledges a asyncsetSinkVolume
+     */
+    virtual void ackSetSinkVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackSetSinkVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSinkVolumeChangeAsyncCallback callback);
+    /**
+     * acknowledges a asyncsetSourceVolume
+     */
+    virtual void ackSetSourceVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackSetSourceVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSourceVolumeChangeAsyncCallback callback);
+    /**
+     * acknowlegde for asyncSetSourceState
+     */
+    virtual void ackSetSourceState(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackSetSourceStateAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceStateAsyncCallback callback);
+    /**
+     * acknowledges asyncSetSinkSoundProperties
+     */
+    virtual void ackSetSinkSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertiesAsyncCallback callback);
+    /**
+     * acknowledges asyncSetSinkSoundProperty
+     */
+    virtual void ackSetSinkSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertyAsyncCallback callback);
+    /**
+     * acknowledges asyncSetSourceSoundProperties
+     */
+    virtual void ackSetSourceSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertiesAsyncCallback callback);
+    /**
+     * acknowledges asyncSetSourceSoundProperty
+     */
+    virtual void ackSetSourceSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertyAsyncCallback callback);
+    /**
+     * acknowledges asyncCrossFade
+     */
+    virtual void ackCrossFading(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackCrossFadingAsync(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, AckCrossFadingAsyncCallback callback);
+    /**
+     * acknowledges a volume tick. This can be used to display volumechanges during
+     *  ramps
+     */
+    virtual void ackSourceVolumeTick(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackSourceVolumeTickAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback);
+    /**
+     * acknowledges a volume tick. This can be used to display volumechanges during
+     *  ramps
+     */
+    virtual void ackSinkVolumeTick(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackSinkVolumeTickAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback);
+    /**
+     * This function returns the ID to the given domainName. If already a domain is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the domain. The other parameters of the domain
+     *  will be overwritten when the domain is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     */
+    virtual void peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback);
+    /**
+     * registers a domain
+    (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     */
+    virtual void registerDomain(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> registerDomainAsync(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, RegisterDomainAsyncCallback callback);
+    /**
+     * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+     *  domain will be removed as well.
+    (at)return E_OK on succes, E_NON_EXISTENT if
+     *  not found E_UNKOWN on error
+     */
+    virtual void deregisterDomain(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> deregisterDomainAsync(const am_domainID_t& domainID, DeregisterDomainAsyncCallback callback);
+    /**
+     * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     */
+    virtual void registerGateway(const am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gatewayID_t& gatewayID, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> registerGatewayAsync(const am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback);
+    /**
+     * registers a converter. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     */
+    virtual void registerConverter(const am_Converter_s& converterData, CommonAPI::CallStatus& callStatus, am_converterID_t& converterID, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> registerConverterAsync(const am_Converter_s& converterData, RegisterConverterAsyncCallback callback);
+    /**
+     * deregisters a gateway. Also removes all sinks and sources of the controlling
+     *  domain.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+     *  error
+     */
+    virtual void deregisterGateway(const am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> deregisterGatewayAsync(const am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback);
+    /**
+     * deregisters a converter. Also removes all sinks and sources of the controlling
+     *  domain.
+     */
+    virtual void deregisterConverter(const am_converterID_t& converterID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> deregisterConverterAsync(const am_converterID_t& converterID, DeregisterConverterAsyncCallback callback);
+    /**
+     * This function returns the ID to the given sinkName. If already a sink is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the sink. The other parameters of the sink will
+     *  be overwritten when the sink is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     */
+    virtual void peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback);
+    /**
+     * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+     *  is copied to the gatewayInformation
+    (at)return E_OK on succes,
+     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+     */
+    virtual void registerSink(const am_Sink_s& sinkData, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> registerSinkAsync(const am_Sink_s& sinkData, RegisterSinkAsyncCallback callback);
+    /**
+     * deregisters a sink.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found
+     *  E_UNKOWN on error
+     */
+    virtual void deregisterSink(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> deregisterSinkAsync(const am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback);
+    /**
+     * This function returns the ID to the given sourceName. If already a source is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the source. The other parameters of the source
+     *  will be overwritten when the source is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     */
+    virtual void peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback);
+    /**
+     * registers a source.  If the source is part of a gateway, the
+     *  listconnectionFormats is copied to the gatewayInformation
+    (at)return E_OK on
+     *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+     *  already exists
+     */
+    virtual void registerSource(const am_Source_s& sourceData, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> registerSourceAsync(const am_Source_s& sourceData, RegisterSourceAsyncCallback callback);
+    /**
+     * deregisters a source
+    (at)return E_OK on succes, E_NON_EXISTENT if not found
+     *  E_UNKOWN on error
+     */
+    virtual void deregisterSource(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> deregisterSourceAsync(const am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback);
+    /**
+     * this function registers a crossfader.
+    (at)return E_OK on succes,
+     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+     */
+    virtual void registerCrossfader(const am_Crossfader_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_crossfaderID_t& crossfaderID, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> registerCrossfaderAsync(const am_Crossfader_s& crossfaderData, RegisterCrossfaderAsyncCallback callback);
+    /**
+     * this function deregisters a crossfader. removes all sources and sinks assiated
+     *  as well.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+     *  error
+     */
+    virtual void deregisterCrossfader(const am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> deregisterCrossfaderAsync(const am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback);
+    /**
+     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+     *  determine the SinkClassIDs of a sinkClass.
+    (at)return E_OK on succes,
+     *  E_DATABASE_ERROR on error
+     */
+    virtual void peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceClass_t& sourceClassID, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback);
+    /**
+     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+     *  determine the SinkClassIDs of a sinkClass.
+    (at)return E_OK on succes,
+     *  E_DATABASE_ERROR on error
+     */
+    virtual void peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkClass_t& sinkClassID, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback);
+    /**
+     * is called when a low level interrupt changes it status.
+     */
+    virtual void hookInterruptStatusChange(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> hookInterruptStatusChangeAsync(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, HookInterruptStatusChangeAsyncCallback callback);
+    /**
+     * This hook is called when all elements from a domain are registered.
+    Is used by
+     *  the Controller to know when all expected domains are finally registered
+     */
+    virtual void hookDomainRegistrationComplete(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> hookDomainRegistrationCompleteAsync(const am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback);
+    /**
+     * is called when a sink changes its availability
+     */
+    virtual void hookSinkAvailablityStatusChange(const am_sinkID_t& sinkID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> hookSinkAvailablityStatusChangeAsync(const am_sinkID_t& sinkID, const am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback);
+    /**
+     * is called when a source changes its availability
+     */
+    virtual void hookSourceAvailablityStatusChange(const am_sourceID_t& sourceID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> hookSourceAvailablityStatusChangeAsync(const am_sourceID_t& sourceID, const am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback);
+    /**
+     * is called when a domain changes its status. This used for early domains only
+     */
+    virtual void hookDomainStateChange(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> hookDomainStateChangeAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback);
+    /**
+     * is called when the timinginformation (delay) changed for a connection.
+     */
+    virtual void hookTimingInformationChanged(const am_connectionID_t& connectionID, const am_timeSync_t& delay, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> hookTimingInformationChangedAsync(const am_connectionID_t& connectionID, const am_timeSync_t& delay, HookTimingInformationChangedAsyncCallback callback);
+    /**
+     * this function is used to send out all data that has been changed in an early
+     *  state.
+    (at)return E_OK on success, E_UNKNOWN on error
+     */
+    virtual void sendChangedData(const am_EarlyData_L& earlyData, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> sendChangedDataAsync(const am_EarlyData_L& earlyData, SendChangedDataAsyncCallback callback);
+    /**
+     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  gatewayID is not valid.
+     */
+    virtual void updateGateway(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> updateGatewayAsync(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateGatewayAsyncCallback callback);
+    /**
+     * updates data of an converter. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  converterID is not valid.
+     */
+    virtual void updateConverter(const am_converterID_t& converterID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> updateConverterAsync(const am_converterID_t& converterID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateConverterAsyncCallback callback);
+    /**
+     * updates data of an sink. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  sinkID is not valid.
+     */
+    virtual void updateSink(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> updateSinkAsync(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback);
+    /**
+     * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  sourceID in the struct is not valid. 
+    Please note that only the following data
+     *  out of am_Source_s have effect when they are
+     *  changed:
+    sourceClassID,
+    listSoundProperties,
+    listConnectionFormats,
+     * 
+    listMainSoundProperties
+     */
+    virtual void updateSource(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    virtual std::future<CommonAPI::CallStatus> updateSourceAsync(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback);
+    /**
+     * acknowledges a asyncSetSinkVolumes
+     */
+    virtual void ackSetVolumes(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, AckSetVolumesAsyncCallback callback);
+    /**
+     * The acknowledge of the SinkNotificationConfiguration
+     */
+    virtual void ackSinkNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSinkNotificationConfigurationAsyncCallback callback);
+    /**
+     * The acknowledge of the SourceNotificationConfiguration
+     */
+    virtual void ackSourceNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> ackSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSourceNotificationConfigurationAsyncCallback callback);
+    /**
+     * is called whenever a notified value needs to be send
+     */
+    virtual void hookSinkNotificationDataChange(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> hookSinkNotificationDataChangeAsync(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback);
+    /**
+     * is called whenever a notified value needs to be send
+     */
+    virtual void hookSourceNotificationDataChange(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> hookSourceNotificationDataChangeAsync(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback);
+    virtual void confirmRoutingRundown(const std::string& domainName, CommonAPI::CallStatus& callStatus);
+    virtual std::future<CommonAPI::CallStatus> confirmRoutingRundownAsync(const std::string& domainName, ConfirmRoutingRundownAsyncCallback callback);
+
+
+    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;
+
+ private:
+   CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<RoutingReadyAttribute>> routingReady_;
+
+
+};
+
+
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Routing_Control_Observer_DBUS_PROXY_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.cpp
new file mode 100644
index 0000000..b9475df
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.cpp
@@ -0,0 +1,1244 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+#include "RoutingControlObserverDBusStubAdapter.h"
+#include <org/genivi/am/RoutingControlObserver.h>
+
+namespace org {
+namespace genivi {
+namespace am {
+
+std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createRoutingControlObserverDBusStubAdapter(
+                   const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                   const std::string& commonApiAddress,
+                   const std::string& interfaceName,
+                   const std::string& busName,
+                   const std::string& objectPath,
+                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection,
+                   const std::shared_ptr<CommonAPI::StubBase>& stubBase) {
+    return std::make_shared<RoutingControlObserverDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
+}
+
+INITIALIZER(registerRoutingControlObserverDBusStubAdapter) {
+    CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(RoutingControlObserver::getInterfaceId(),
+                                                               &createRoutingControlObserverDBusStubAdapter);
+}
+
+
+
+RoutingControlObserverDBusStubAdapterInternal::~RoutingControlObserverDBusStubAdapterInternal() {
+    deactivateManagedInstances();
+    RoutingControlObserverDBusStubAdapterHelper::deinit();
+}
+
+void RoutingControlObserverDBusStubAdapterInternal::deactivateManagedInstances() {
+
+}
+
+const char* RoutingControlObserverDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
+    static const std::string introspectionData =
+        "<method name=\"getInterfaceVersion\">\n"
+            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
+        "</method>\n"
+        "<method name=\"getRoutingReadyAttribute\">\n"
+            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
+        "</method>\n"
+        "<signal name=\"onRoutingReadyAttributeChanged\">\n"
+            "<arg name=\"changedValue\" type=\"i\" />\n"
+        "</signal>\n"
+        /**
+         * acknowledges a asyncConnect
+         */
+        "<method name=\"ackConnect\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"connectionID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * acknowledges a asyncDisconnect
+         */
+        "<method name=\"ackDisconnect\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"connectionID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * acknowledges a asyncsetSinkVolume
+         */
+        "<method name=\"ackSetSinkVolumeChange\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * acknowledges a asyncsetSourceVolume
+         */
+        "<method name=\"ackSetSourceVolumeChange\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * acknowlegde for asyncSetSourceState
+         */
+        "<method name=\"ackSetSourceState\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * acknowledges asyncSetSinkSoundProperties
+         */
+        "<method name=\"ackSetSinkSoundProperties\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * acknowledges asyncSetSinkSoundProperty
+         */
+        "<method name=\"ackSetSinkSoundProperty\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * acknowledges asyncSetSourceSoundProperties
+         */
+        "<method name=\"ackSetSourceSoundProperties\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * acknowledges asyncSetSourceSoundProperty
+         */
+        "<method name=\"ackSetSourceSoundProperty\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * acknowledges asyncCrossFade
+         */
+        "<method name=\"ackCrossFading\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"hotSink\" type=\"i\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * acknowledges a volume tick. This can be used to display volumechanges during
+         *  ramps
+         */
+        "<method name=\"ackSourceVolumeTick\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * acknowledges a volume tick. This can be used to display volumechanges during
+         *  ramps
+         */
+        "<method name=\"ackSinkVolumeTick\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * This function returns the ID to the given domainName. If already a domain is
+         *  registered with this name, it will return the corresponding ID, if not it will
+         *  reserve an ID but not register the domain. The other parameters of the domain
+         *  will be overwritten when the domain is registered.
+        (at)return E_OK on success,
+         *  E_UNKNOWN on error
+         */
+        "<method name=\"peekDomain\">\n"
+            "<arg name=\"name\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"domainID\" type=\"q\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * registers a domain
+        (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+         *  registered E_UNKOWN on error
+         */
+        "<method name=\"registerDomain\">\n"
+            "<arg name=\"domainData\" type=\"(qsssbbi)\" direction=\"in\" />\n"
+            "<arg name=\"returnBusname\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"returnInterface\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"domainID\" type=\"q\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+         *  domain will be removed as well.
+        (at)return E_OK on succes, E_NON_EXISTENT if
+         *  not found E_UNKOWN on error
+         */
+        "<method name=\"deregisterDomain\">\n"
+            "<arg name=\"domainID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+         *  registered E_UNKOWN on error
+         */
+        "<method name=\"registerGateway\">\n"
+            "<arg name=\"gatewayData\" type=\"(qsqqqqqaqaqab)\" direction=\"in\" />\n"
+            "<arg name=\"gatewayID\" type=\"q\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * registers a converter. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+         *  registered E_UNKOWN on error
+         */
+        "<method name=\"registerConverter\">\n"
+            "<arg name=\"converterData\" type=\"(qsqqqaqaqab)\" direction=\"in\" />\n"
+            "<arg name=\"converterID\" type=\"q\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * deregisters a gateway. Also removes all sinks and sources of the controlling
+         *  domain.
+        (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+         *  error
+         */
+        "<method name=\"deregisterGateway\">\n"
+            "<arg name=\"gatewayID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * deregisters a converter. Also removes all sinks and sources of the controlling
+         *  domain.
+         */
+        "<method name=\"deregisterConverter\">\n"
+            "<arg name=\"converterID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * This function returns the ID to the given sinkName. If already a sink is
+         *  registered with this name, it will return the corresponding ID, if not it will
+         *  reserve an ID but not register the sink. The other parameters of the sink will
+         *  be overwritten when the sink is registered.
+        (at)return E_OK on success,
+         *  E_UNKNOWN on error
+         */
+        "<method name=\"peekSink\">\n"
+            "<arg name=\"name\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+         *  is copied to the gatewayInformation
+        (at)return E_OK on succes,
+         *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+         */
+        "<method name=\"registerSink\">\n"
+            "<arg name=\"sinkData\" type=\"(qsqqnb(iq)ina(qn)aqa(qn)a(qin)a(qin))\" direction=\"in\" />\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * deregisters a sink.
+        (at)return E_OK on succes, E_NON_EXISTENT if not found
+         *  E_UNKOWN on error
+         */
+        "<method name=\"deregisterSink\">\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * This function returns the ID to the given sourceName. If already a source is
+         *  registered with this name, it will return the corresponding ID, if not it will
+         *  reserve an ID but not register the source. The other parameters of the source
+         *  will be overwritten when the source is registered.
+        (at)return E_OK on success,
+         *  E_UNKNOWN on error
+         */
+        "<method name=\"peekSource\">\n"
+            "<arg name=\"name\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * registers a source.  If the source is part of a gateway, the
+         *  listconnectionFormats is copied to the gatewayInformation
+        (at)return E_OK on
+         *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+         *  already exists
+         */
+        "<method name=\"registerSource\">\n"
+            "<arg name=\"sourceData\" type=\"(qqsqinb(iq)ia(qn)aqa(qn)a(qin)a(qin))\" direction=\"in\" />\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * deregisters a source
+        (at)return E_OK on succes, E_NON_EXISTENT if not found
+         *  E_UNKOWN on error
+         */
+        "<method name=\"deregisterSource\">\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * this function registers a crossfader.
+        (at)return E_OK on succes,
+         *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+         */
+        "<method name=\"registerCrossfader\">\n"
+            "<arg name=\"crossfaderData\" type=\"(qsqqqi)\" direction=\"in\" />\n"
+            "<arg name=\"crossfaderID\" type=\"q\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * this function deregisters a crossfader. removes all sources and sinks assiated
+         *  as well.
+        (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+         *  error
+         */
+        "<method name=\"deregisterCrossfader\">\n"
+            "<arg name=\"crossfaderID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+         *  determine the SinkClassIDs of a sinkClass.
+        (at)return E_OK on succes,
+         *  E_DATABASE_ERROR on error
+         */
+        "<method name=\"peekSourceClassID\">\n"
+            "<arg name=\"name\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"sourceClassID\" type=\"q\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+         *  determine the SinkClassIDs of a sinkClass.
+        (at)return E_OK on succes,
+         *  E_DATABASE_ERROR on error
+         */
+        "<method name=\"peekSinkClassID\">\n"
+            "<arg name=\"name\" type=\"s\" direction=\"in\" />\n"
+            "<arg name=\"sinkClassID\" type=\"q\" direction=\"out\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * is called when a low level interrupt changes it status.
+         */
+        "<method name=\"hookInterruptStatusChange\">\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"interruptState\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * This hook is called when all elements from a domain are registered.
+        Is used by
+         *  the Controller to know when all expected domains are finally registered
+         */
+        "<method name=\"hookDomainRegistrationComplete\">\n"
+            "<arg name=\"domainID\" type=\"q\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * is called when a sink changes its availability
+         */
+        "<method name=\"hookSinkAvailablityStatusChange\">\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"availability\" type=\"(iq)\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * is called when a source changes its availability
+         */
+        "<method name=\"hookSourceAvailablityStatusChange\">\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"availability\" type=\"(iq)\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * is called when a domain changes its status. This used for early domains only
+         */
+        "<method name=\"hookDomainStateChange\">\n"
+            "<arg name=\"domainID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"domainState\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * is called when the timinginformation (delay) changed for a connection.
+         */
+        "<method name=\"hookTimingInformationChanged\">\n"
+            "<arg name=\"connectionID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"delay\" type=\"n\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * this function is used to send out all data that has been changed in an early
+         *  state.
+        (at)return E_OK on success, E_UNKNOWN on error
+         */
+        "<method name=\"sendChangedData\">\n"
+            "<arg name=\"earlyData\" type=\"a(i(yv)(yv))\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+         *  gatewayID is not valid.
+         */
+        "<method name=\"updateGateway\">\n"
+            "<arg name=\"gatewayID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"listSourceFormats\" type=\"aq\" direction=\"in\" />\n"
+            "<arg name=\"listSinkFormats\" type=\"aq\" direction=\"in\" />\n"
+            "<arg name=\"convertionMatrix\" type=\"ab\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * updates data of an converter. (at)return E_OK on success, E_NON_EXISTENT if the
+         *  converterID is not valid.
+         */
+        "<method name=\"updateConverter\">\n"
+            "<arg name=\"converterID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"listSourceFormats\" type=\"aq\" direction=\"in\" />\n"
+            "<arg name=\"listSinkFormats\" type=\"aq\" direction=\"in\" />\n"
+            "<arg name=\"convertionMatrix\" type=\"ab\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * updates data of an sink. (at)return E_OK on success, E_NON_EXISTENT if the
+         *  sinkID is not valid.
+         */
+        "<method name=\"updateSink\">\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"sinkClassID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"listSoundProperties\" type=\"a(qn)\" direction=\"in\" />\n"
+            "<arg name=\"listConnectionFormats\" type=\"aq\" direction=\"in\" />\n"
+            "<arg name=\"listMainSoundProperties\" type=\"a(qn)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+         *  sourceID in the struct is not valid. 
+        Please note that only the following data
+         *  out of am_Source_s have effect when they are
+         *  changed:
+        sourceClassID,
+        listSoundProperties,
+        listConnectionFormats,
+         * 
+        listMainSoundProperties
+         */
+        "<method name=\"updateSource\">\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"sourceClassID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"listSoundProperties\" type=\"a(qn)\" direction=\"in\" />\n"
+            "<arg name=\"listConnectionFormats\" type=\"aq\" direction=\"in\" />\n"
+            "<arg name=\"listMainSoundProperties\" type=\"a(qn)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
+        "</method>\n"
+        /**
+         * acknowledges a asyncSetSinkVolumes
+         */
+        "<method name=\"ackSetVolumes\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"listvolumes\" type=\"a(i(yv)nqn)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * The acknowledge of the SinkNotificationConfiguration
+         */
+        "<method name=\"ackSinkNotificationConfiguration\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * The acknowledge of the SourceNotificationConfiguration
+         */
+        "<method name=\"ackSourceNotificationConfiguration\">\n"
+            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
+            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * is called whenever a notified value needs to be send
+         */
+        "<method name=\"hookSinkNotificationDataChange\">\n"
+            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"payload\" type=\"(qn)\" direction=\"in\" />\n"
+        "</method>\n"
+        /**
+         * is called whenever a notified value needs to be send
+         */
+        "<method name=\"hookSourceNotificationDataChange\">\n"
+            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
+            "<arg name=\"payload\" type=\"(qn)\" direction=\"in\" />\n"
+        "</method>\n"
+        "<method name=\"confirmRoutingRundown\">\n"
+            "<arg name=\"domainName\" type=\"s\" direction=\"in\" />\n"
+        "</method>\n"
+
+    ;
+    return introspectionData.c_str();
+}
+
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        RoutingControlObserverStub,
+        CommonAPI::Version
+        > RoutingControlObserverDBusStubAdapterInternal::getRoutingControlObserverInterfaceVersionStubDispatcher(&RoutingControlObserverStub::getInterfaceVersion, "uu");
+
+/**
+ * This attribute signals to the clients the current routing state.
+A client
+ *  should notify himself to this attribute in order to know the current state and
+ *  act accordingly.
+ */
+CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        RoutingControlObserverStub,
+        am_RoutingReady_e
+        > RoutingControlObserverDBusStubAdapterInternal::getRoutingReadyAttributeStubDispatcher(&RoutingControlObserverStub::getRoutingReadyAttribute, "i");
+
+
+/**
+ * acknowledges a asyncConnect
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_connectionID_t, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackConnectStubDispatcher(&RoutingControlObserverStub::ackConnect, "");
+/**
+ * acknowledges a asyncDisconnect
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_connectionID_t, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackDisconnectStubDispatcher(&RoutingControlObserverStub::ackDisconnect, "");
+/**
+ * acknowledges a asyncsetSinkVolume
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_volume_t, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSinkVolumeChangeStubDispatcher(&RoutingControlObserverStub::ackSetSinkVolumeChange, "");
+/**
+ * acknowledges a asyncsetSourceVolume
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_volume_t, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSourceVolumeChangeStubDispatcher(&RoutingControlObserverStub::ackSetSourceVolumeChange, "");
+/**
+ * acknowlegde for asyncSetSourceState
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSourceStateStubDispatcher(&RoutingControlObserverStub::ackSetSourceState, "");
+/**
+ * acknowledges asyncSetSinkSoundProperties
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSinkSoundPropertiesStubDispatcher(&RoutingControlObserverStub::ackSetSinkSoundProperties, "");
+/**
+ * acknowledges asyncSetSinkSoundProperty
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSinkSoundPropertyStubDispatcher(&RoutingControlObserverStub::ackSetSinkSoundProperty, "");
+/**
+ * acknowledges asyncSetSourceSoundProperties
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSourceSoundPropertiesStubDispatcher(&RoutingControlObserverStub::ackSetSourceSoundProperties, "");
+/**
+ * acknowledges asyncSetSourceSoundProperty
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetSourceSoundPropertyStubDispatcher(&RoutingControlObserverStub::ackSetSourceSoundProperty, "");
+/**
+ * acknowledges asyncCrossFade
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_HotSink_e, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackCrossFadingStubDispatcher(&RoutingControlObserverStub::ackCrossFading, "");
+/**
+ * acknowledges a volume tick. This can be used to display volumechanges during
+ *  ramps
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_volume_t>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackSourceVolumeTickStubDispatcher(&RoutingControlObserverStub::ackSourceVolumeTick, "");
+/**
+ * acknowledges a volume tick. This can be used to display volumechanges during
+ *  ramps
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_volume_t>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackSinkVolumeTickStubDispatcher(&RoutingControlObserverStub::ackSinkVolumeTick, "");
+/**
+ * This function returns the ID to the given domainName. If already a domain is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the domain. The other parameters of the domain
+ *  will be overwritten when the domain is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_domainID_t, am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::peekDomainStubDispatcher(&RoutingControlObserverStub::peekDomain, "qi");
+/**
+ * registers a domain
+(at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Domain_s, std::string, std::string>,
+    std::tuple<am_domainID_t, am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::registerDomainStubDispatcher(&RoutingControlObserverStub::registerDomain, "qi");
+/**
+ * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+ *  domain will be removed as well.
+(at)return E_OK on succes, E_NON_EXISTENT if
+ *  not found E_UNKOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_domainID_t>,
+    std::tuple<am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::deregisterDomainStubDispatcher(&RoutingControlObserverStub::deregisterDomain, "i");
+/**
+ * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Gateway_s>,
+    std::tuple<am_gatewayID_t, am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::registerGatewayStubDispatcher(&RoutingControlObserverStub::registerGateway, "qi");
+/**
+ * registers a converter. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Converter_s>,
+    std::tuple<am_converterID_t, am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::registerConverterStubDispatcher(&RoutingControlObserverStub::registerConverter, "qi");
+/**
+ * deregisters a gateway. Also removes all sinks and sources of the controlling
+ *  domain.
+(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+ *  error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_gatewayID_t>,
+    std::tuple<am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::deregisterGatewayStubDispatcher(&RoutingControlObserverStub::deregisterGateway, "i");
+/**
+ * deregisters a converter. Also removes all sinks and sources of the controlling
+ *  domain.
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_converterID_t>,
+    std::tuple<am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::deregisterConverterStubDispatcher(&RoutingControlObserverStub::deregisterConverter, "i");
+/**
+ * This function returns the ID to the given sinkName. If already a sink is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the sink. The other parameters of the sink will
+ *  be overwritten when the sink is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_sinkID_t, am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::peekSinkStubDispatcher(&RoutingControlObserverStub::peekSink, "qi");
+/**
+ * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+ *  is copied to the gatewayInformation
+(at)return E_OK on succes,
+ *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Sink_s>,
+    std::tuple<am_sinkID_t, am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::registerSinkStubDispatcher(&RoutingControlObserverStub::registerSink, "qi");
+/**
+ * deregisters a sink.
+(at)return E_OK on succes, E_NON_EXISTENT if not found
+ *  E_UNKOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sinkID_t>,
+    std::tuple<am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::deregisterSinkStubDispatcher(&RoutingControlObserverStub::deregisterSink, "i");
+/**
+ * This function returns the ID to the given sourceName. If already a source is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the source. The other parameters of the source
+ *  will be overwritten when the source is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_sourceID_t, am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::peekSourceStubDispatcher(&RoutingControlObserverStub::peekSource, "qi");
+/**
+ * registers a source.  If the source is part of a gateway, the
+ *  listconnectionFormats is copied to the gatewayInformation
+(at)return E_OK on
+ *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+ *  already exists
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Source_s>,
+    std::tuple<am_sourceID_t, am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::registerSourceStubDispatcher(&RoutingControlObserverStub::registerSource, "qi");
+/**
+ * deregisters a source
+(at)return E_OK on succes, E_NON_EXISTENT if not found
+ *  E_UNKOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t>,
+    std::tuple<am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::deregisterSourceStubDispatcher(&RoutingControlObserverStub::deregisterSource, "i");
+/**
+ * this function registers a crossfader.
+(at)return E_OK on succes,
+ *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Crossfader_s>,
+    std::tuple<am_crossfaderID_t, am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::registerCrossfaderStubDispatcher(&RoutingControlObserverStub::registerCrossfader, "qi");
+/**
+ * this function deregisters a crossfader. removes all sources and sinks assiated
+ *  as well.
+(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+ *  error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_crossfaderID_t>,
+    std::tuple<am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::deregisterCrossfaderStubDispatcher(&RoutingControlObserverStub::deregisterCrossfader, "i");
+/**
+ * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+ *  determine the SinkClassIDs of a sinkClass.
+(at)return E_OK on succes,
+ *  E_DATABASE_ERROR on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_sourceClass_t, am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::peekSourceClassIDStubDispatcher(&RoutingControlObserverStub::peekSourceClassID, "qi");
+/**
+ * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+ *  determine the SinkClassIDs of a sinkClass.
+(at)return E_OK on succes,
+ *  E_DATABASE_ERROR on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_sinkClass_t, am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::peekSinkClassIDStubDispatcher(&RoutingControlObserverStub::peekSinkClassID, "qi");
+/**
+ * is called when a low level interrupt changes it status.
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t, am_InterruptState_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::hookInterruptStatusChangeStubDispatcher(&RoutingControlObserverStub::hookInterruptStatusChange, "");
+/**
+ * This hook is called when all elements from a domain are registered.
+Is used by
+ *  the Controller to know when all expected domains are finally registered
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_domainID_t>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::hookDomainRegistrationCompleteStubDispatcher(&RoutingControlObserverStub::hookDomainRegistrationComplete, "");
+/**
+ * is called when a sink changes its availability
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sinkID_t, am_Availability_s>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::hookSinkAvailablityStatusChangeStubDispatcher(&RoutingControlObserverStub::hookSinkAvailablityStatusChange, "");
+/**
+ * is called when a source changes its availability
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t, am_Availability_s>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::hookSourceAvailablityStatusChangeStubDispatcher(&RoutingControlObserverStub::hookSourceAvailablityStatusChange, "");
+/**
+ * is called when a domain changes its status. This used for early domains only
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_domainID_t, am_DomainState_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::hookDomainStateChangeStubDispatcher(&RoutingControlObserverStub::hookDomainStateChange, "");
+/**
+ * is called when the timinginformation (delay) changed for a connection.
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_connectionID_t, am_timeSync_t>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::hookTimingInformationChangedStubDispatcher(&RoutingControlObserverStub::hookTimingInformationChanged, "");
+/**
+ * this function is used to send out all data that has been changed in an early
+ *  state.
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_EarlyData_L>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::sendChangedDataStubDispatcher(&RoutingControlObserverStub::sendChangedData, "");
+/**
+ * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  gatewayID is not valid.
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_gatewayID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
+    std::tuple<am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::updateGatewayStubDispatcher(&RoutingControlObserverStub::updateGateway, "i");
+/**
+ * updates data of an converter. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  converterID is not valid.
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_converterID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
+    std::tuple<am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::updateConverterStubDispatcher(&RoutingControlObserverStub::updateConverter, "i");
+/**
+ * updates data of an sink. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  sinkID is not valid.
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sinkID_t, am_sinkClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
+    std::tuple<am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::updateSinkStubDispatcher(&RoutingControlObserverStub::updateSink, "i");
+/**
+ * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  sourceID in the struct is not valid. 
+Please note that only the following data
+ *  out of am_Source_s have effect when they are
+ *  changed:
+sourceClassID,
+listSoundProperties,
+listConnectionFormats,
+ * 
+listMainSoundProperties
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t, am_sourceClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
+    std::tuple<am_Error_e>
+    > RoutingControlObserverDBusStubAdapterInternal::updateSourceStubDispatcher(&RoutingControlObserverStub::updateSource, "i");
+/**
+ * acknowledges a asyncSetSinkVolumes
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Volumes_L, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackSetVolumesStubDispatcher(&RoutingControlObserverStub::ackSetVolumes, "");
+/**
+ * The acknowledge of the SinkNotificationConfiguration
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackSinkNotificationConfigurationStubDispatcher(&RoutingControlObserverStub::ackSinkNotificationConfiguration, "");
+/**
+ * The acknowledge of the SourceNotificationConfiguration
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::ackSourceNotificationConfigurationStubDispatcher(&RoutingControlObserverStub::ackSourceNotificationConfiguration, "");
+/**
+ * is called whenever a notified value needs to be send
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sinkID_t, am_NotificationPayload_s>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::hookSinkNotificationDataChangeStubDispatcher(&RoutingControlObserverStub::hookSinkNotificationDataChange, "");
+/**
+ * is called whenever a notified value needs to be send
+ */
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t, am_NotificationPayload_s>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::hookSourceNotificationDataChangeStubDispatcher(&RoutingControlObserverStub::hookSourceNotificationDataChange, "");
+CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<>
+    > RoutingControlObserverDBusStubAdapterInternal::confirmRoutingRundownStubDispatcher(&RoutingControlObserverStub::confirmRoutingRundown, "");
+
+
+/**
+ * This attribute signals to the clients the current routing state.
+A client
+ *  should notify himself to this attribute in order to know the current state and
+ *  act accordingly.
+ */
+void RoutingControlObserverDBusStubAdapterInternal::fireRoutingReadyAttributeChanged(const am_RoutingReady_e& value) {
+    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_RoutingReady_e>>
+        ::sendSignal(
+            *this,
+            "onRoutingReadyAttributeChanged",
+            "i",
+            value
+    );
+}
+
+
+
+const RoutingControlObserverDBusStubAdapterHelper::StubDispatcherTable& RoutingControlObserverDBusStubAdapterInternal::getStubDispatcherTable() {
+    return stubDispatcherTable_;
+}
+
+const CommonAPI::DBus::StubAttributeTable& RoutingControlObserverDBusStubAdapterInternal::getStubAttributeTable() {
+    return stubAttributeTable_;
+}
+
+RoutingControlObserverDBusStubAdapterInternal::RoutingControlObserverDBusStubAdapterInternal(
+        const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+        const std::string& commonApiAddress,
+        const std::string& dbusInterfaceName,
+        const std::string& dbusBusName,
+        const std::string& dbusObjectPath,
+        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+        const std::shared_ptr<CommonAPI::StubBase>& stub):
+        CommonAPI::DBus::DBusStubAdapter(
+                factory,
+                commonApiAddress,
+                dbusInterfaceName,
+                dbusBusName,
+                dbusObjectPath,
+                dbusConnection,
+                false),
+        RoutingControlObserverDBusStubAdapterHelper(
+            factory,
+            commonApiAddress,
+            dbusInterfaceName,
+            dbusBusName,
+            dbusObjectPath,
+            dbusConnection,
+            std::dynamic_pointer_cast<RoutingControlObserverStub>(stub),
+            false),
+        stubDispatcherTable_({
+            /**
+             * This attribute signals to the clients the current routing state.
+            A client
+             *  should notify himself to this attribute in order to know the current state and
+             *  act accordingly.
+             */
+            { { "getRoutingReadyAttribute", "" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::getRoutingReadyAttributeStubDispatcher }
+            ,
+            /**
+             * acknowledges a asyncConnect
+             */
+            { { "ackConnect", "(iq)qi" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackConnectStubDispatcher },
+            /**
+             * acknowledges a asyncDisconnect
+             */
+            { { "ackDisconnect", "(iq)qi" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackDisconnectStubDispatcher },
+            /**
+             * acknowledges a asyncsetSinkVolume
+             */
+            { { "ackSetSinkVolumeChange", "(iq)ni" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSinkVolumeChangeStubDispatcher },
+            /**
+             * acknowledges a asyncsetSourceVolume
+             */
+            { { "ackSetSourceVolumeChange", "(iq)ni" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSourceVolumeChangeStubDispatcher },
+            /**
+             * acknowlegde for asyncSetSourceState
+             */
+            { { "ackSetSourceState", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSourceStateStubDispatcher },
+            /**
+             * acknowledges asyncSetSinkSoundProperties
+             */
+            { { "ackSetSinkSoundProperties", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSinkSoundPropertiesStubDispatcher },
+            /**
+             * acknowledges asyncSetSinkSoundProperty
+             */
+            { { "ackSetSinkSoundProperty", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSinkSoundPropertyStubDispatcher },
+            /**
+             * acknowledges asyncSetSourceSoundProperties
+             */
+            { { "ackSetSourceSoundProperties", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSourceSoundPropertiesStubDispatcher },
+            /**
+             * acknowledges asyncSetSourceSoundProperty
+             */
+            { { "ackSetSourceSoundProperty", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetSourceSoundPropertyStubDispatcher },
+            /**
+             * acknowledges asyncCrossFade
+             */
+            { { "ackCrossFading", "(iq)ii" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackCrossFadingStubDispatcher },
+            /**
+             * acknowledges a volume tick. This can be used to display volumechanges during
+             *  ramps
+             */
+            { { "ackSourceVolumeTick", "(iq)qn" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSourceVolumeTickStubDispatcher },
+            /**
+             * acknowledges a volume tick. This can be used to display volumechanges during
+             *  ramps
+             */
+            { { "ackSinkVolumeTick", "(iq)qn" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSinkVolumeTickStubDispatcher },
+            /**
+             * This function returns the ID to the given domainName. If already a domain is
+             *  registered with this name, it will return the corresponding ID, if not it will
+             *  reserve an ID but not register the domain. The other parameters of the domain
+             *  will be overwritten when the domain is registered.
+            (at)return E_OK on success,
+             *  E_UNKNOWN on error
+             */
+            { { "peekDomain", "s" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::peekDomainStubDispatcher },
+            /**
+             * registers a domain
+            (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+             *  registered E_UNKOWN on error
+             */
+            { { "registerDomain", "(qsssbbi)ss" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::registerDomainStubDispatcher },
+            /**
+             * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+             *  domain will be removed as well.
+            (at)return E_OK on succes, E_NON_EXISTENT if
+             *  not found E_UNKOWN on error
+             */
+            { { "deregisterDomain", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::deregisterDomainStubDispatcher },
+            /**
+             * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+             *  registered E_UNKOWN on error
+             */
+            { { "registerGateway", "(qsqqqqqaqaqab)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::registerGatewayStubDispatcher },
+            /**
+             * registers a converter. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+             *  registered E_UNKOWN on error
+             */
+            { { "registerConverter", "(qsqqqaqaqab)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::registerConverterStubDispatcher },
+            /**
+             * deregisters a gateway. Also removes all sinks and sources of the controlling
+             *  domain.
+            (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+             *  error
+             */
+            { { "deregisterGateway", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::deregisterGatewayStubDispatcher },
+            /**
+             * deregisters a converter. Also removes all sinks and sources of the controlling
+             *  domain.
+             */
+            { { "deregisterConverter", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::deregisterConverterStubDispatcher },
+            /**
+             * This function returns the ID to the given sinkName. If already a sink is
+             *  registered with this name, it will return the corresponding ID, if not it will
+             *  reserve an ID but not register the sink. The other parameters of the sink will
+             *  be overwritten when the sink is registered.
+            (at)return E_OK on success,
+             *  E_UNKNOWN on error
+             */
+            { { "peekSink", "s" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::peekSinkStubDispatcher },
+            /**
+             * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+             *  is copied to the gatewayInformation
+            (at)return E_OK on succes,
+             *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+             */
+            { { "registerSink", "(qsqqnb(iq)ina(qn)aqa(qn)a(qin)a(qin))" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::registerSinkStubDispatcher },
+            /**
+             * deregisters a sink.
+            (at)return E_OK on succes, E_NON_EXISTENT if not found
+             *  E_UNKOWN on error
+             */
+            { { "deregisterSink", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::deregisterSinkStubDispatcher },
+            /**
+             * This function returns the ID to the given sourceName. If already a source is
+             *  registered with this name, it will return the corresponding ID, if not it will
+             *  reserve an ID but not register the source. The other parameters of the source
+             *  will be overwritten when the source is registered.
+            (at)return E_OK on success,
+             *  E_UNKNOWN on error
+             */
+            { { "peekSource", "s" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::peekSourceStubDispatcher },
+            /**
+             * registers a source.  If the source is part of a gateway, the
+             *  listconnectionFormats is copied to the gatewayInformation
+            (at)return E_OK on
+             *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+             *  already exists
+             */
+            { { "registerSource", "(qqsqinb(iq)ia(qn)aqa(qn)a(qin)a(qin))" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::registerSourceStubDispatcher },
+            /**
+             * deregisters a source
+            (at)return E_OK on succes, E_NON_EXISTENT if not found
+             *  E_UNKOWN on error
+             */
+            { { "deregisterSource", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::deregisterSourceStubDispatcher },
+            /**
+             * this function registers a crossfader.
+            (at)return E_OK on succes,
+             *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+             */
+            { { "registerCrossfader", "(qsqqqi)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::registerCrossfaderStubDispatcher },
+            /**
+             * this function deregisters a crossfader. removes all sources and sinks assiated
+             *  as well.
+            (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+             *  error
+             */
+            { { "deregisterCrossfader", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::deregisterCrossfaderStubDispatcher },
+            /**
+             * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+             *  determine the SinkClassIDs of a sinkClass.
+            (at)return E_OK on succes,
+             *  E_DATABASE_ERROR on error
+             */
+            { { "peekSourceClassID", "s" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::peekSourceClassIDStubDispatcher },
+            /**
+             * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+             *  determine the SinkClassIDs of a sinkClass.
+            (at)return E_OK on succes,
+             *  E_DATABASE_ERROR on error
+             */
+            { { "peekSinkClassID", "s" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::peekSinkClassIDStubDispatcher },
+            /**
+             * is called when a low level interrupt changes it status.
+             */
+            { { "hookInterruptStatusChange", "qi" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookInterruptStatusChangeStubDispatcher },
+            /**
+             * This hook is called when all elements from a domain are registered.
+            Is used by
+             *  the Controller to know when all expected domains are finally registered
+             */
+            { { "hookDomainRegistrationComplete", "q" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookDomainRegistrationCompleteStubDispatcher },
+            /**
+             * is called when a sink changes its availability
+             */
+            { { "hookSinkAvailablityStatusChange", "q(iq)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookSinkAvailablityStatusChangeStubDispatcher },
+            /**
+             * is called when a source changes its availability
+             */
+            { { "hookSourceAvailablityStatusChange", "q(iq)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookSourceAvailablityStatusChangeStubDispatcher },
+            /**
+             * is called when a domain changes its status. This used for early domains only
+             */
+            { { "hookDomainStateChange", "qi" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookDomainStateChangeStubDispatcher },
+            /**
+             * is called when the timinginformation (delay) changed for a connection.
+             */
+            { { "hookTimingInformationChanged", "qn" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookTimingInformationChangedStubDispatcher },
+            /**
+             * this function is used to send out all data that has been changed in an early
+             *  state.
+            (at)return E_OK on success, E_UNKNOWN on error
+             */
+            { { "sendChangedData", "a(i(yv)(yv))" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::sendChangedDataStubDispatcher },
+            /**
+             * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+             *  gatewayID is not valid.
+             */
+            { { "updateGateway", "qaqaqab" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::updateGatewayStubDispatcher },
+            /**
+             * updates data of an converter. (at)return E_OK on success, E_NON_EXISTENT if the
+             *  converterID is not valid.
+             */
+            { { "updateConverter", "qaqaqab" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::updateConverterStubDispatcher },
+            /**
+             * updates data of an sink. (at)return E_OK on success, E_NON_EXISTENT if the
+             *  sinkID is not valid.
+             */
+            { { "updateSink", "qqa(qn)aqa(qn)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::updateSinkStubDispatcher },
+            /**
+             * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+             *  sourceID in the struct is not valid. 
+            Please note that only the following data
+             *  out of am_Source_s have effect when they are
+             *  changed:
+            sourceClassID,
+            listSoundProperties,
+            listConnectionFormats,
+             * 
+            listMainSoundProperties
+             */
+            { { "updateSource", "qqa(qn)aqa(qn)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::updateSourceStubDispatcher },
+            /**
+             * acknowledges a asyncSetSinkVolumes
+             */
+            { { "ackSetVolumes", "(iq)a(i(yv)nqn)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSetVolumesStubDispatcher },
+            /**
+             * The acknowledge of the SinkNotificationConfiguration
+             */
+            { { "ackSinkNotificationConfiguration", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSinkNotificationConfigurationStubDispatcher },
+            /**
+             * The acknowledge of the SourceNotificationConfiguration
+             */
+            { { "ackSourceNotificationConfiguration", "(iq)i" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::ackSourceNotificationConfigurationStubDispatcher },
+            /**
+             * is called whenever a notified value needs to be send
+             */
+            { { "hookSinkNotificationDataChange", "q(qn)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookSinkNotificationDataChangeStubDispatcher },
+            /**
+             * is called whenever a notified value needs to be send
+             */
+            { { "hookSourceNotificationDataChange", "q(qn)" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::hookSourceNotificationDataChangeStubDispatcher },
+            { { "confirmRoutingRundown", "s" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::confirmRoutingRundownStubDispatcher }
+            }),
+        stubAttributeTable_() {
+
+    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::am::RoutingControlObserverDBusStubAdapterInternal::getRoutingControlObserverInterfaceVersionStubDispatcher });
+}
+
+const bool RoutingControlObserverDBusStubAdapterInternal::hasFreedesktopProperties() {
+    return false;
+}
+
+} // namespace am
+} // namespace genivi
+} // namespace org
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.h
new file mode 100644
index 0000000..874ee6c
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverDBusStubAdapter.h
@@ -0,0 +1,557 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * Routing Receive sendInterface description.
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_Observer_DBUS_STUB_ADAPTER_H_
+#define ORG_GENIVI_AM_Routing_Control_Observer_DBUS_STUB_ADAPTER_H_
+
+#include <org/genivi/am/RoutingControlObserverStub.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/DBus/DBusStubAdapterHelper.h>
+#include <CommonAPI/DBus/DBusStubAdapter.h>
+#include <CommonAPI/DBus/DBusFactory.h>
+#include <CommonAPI/DBus/DBusServicePublisher.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+typedef CommonAPI::DBus::DBusStubAdapterHelper<RoutingControlObserverStub> RoutingControlObserverDBusStubAdapterHelper;
+
+class RoutingControlObserverDBusStubAdapterInternal: public virtual RoutingControlObserverStubAdapter, public RoutingControlObserverDBusStubAdapterHelper {
+ public:
+    RoutingControlObserverDBusStubAdapterInternal(
+            const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+            const std::string& commonApiAddress,
+            const std::string& dbusInterfaceName,
+            const std::string& dbusBusName,
+            const std::string& dbusObjectPath,
+            const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+            const std::shared_ptr<CommonAPI::StubBase>& stub);
+
+    ~RoutingControlObserverDBusStubAdapterInternal();
+
+    virtual const bool hasFreedesktopProperties();
+
+    /**
+     * This attribute signals to the clients the current routing state.
+    A client
+     *  should notify himself to this attribute in order to know the current state and
+     *  act accordingly.
+     */
+    void fireRoutingReadyAttributeChanged(const am_RoutingReady_e& value);
+
+
+
+    const RoutingControlObserverDBusStubAdapterHelper::StubDispatcherTable& getStubDispatcherTable();
+    const CommonAPI::DBus::StubAttributeTable& getStubAttributeTable();
+
+    void deactivateManagedInstances();
+
+
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        RoutingControlObserverStub,
+        CommonAPI::Version
+        > getRoutingControlObserverInterfaceVersionStubDispatcher;
+
+/**
+ * This attribute signals to the clients the current routing state.
+A client
+ *  should notify himself to this attribute in order to know the current state and
+ *  act accordingly.
+ */
+static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
+        RoutingControlObserverStub,
+        am_RoutingReady_e
+        > getRoutingReadyAttributeStubDispatcher;
+
+
+/**
+ * acknowledges a asyncConnect
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_connectionID_t, am_Error_e>,
+    std::tuple<>
+    > ackConnectStubDispatcher;
+/**
+ * acknowledges a asyncDisconnect
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_connectionID_t, am_Error_e>,
+    std::tuple<>
+    > ackDisconnectStubDispatcher;
+/**
+ * acknowledges a asyncsetSinkVolume
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_volume_t, am_Error_e>,
+    std::tuple<>
+    > ackSetSinkVolumeChangeStubDispatcher;
+/**
+ * acknowledges a asyncsetSourceVolume
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_volume_t, am_Error_e>,
+    std::tuple<>
+    > ackSetSourceVolumeChangeStubDispatcher;
+/**
+ * acknowlegde for asyncSetSourceState
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSetSourceStateStubDispatcher;
+/**
+ * acknowledges asyncSetSinkSoundProperties
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSetSinkSoundPropertiesStubDispatcher;
+/**
+ * acknowledges asyncSetSinkSoundProperty
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSetSinkSoundPropertyStubDispatcher;
+/**
+ * acknowledges asyncSetSourceSoundProperties
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSetSourceSoundPropertiesStubDispatcher;
+/**
+ * acknowledges asyncSetSourceSoundProperty
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSetSourceSoundPropertyStubDispatcher;
+/**
+ * acknowledges asyncCrossFade
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_HotSink_e, am_Error_e>,
+    std::tuple<>
+    > ackCrossFadingStubDispatcher;
+/**
+ * acknowledges a volume tick. This can be used to display volumechanges during
+ *  ramps
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_sourceID_t, am_volume_t>,
+    std::tuple<>
+    > ackSourceVolumeTickStubDispatcher;
+/**
+ * acknowledges a volume tick. This can be used to display volumechanges during
+ *  ramps
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_sinkID_t, am_volume_t>,
+    std::tuple<>
+    > ackSinkVolumeTickStubDispatcher;
+/**
+ * This function returns the ID to the given domainName. If already a domain is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the domain. The other parameters of the domain
+ *  will be overwritten when the domain is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_domainID_t, am_Error_e>
+    > peekDomainStubDispatcher;
+/**
+ * registers a domain
+(at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Domain_s, std::string, std::string>,
+    std::tuple<am_domainID_t, am_Error_e>
+    > registerDomainStubDispatcher;
+/**
+ * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+ *  domain will be removed as well.
+(at)return E_OK on succes, E_NON_EXISTENT if
+ *  not found E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_domainID_t>,
+    std::tuple<am_Error_e>
+    > deregisterDomainStubDispatcher;
+/**
+ * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Gateway_s>,
+    std::tuple<am_gatewayID_t, am_Error_e>
+    > registerGatewayStubDispatcher;
+/**
+ * registers a converter. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Converter_s>,
+    std::tuple<am_converterID_t, am_Error_e>
+    > registerConverterStubDispatcher;
+/**
+ * deregisters a gateway. Also removes all sinks and sources of the controlling
+ *  domain.
+(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+ *  error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_gatewayID_t>,
+    std::tuple<am_Error_e>
+    > deregisterGatewayStubDispatcher;
+/**
+ * deregisters a converter. Also removes all sinks and sources of the controlling
+ *  domain.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_converterID_t>,
+    std::tuple<am_Error_e>
+    > deregisterConverterStubDispatcher;
+/**
+ * This function returns the ID to the given sinkName. If already a sink is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the sink. The other parameters of the sink will
+ *  be overwritten when the sink is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_sinkID_t, am_Error_e>
+    > peekSinkStubDispatcher;
+/**
+ * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+ *  is copied to the gatewayInformation
+(at)return E_OK on succes,
+ *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Sink_s>,
+    std::tuple<am_sinkID_t, am_Error_e>
+    > registerSinkStubDispatcher;
+/**
+ * deregisters a sink.
+(at)return E_OK on succes, E_NON_EXISTENT if not found
+ *  E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sinkID_t>,
+    std::tuple<am_Error_e>
+    > deregisterSinkStubDispatcher;
+/**
+ * This function returns the ID to the given sourceName. If already a source is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the source. The other parameters of the source
+ *  will be overwritten when the source is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_sourceID_t, am_Error_e>
+    > peekSourceStubDispatcher;
+/**
+ * registers a source.  If the source is part of a gateway, the
+ *  listconnectionFormats is copied to the gatewayInformation
+(at)return E_OK on
+ *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+ *  already exists
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Source_s>,
+    std::tuple<am_sourceID_t, am_Error_e>
+    > registerSourceStubDispatcher;
+/**
+ * deregisters a source
+(at)return E_OK on succes, E_NON_EXISTENT if not found
+ *  E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t>,
+    std::tuple<am_Error_e>
+    > deregisterSourceStubDispatcher;
+/**
+ * this function registers a crossfader.
+(at)return E_OK on succes,
+ *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Crossfader_s>,
+    std::tuple<am_crossfaderID_t, am_Error_e>
+    > registerCrossfaderStubDispatcher;
+/**
+ * this function deregisters a crossfader. removes all sources and sinks assiated
+ *  as well.
+(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+ *  error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_crossfaderID_t>,
+    std::tuple<am_Error_e>
+    > deregisterCrossfaderStubDispatcher;
+/**
+ * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+ *  determine the SinkClassIDs of a sinkClass.
+(at)return E_OK on succes,
+ *  E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_sourceClass_t, am_Error_e>
+    > peekSourceClassIDStubDispatcher;
+/**
+ * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+ *  determine the SinkClassIDs of a sinkClass.
+(at)return E_OK on succes,
+ *  E_DATABASE_ERROR on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<am_sinkClass_t, am_Error_e>
+    > peekSinkClassIDStubDispatcher;
+/**
+ * is called when a low level interrupt changes it status.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t, am_InterruptState_e>,
+    std::tuple<>
+    > hookInterruptStatusChangeStubDispatcher;
+/**
+ * This hook is called when all elements from a domain are registered.
+Is used by
+ *  the Controller to know when all expected domains are finally registered
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_domainID_t>,
+    std::tuple<>
+    > hookDomainRegistrationCompleteStubDispatcher;
+/**
+ * is called when a sink changes its availability
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sinkID_t, am_Availability_s>,
+    std::tuple<>
+    > hookSinkAvailablityStatusChangeStubDispatcher;
+/**
+ * is called when a source changes its availability
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t, am_Availability_s>,
+    std::tuple<>
+    > hookSourceAvailablityStatusChangeStubDispatcher;
+/**
+ * is called when a domain changes its status. This used for early domains only
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_domainID_t, am_DomainState_e>,
+    std::tuple<>
+    > hookDomainStateChangeStubDispatcher;
+/**
+ * is called when the timinginformation (delay) changed for a connection.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_connectionID_t, am_timeSync_t>,
+    std::tuple<>
+    > hookTimingInformationChangedStubDispatcher;
+/**
+ * this function is used to send out all data that has been changed in an early
+ *  state.
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_EarlyData_L>,
+    std::tuple<>
+    > sendChangedDataStubDispatcher;
+/**
+ * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  gatewayID is not valid.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_gatewayID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
+    std::tuple<am_Error_e>
+    > updateGatewayStubDispatcher;
+/**
+ * updates data of an converter. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  converterID is not valid.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_converterID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
+    std::tuple<am_Error_e>
+    > updateConverterStubDispatcher;
+/**
+ * updates data of an sink. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  sinkID is not valid.
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sinkID_t, am_sinkClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
+    std::tuple<am_Error_e>
+    > updateSinkStubDispatcher;
+/**
+ * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  sourceID in the struct is not valid. 
+Please note that only the following data
+ *  out of am_Source_s have effect when they are
+ *  changed:
+sourceClassID,
+listSoundProperties,
+listConnectionFormats,
+ * 
+listMainSoundProperties
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t, am_sourceClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
+    std::tuple<am_Error_e>
+    > updateSourceStubDispatcher;
+/**
+ * acknowledges a asyncSetSinkVolumes
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Volumes_L, am_Error_e>,
+    std::tuple<>
+    > ackSetVolumesStubDispatcher;
+/**
+ * The acknowledge of the SinkNotificationConfiguration
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSinkNotificationConfigurationStubDispatcher;
+/**
+ * The acknowledge of the SourceNotificationConfiguration
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_Handle_s, am_Error_e>,
+    std::tuple<>
+    > ackSourceNotificationConfigurationStubDispatcher;
+/**
+ * is called whenever a notified value needs to be send
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sinkID_t, am_NotificationPayload_s>,
+    std::tuple<>
+    > hookSinkNotificationDataChangeStubDispatcher;
+/**
+ * is called whenever a notified value needs to be send
+ */
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<am_sourceID_t, am_NotificationPayload_s>,
+    std::tuple<>
+    > hookSourceNotificationDataChangeStubDispatcher;
+static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
+    RoutingControlObserverStub,
+    std::tuple<std::string>,
+    std::tuple<>
+    > confirmRoutingRundownStubDispatcher;
+
+
+
+
+ protected:
+    virtual const char* getMethodsDBusIntrospectionXmlData() const;
+
+ private:
+    RoutingControlObserverDBusStubAdapterHelper::StubDispatcherTable stubDispatcherTable_;
+    CommonAPI::DBus::StubAttributeTable stubAttributeTable_;
+};
+
+class RoutingControlObserverDBusStubAdapter: public RoutingControlObserverDBusStubAdapterInternal, public std::enable_shared_from_this<RoutingControlObserverDBusStubAdapter> {
+public:
+    RoutingControlObserverDBusStubAdapter(
+                         const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
+                         const std::string& commonApiAddress,
+                         const std::string& dbusInterfaceName,
+                         const std::string& dbusBusName,
+                         const std::string& dbusObjectPath,
+                         const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
+                         const std::shared_ptr<CommonAPI::StubBase>& stub) :
+            CommonAPI::DBus::DBusStubAdapter(
+                            factory,
+                            commonApiAddress,
+                            dbusInterfaceName,
+                            dbusBusName,
+                            dbusObjectPath,
+                            dbusConnection,
+                            false),
+            RoutingControlObserverDBusStubAdapterInternal(
+                            factory,
+                            commonApiAddress,
+                            dbusInterfaceName,
+                            dbusBusName,
+                            dbusObjectPath,
+                            dbusConnection,
+                            stub) { }
+};
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Routing_Control_Observer_DBUS_STUB_ADAPTER_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxy.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxy.h
new file mode 100644
index 0000000..813c9cc
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxy.h
@@ -0,0 +1,1921 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * Routing Receive sendInterface description.
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_Observer_PROXY_H_
+#define ORG_GENIVI_AM_Routing_Control_Observer_PROXY_H_
+
+#include "RoutingControlObserverProxyBase.h"
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/AttributeExtension.h>
+#include <CommonAPI/Factory.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+template <typename ... _AttributeExtensions>
+class RoutingControlObserverProxy: virtual public RoutingControlObserver, virtual public RoutingControlObserverProxyBase
+, public _AttributeExtensions... {
+public:
+    RoutingControlObserverProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
+    ~RoutingControlObserverProxy();
+
+    typedef RoutingControlObserver InterfaceType;
+
+
+    /**
+     * This attribute signals to the clients the current routing state.
+    A client
+     *  should notify himself to this attribute in order to know the current state and
+     *  act accordingly.
+     */
+    /**
+     * Returns the wrapper class that provides access to the attribute RoutingReady.
+     */
+    virtual RoutingReadyAttribute& getRoutingReadyAttribute() {
+        return delegate_->getRoutingReadyAttribute();
+    }
+
+
+    /**
+     * acknowledges a asyncConnect
+     * 
+     * Calls ackConnect with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackConnect with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckConnectAsyncCallback callback);
+    /**
+     * acknowledges a asyncDisconnect
+     * 
+     * Calls ackDisconnect with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackDisconnect with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckDisconnectAsyncCallback callback);
+    /**
+     * acknowledges a asyncsetSinkVolume
+     * 
+     * Calls ackSetSinkVolumeChange with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackSetSinkVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackSetSinkVolumeChange with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackSetSinkVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSinkVolumeChangeAsyncCallback callback);
+    /**
+     * acknowledges a asyncsetSourceVolume
+     * 
+     * Calls ackSetSourceVolumeChange with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackSetSourceVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackSetSourceVolumeChange with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackSetSourceVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSourceVolumeChangeAsyncCallback callback);
+    /**
+     * acknowlegde for asyncSetSourceState
+     * 
+     * Calls ackSetSourceState with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackSetSourceState(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackSetSourceState with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackSetSourceStateAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceStateAsyncCallback callback);
+    /**
+     * acknowledges asyncSetSinkSoundProperties
+     * 
+     * Calls ackSetSinkSoundProperties with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackSetSinkSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackSetSinkSoundProperties with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertiesAsyncCallback callback);
+    /**
+     * acknowledges asyncSetSinkSoundProperty
+     * 
+     * Calls ackSetSinkSoundProperty with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackSetSinkSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackSetSinkSoundProperty with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertyAsyncCallback callback);
+    /**
+     * acknowledges asyncSetSourceSoundProperties
+     * 
+     * Calls ackSetSourceSoundProperties with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackSetSourceSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackSetSourceSoundProperties with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertiesAsyncCallback callback);
+    /**
+     * acknowledges asyncSetSourceSoundProperty
+     * 
+     * Calls ackSetSourceSoundProperty with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackSetSourceSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackSetSourceSoundProperty with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertyAsyncCallback callback);
+    /**
+     * acknowledges asyncCrossFade
+     * 
+     * Calls ackCrossFading with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackCrossFading(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackCrossFading with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackCrossFadingAsync(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, AckCrossFadingAsyncCallback callback);
+    /**
+     * acknowledges a volume tick. This can be used to display volumechanges during
+     *  ramps
+     * 
+     * Calls ackSourceVolumeTick with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackSourceVolumeTick(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackSourceVolumeTick with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackSourceVolumeTickAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback);
+    /**
+     * acknowledges a volume tick. This can be used to display volumechanges during
+     *  ramps
+     * 
+     * Calls ackSinkVolumeTick with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackSinkVolumeTick(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackSinkVolumeTick with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackSinkVolumeTickAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback);
+    /**
+     * This function returns the ID to the given domainName. If already a domain is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the domain. The other parameters of the domain
+     *  will be overwritten when the domain is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     * 
+     * Calls peekDomain with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error);
+    /**
+     * Calls peekDomain with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback);
+    /**
+     * registers a domain
+    (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     * 
+     * Calls registerDomain with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void registerDomain(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error);
+    /**
+     * Calls registerDomain with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> registerDomainAsync(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, RegisterDomainAsyncCallback callback);
+    /**
+     * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+     *  domain will be removed as well.
+    (at)return E_OK on succes, E_NON_EXISTENT if
+     *  not found E_UNKOWN on error
+     * 
+     * Calls deregisterDomain with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void deregisterDomain(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls deregisterDomain with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> deregisterDomainAsync(const am_domainID_t& domainID, DeregisterDomainAsyncCallback callback);
+    /**
+     * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     * 
+     * Calls registerGateway with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void registerGateway(const am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gatewayID_t& gatewayID, am_Error_e& error);
+    /**
+     * Calls registerGateway with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> registerGatewayAsync(const am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback);
+    /**
+     * registers a converter. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     * 
+     * Calls registerConverter with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void registerConverter(const am_Converter_s& converterData, CommonAPI::CallStatus& callStatus, am_converterID_t& converterID, am_Error_e& error);
+    /**
+     * Calls registerConverter with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> registerConverterAsync(const am_Converter_s& converterData, RegisterConverterAsyncCallback callback);
+    /**
+     * deregisters a gateway. Also removes all sinks and sources of the controlling
+     *  domain.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+     *  error
+     * 
+     * Calls deregisterGateway with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void deregisterGateway(const am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls deregisterGateway with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> deregisterGatewayAsync(const am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback);
+    /**
+     * deregisters a converter. Also removes all sinks and sources of the controlling
+     *  domain.
+     * 
+     * Calls deregisterConverter with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void deregisterConverter(const am_converterID_t& converterID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls deregisterConverter with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> deregisterConverterAsync(const am_converterID_t& converterID, DeregisterConverterAsyncCallback callback);
+    /**
+     * This function returns the ID to the given sinkName. If already a sink is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the sink. The other parameters of the sink will
+     *  be overwritten when the sink is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     * 
+     * Calls peekSink with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error);
+    /**
+     * Calls peekSink with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback);
+    /**
+     * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+     *  is copied to the gatewayInformation
+    (at)return E_OK on succes,
+     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+     * 
+     * Calls registerSink with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void registerSink(const am_Sink_s& sinkData, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error);
+    /**
+     * Calls registerSink with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> registerSinkAsync(const am_Sink_s& sinkData, RegisterSinkAsyncCallback callback);
+    /**
+     * deregisters a sink.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found
+     *  E_UNKOWN on error
+     * 
+     * Calls deregisterSink with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void deregisterSink(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls deregisterSink with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> deregisterSinkAsync(const am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback);
+    /**
+     * This function returns the ID to the given sourceName. If already a source is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the source. The other parameters of the source
+     *  will be overwritten when the source is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     * 
+     * Calls peekSource with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error);
+    /**
+     * Calls peekSource with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback);
+    /**
+     * registers a source.  If the source is part of a gateway, the
+     *  listconnectionFormats is copied to the gatewayInformation
+    (at)return E_OK on
+     *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+     *  already exists
+     * 
+     * Calls registerSource with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void registerSource(const am_Source_s& sourceData, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error);
+    /**
+     * Calls registerSource with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> registerSourceAsync(const am_Source_s& sourceData, RegisterSourceAsyncCallback callback);
+    /**
+     * deregisters a source
+    (at)return E_OK on succes, E_NON_EXISTENT if not found
+     *  E_UNKOWN on error
+     * 
+     * Calls deregisterSource with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void deregisterSource(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls deregisterSource with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> deregisterSourceAsync(const am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback);
+    /**
+     * this function registers a crossfader.
+    (at)return E_OK on succes,
+     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+     * 
+     * Calls registerCrossfader with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void registerCrossfader(const am_Crossfader_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_crossfaderID_t& crossfaderID, am_Error_e& error);
+    /**
+     * Calls registerCrossfader with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> registerCrossfaderAsync(const am_Crossfader_s& crossfaderData, RegisterCrossfaderAsyncCallback callback);
+    /**
+     * this function deregisters a crossfader. removes all sources and sinks assiated
+     *  as well.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+     *  error
+     * 
+     * Calls deregisterCrossfader with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void deregisterCrossfader(const am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls deregisterCrossfader with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> deregisterCrossfaderAsync(const am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback);
+    /**
+     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+     *  determine the SinkClassIDs of a sinkClass.
+    (at)return E_OK on succes,
+     *  E_DATABASE_ERROR on error
+     * 
+     * Calls peekSourceClassID with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceClass_t& sourceClassID, am_Error_e& error);
+    /**
+     * Calls peekSourceClassID with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback);
+    /**
+     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+     *  determine the SinkClassIDs of a sinkClass.
+    (at)return E_OK on succes,
+     *  E_DATABASE_ERROR on error
+     * 
+     * Calls peekSinkClassID with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkClass_t& sinkClassID, am_Error_e& error);
+    /**
+     * Calls peekSinkClassID with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback);
+    /**
+     * is called when a low level interrupt changes it status.
+     * 
+     * Calls hookInterruptStatusChange with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void hookInterruptStatusChange(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls hookInterruptStatusChange with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> hookInterruptStatusChangeAsync(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, HookInterruptStatusChangeAsyncCallback callback);
+    /**
+     * This hook is called when all elements from a domain are registered.
+    Is used by
+     *  the Controller to know when all expected domains are finally registered
+     * 
+     * Calls hookDomainRegistrationComplete with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void hookDomainRegistrationComplete(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls hookDomainRegistrationComplete with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> hookDomainRegistrationCompleteAsync(const am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback);
+    /**
+     * is called when a sink changes its availability
+     * 
+     * Calls hookSinkAvailablityStatusChange with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void hookSinkAvailablityStatusChange(const am_sinkID_t& sinkID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls hookSinkAvailablityStatusChange with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> hookSinkAvailablityStatusChangeAsync(const am_sinkID_t& sinkID, const am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback);
+    /**
+     * is called when a source changes its availability
+     * 
+     * Calls hookSourceAvailablityStatusChange with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void hookSourceAvailablityStatusChange(const am_sourceID_t& sourceID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls hookSourceAvailablityStatusChange with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> hookSourceAvailablityStatusChangeAsync(const am_sourceID_t& sourceID, const am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback);
+    /**
+     * is called when a domain changes its status. This used for early domains only
+     * 
+     * Calls hookDomainStateChange with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void hookDomainStateChange(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls hookDomainStateChange with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> hookDomainStateChangeAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback);
+    /**
+     * is called when the timinginformation (delay) changed for a connection.
+     * 
+     * Calls hookTimingInformationChanged with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void hookTimingInformationChanged(const am_connectionID_t& connectionID, const am_timeSync_t& delay, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls hookTimingInformationChanged with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> hookTimingInformationChangedAsync(const am_connectionID_t& connectionID, const am_timeSync_t& delay, HookTimingInformationChangedAsyncCallback callback);
+    /**
+     * this function is used to send out all data that has been changed in an early
+     *  state.
+    (at)return E_OK on success, E_UNKNOWN on error
+     * 
+     * Calls sendChangedData with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void sendChangedData(const am_EarlyData_L& earlyData, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls sendChangedData with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> sendChangedDataAsync(const am_EarlyData_L& earlyData, SendChangedDataAsyncCallback callback);
+    /**
+     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  gatewayID is not valid.
+     * 
+     * Calls updateGateway with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void updateGateway(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls updateGateway with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> updateGatewayAsync(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateGatewayAsyncCallback callback);
+    /**
+     * updates data of an converter. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  converterID is not valid.
+     * 
+     * Calls updateConverter with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void updateConverter(const am_converterID_t& converterID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls updateConverter with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> updateConverterAsync(const am_converterID_t& converterID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateConverterAsyncCallback callback);
+    /**
+     * updates data of an sink. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  sinkID is not valid.
+     * 
+     * Calls updateSink with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void updateSink(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls updateSink with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> updateSinkAsync(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback);
+    /**
+     * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  sourceID in the struct is not valid. 
+    Please note that only the following data
+     *  out of am_Source_s have effect when they are
+     *  changed:
+    sourceClassID,
+    listSoundProperties,
+    listConnectionFormats,
+     * 
+    listMainSoundProperties
+     * 
+     * Calls updateSource with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void updateSource(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls updateSource with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> updateSourceAsync(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback);
+    /**
+     * acknowledges a asyncSetSinkVolumes
+     * 
+     * Calls ackSetVolumes with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackSetVolumes(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackSetVolumes with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, AckSetVolumesAsyncCallback callback);
+    /**
+     * The acknowledge of the SinkNotificationConfiguration
+     * 
+     * Calls ackSinkNotificationConfiguration with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackSinkNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackSinkNotificationConfiguration with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSinkNotificationConfigurationAsyncCallback callback);
+    /**
+     * The acknowledge of the SourceNotificationConfiguration
+     * 
+     * Calls ackSourceNotificationConfiguration with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void ackSourceNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls ackSourceNotificationConfiguration with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> ackSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSourceNotificationConfigurationAsyncCallback callback);
+    /**
+     * is called whenever a notified value needs to be send
+     * 
+     * Calls hookSinkNotificationDataChange with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void hookSinkNotificationDataChange(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls hookSinkNotificationDataChange with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> hookSinkNotificationDataChangeAsync(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback);
+    /**
+     * is called whenever a notified value needs to be send
+     * 
+     * Calls hookSourceNotificationDataChange with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void hookSourceNotificationDataChange(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls hookSourceNotificationDataChange with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> hookSourceNotificationDataChangeAsync(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback);
+    /**
+     * Calls confirmRoutingRundown with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void confirmRoutingRundown(const std::string& domainName, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls confirmRoutingRundown with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> confirmRoutingRundownAsync(const std::string& domainName, ConfirmRoutingRundownAsyncCallback callback);
+
+
+    /**
+     * Returns the CommonAPI address of the remote partner this proxy communicates with.
+     */
+    virtual std::string getAddress() const;
+
+    /**
+     * Returns the domain of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getDomain() const;
+
+    /** 
+     * Returns the service ID of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getServiceId() const;
+
+    /**
+     * Returns the instance ID of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getInstanceId() const;
+
+    /**
+     * Returns true if the remote partner for this proxy is currently known to be available.
+     */
+    virtual bool isAvailable() const;
+
+    /**
+     * Returns true if the remote partner for this proxy is available.
+     */
+    virtual bool isAvailableBlocking() const;
+
+    /**
+     * Returns the wrapper class that is used to (de-)register for notifications about
+     * the availability of the remote partner of this proxy.
+     */
+    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();
+
+    /**
+     * Returns the wrapper class that is used to access version information of the remote
+     * partner of this proxy.
+     */
+    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();
+
+ private:
+    std::shared_ptr<RoutingControlObserverProxyBase> delegate_;
+};
+
+#ifdef WIN32
+    typedef RoutingControlObserverProxy<CommonAPI::WINDummyAttributeExtension<CommonAPI::WINDummyAttribute>> RoutingControlObserverProxyDefault;
+#else
+    typedef RoutingControlObserverProxy<> RoutingControlObserverProxyDefault;
+#endif
+
+namespace RoutingControlObserverExtensions {
+    /**
+     * This attribute signals to the clients the current routing state.
+    A client
+     *  should notify himself to this attribute in order to know the current state and
+     *  act accordingly.
+     */
+    template <template <typename > class _ExtensionType>
+    class RoutingReadyAttributeExtension {
+     public:
+        typedef _ExtensionType<RoutingControlObserverProxyBase::RoutingReadyAttribute> extension_type;
+    
+        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<RoutingControlObserverProxyBase::RoutingReadyAttribute>, extension_type>::value,
+                      "Not CommonAPI Attribute Extension!");
+    #ifdef WIN32
+        RoutingReadyAttributeExtension() {}
+    #endif
+    
+        RoutingReadyAttributeExtension(RoutingControlObserverProxyBase& proxy): attributeExtension_(proxy.getRoutingReadyAttribute()) {
+        }
+    
+        inline extension_type& getRoutingReadyAttributeExtension() {
+            return attributeExtension_;
+        }
+    
+     private:
+        extension_type attributeExtension_;
+    };
+
+} // namespace RoutingControlObserverExtensions
+
+//
+// RoutingControlObserverProxy Implementation
+//
+template <typename ... _AttributeExtensions>
+RoutingControlObserverProxy<_AttributeExtensions...>::RoutingControlObserverProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
+        _AttributeExtensions(*(std::dynamic_pointer_cast<RoutingControlObserverProxyBase>(delegate)))...,
+        delegate_(std::dynamic_pointer_cast<RoutingControlObserverProxyBase>(delegate)) {
+}
+
+template <typename ... _AttributeExtensions>
+RoutingControlObserverProxy<_AttributeExtensions...>::~RoutingControlObserverProxy() {
+}
+
+/**
+ * acknowledges a asyncConnect
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackConnect(handle, connectionID, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckConnectAsyncCallback callback) {
+    return delegate_->ackConnectAsync(handle, connectionID, error, callback);
+}
+/**
+ * acknowledges a asyncDisconnect
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackDisconnect(handle, connectionID, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckDisconnectAsyncCallback callback) {
+    return delegate_->ackDisconnectAsync(handle, connectionID, error, callback);
+}
+/**
+ * acknowledges a asyncsetSinkVolume
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackSetSinkVolumeChange(handle, volume, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSinkVolumeChangeAsyncCallback callback) {
+    return delegate_->ackSetSinkVolumeChangeAsync(handle, volume, error, callback);
+}
+/**
+ * acknowledges a asyncsetSourceVolume
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackSetSourceVolumeChange(handle, volume, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSourceVolumeChangeAsyncCallback callback) {
+    return delegate_->ackSetSourceVolumeChangeAsync(handle, volume, error, callback);
+}
+/**
+ * acknowlegde for asyncSetSourceState
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceState(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackSetSourceState(handle, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceStateAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceStateAsyncCallback callback) {
+    return delegate_->ackSetSourceStateAsync(handle, error, callback);
+}
+/**
+ * acknowledges asyncSetSinkSoundProperties
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackSetSinkSoundProperties(handle, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertiesAsyncCallback callback) {
+    return delegate_->ackSetSinkSoundPropertiesAsync(handle, error, callback);
+}
+/**
+ * acknowledges asyncSetSinkSoundProperty
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackSetSinkSoundProperty(handle, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertyAsyncCallback callback) {
+    return delegate_->ackSetSinkSoundPropertyAsync(handle, error, callback);
+}
+/**
+ * acknowledges asyncSetSourceSoundProperties
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackSetSourceSoundProperties(handle, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertiesAsyncCallback callback) {
+    return delegate_->ackSetSourceSoundPropertiesAsync(handle, error, callback);
+}
+/**
+ * acknowledges asyncSetSourceSoundProperty
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackSetSourceSoundProperty(handle, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertyAsyncCallback callback) {
+    return delegate_->ackSetSourceSoundPropertyAsync(handle, error, callback);
+}
+/**
+ * acknowledges asyncCrossFade
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackCrossFading(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackCrossFading(handle, hotSink, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackCrossFadingAsync(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, AckCrossFadingAsyncCallback callback) {
+    return delegate_->ackCrossFadingAsync(handle, hotSink, error, callback);
+}
+/**
+ * acknowledges a volume tick. This can be used to display volumechanges during
+ *  ramps
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackSourceVolumeTick(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackSourceVolumeTick(handle, sourceID, volume, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSourceVolumeTickAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback) {
+    return delegate_->ackSourceVolumeTickAsync(handle, sourceID, volume, callback);
+}
+/**
+ * acknowledges a volume tick. This can be used to display volumechanges during
+ *  ramps
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackSinkVolumeTick(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackSinkVolumeTick(handle, sinkID, volume, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSinkVolumeTickAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback) {
+    return delegate_->ackSinkVolumeTickAsync(handle, sinkID, volume, callback);
+}
+/**
+ * This function returns the ID to the given domainName. If already a domain is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the domain. The other parameters of the domain
+ *  will be overwritten when the domain is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) {
+    delegate_->peekDomain(name, callStatus, domainID, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback) {
+    return delegate_->peekDomainAsync(name, callback);
+}
+/**
+ * registers a domain
+(at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::registerDomain(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) {
+    delegate_->registerDomain(domainData, returnBusname, returnInterface, callStatus, domainID, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerDomainAsync(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, RegisterDomainAsyncCallback callback) {
+    return delegate_->registerDomainAsync(domainData, returnBusname, returnInterface, callback);
+}
+/**
+ * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+ *  domain will be removed as well.
+(at)return E_OK on succes, E_NON_EXISTENT if
+ *  not found E_UNKOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterDomain(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->deregisterDomain(domainID, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterDomainAsync(const am_domainID_t& domainID, DeregisterDomainAsyncCallback callback) {
+    return delegate_->deregisterDomainAsync(domainID, callback);
+}
+/**
+ * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::registerGateway(const am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gatewayID_t& gatewayID, am_Error_e& error) {
+    delegate_->registerGateway(gatewayData, callStatus, gatewayID, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerGatewayAsync(const am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback) {
+    return delegate_->registerGatewayAsync(gatewayData, callback);
+}
+/**
+ * registers a converter. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::registerConverter(const am_Converter_s& converterData, CommonAPI::CallStatus& callStatus, am_converterID_t& converterID, am_Error_e& error) {
+    delegate_->registerConverter(converterData, callStatus, converterID, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerConverterAsync(const am_Converter_s& converterData, RegisterConverterAsyncCallback callback) {
+    return delegate_->registerConverterAsync(converterData, callback);
+}
+/**
+ * deregisters a gateway. Also removes all sinks and sources of the controlling
+ *  domain.
+(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+ *  error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterGateway(const am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->deregisterGateway(gatewayID, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterGatewayAsync(const am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback) {
+    return delegate_->deregisterGatewayAsync(gatewayID, callback);
+}
+/**
+ * deregisters a converter. Also removes all sinks and sources of the controlling
+ *  domain.
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterConverter(const am_converterID_t& converterID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->deregisterConverter(converterID, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterConverterAsync(const am_converterID_t& converterID, DeregisterConverterAsyncCallback callback) {
+    return delegate_->deregisterConverterAsync(converterID, callback);
+}
+/**
+ * This function returns the ID to the given sinkName. If already a sink is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the sink. The other parameters of the sink will
+ *  be overwritten when the sink is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) {
+    delegate_->peekSink(name, callStatus, sinkID, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback) {
+    return delegate_->peekSinkAsync(name, callback);
+}
+/**
+ * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+ *  is copied to the gatewayInformation
+(at)return E_OK on succes,
+ *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::registerSink(const am_Sink_s& sinkData, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) {
+    delegate_->registerSink(sinkData, callStatus, sinkID, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerSinkAsync(const am_Sink_s& sinkData, RegisterSinkAsyncCallback callback) {
+    return delegate_->registerSinkAsync(sinkData, callback);
+}
+/**
+ * deregisters a sink.
+(at)return E_OK on succes, E_NON_EXISTENT if not found
+ *  E_UNKOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSink(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->deregisterSink(sinkID, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSinkAsync(const am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback) {
+    return delegate_->deregisterSinkAsync(sinkID, callback);
+}
+/**
+ * This function returns the ID to the given sourceName. If already a source is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the source. The other parameters of the source
+ *  will be overwritten when the source is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) {
+    delegate_->peekSource(name, callStatus, sourceID, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback) {
+    return delegate_->peekSourceAsync(name, callback);
+}
+/**
+ * registers a source.  If the source is part of a gateway, the
+ *  listconnectionFormats is copied to the gatewayInformation
+(at)return E_OK on
+ *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+ *  already exists
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::registerSource(const am_Source_s& sourceData, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) {
+    delegate_->registerSource(sourceData, callStatus, sourceID, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerSourceAsync(const am_Source_s& sourceData, RegisterSourceAsyncCallback callback) {
+    return delegate_->registerSourceAsync(sourceData, callback);
+}
+/**
+ * deregisters a source
+(at)return E_OK on succes, E_NON_EXISTENT if not found
+ *  E_UNKOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSource(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->deregisterSource(sourceID, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSourceAsync(const am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback) {
+    return delegate_->deregisterSourceAsync(sourceID, callback);
+}
+/**
+ * this function registers a crossfader.
+(at)return E_OK on succes,
+ *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::registerCrossfader(const am_Crossfader_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_crossfaderID_t& crossfaderID, am_Error_e& error) {
+    delegate_->registerCrossfader(crossfaderData, callStatus, crossfaderID, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerCrossfaderAsync(const am_Crossfader_s& crossfaderData, RegisterCrossfaderAsyncCallback callback) {
+    return delegate_->registerCrossfaderAsync(crossfaderData, callback);
+}
+/**
+ * this function deregisters a crossfader. removes all sources and sinks assiated
+ *  as well.
+(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+ *  error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterCrossfader(const am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->deregisterCrossfader(crossfaderID, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterCrossfaderAsync(const am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback) {
+    return delegate_->deregisterCrossfaderAsync(crossfaderID, callback);
+}
+/**
+ * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+ *  determine the SinkClassIDs of a sinkClass.
+(at)return E_OK on succes,
+ *  E_DATABASE_ERROR on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceClass_t& sourceClassID, am_Error_e& error) {
+    delegate_->peekSourceClassID(name, callStatus, sourceClassID, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback) {
+    return delegate_->peekSourceClassIDAsync(name, callback);
+}
+/**
+ * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+ *  determine the SinkClassIDs of a sinkClass.
+(at)return E_OK on succes,
+ *  E_DATABASE_ERROR on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkClass_t& sinkClassID, am_Error_e& error) {
+    delegate_->peekSinkClassID(name, callStatus, sinkClassID, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback) {
+    return delegate_->peekSinkClassIDAsync(name, callback);
+}
+/**
+ * is called when a low level interrupt changes it status.
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::hookInterruptStatusChange(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, CommonAPI::CallStatus& callStatus) {
+    delegate_->hookInterruptStatusChange(sourceID, interruptState, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookInterruptStatusChangeAsync(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, HookInterruptStatusChangeAsyncCallback callback) {
+    return delegate_->hookInterruptStatusChangeAsync(sourceID, interruptState, callback);
+}
+/**
+ * This hook is called when all elements from a domain are registered.
+Is used by
+ *  the Controller to know when all expected domains are finally registered
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainRegistrationComplete(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus) {
+    delegate_->hookDomainRegistrationComplete(domainID, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainRegistrationCompleteAsync(const am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback) {
+    return delegate_->hookDomainRegistrationCompleteAsync(domainID, callback);
+}
+/**
+ * is called when a sink changes its availability
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkAvailablityStatusChange(const am_sinkID_t& sinkID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) {
+    delegate_->hookSinkAvailablityStatusChange(sinkID, availability, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkAvailablityStatusChangeAsync(const am_sinkID_t& sinkID, const am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback) {
+    return delegate_->hookSinkAvailablityStatusChangeAsync(sinkID, availability, callback);
+}
+/**
+ * is called when a source changes its availability
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceAvailablityStatusChange(const am_sourceID_t& sourceID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) {
+    delegate_->hookSourceAvailablityStatusChange(sourceID, availability, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceAvailablityStatusChangeAsync(const am_sourceID_t& sourceID, const am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback) {
+    return delegate_->hookSourceAvailablityStatusChangeAsync(sourceID, availability, callback);
+}
+/**
+ * is called when a domain changes its status. This used for early domains only
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainStateChange(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus) {
+    delegate_->hookDomainStateChange(domainID, domainState, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainStateChangeAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback) {
+    return delegate_->hookDomainStateChangeAsync(domainID, domainState, callback);
+}
+/**
+ * is called when the timinginformation (delay) changed for a connection.
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::hookTimingInformationChanged(const am_connectionID_t& connectionID, const am_timeSync_t& delay, CommonAPI::CallStatus& callStatus) {
+    delegate_->hookTimingInformationChanged(connectionID, delay, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookTimingInformationChangedAsync(const am_connectionID_t& connectionID, const am_timeSync_t& delay, HookTimingInformationChangedAsyncCallback callback) {
+    return delegate_->hookTimingInformationChangedAsync(connectionID, delay, callback);
+}
+/**
+ * this function is used to send out all data that has been changed in an early
+ *  state.
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::sendChangedData(const am_EarlyData_L& earlyData, CommonAPI::CallStatus& callStatus) {
+    delegate_->sendChangedData(earlyData, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendChangedDataAsync(const am_EarlyData_L& earlyData, SendChangedDataAsyncCallback callback) {
+    return delegate_->sendChangedDataAsync(earlyData, callback);
+}
+/**
+ * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  gatewayID is not valid.
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::updateGateway(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->updateGateway(gatewayID, listSourceFormats, listSinkFormats, convertionMatrix, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::updateGatewayAsync(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateGatewayAsyncCallback callback) {
+    return delegate_->updateGatewayAsync(gatewayID, listSourceFormats, listSinkFormats, convertionMatrix, callback);
+}
+/**
+ * updates data of an converter. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  converterID is not valid.
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::updateConverter(const am_converterID_t& converterID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->updateConverter(converterID, listSourceFormats, listSinkFormats, convertionMatrix, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::updateConverterAsync(const am_converterID_t& converterID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateConverterAsyncCallback callback) {
+    return delegate_->updateConverterAsync(converterID, listSourceFormats, listSinkFormats, convertionMatrix, callback);
+}
+/**
+ * updates data of an sink. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  sinkID is not valid.
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::updateSink(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->updateSink(sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::updateSinkAsync(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback) {
+    return delegate_->updateSinkAsync(sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callback);
+}
+/**
+ * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  sourceID in the struct is not valid. 
+Please note that only the following data
+ *  out of am_Source_s have effect when they are
+ *  changed:
+sourceClassID,
+listSoundProperties,
+listConnectionFormats,
+ * 
+listMainSoundProperties
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::updateSource(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->updateSource(sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::updateSourceAsync(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback) {
+    return delegate_->updateSourceAsync(sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callback);
+}
+/**
+ * acknowledges a asyncSetSinkVolumes
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetVolumes(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackSetVolumes(handle, listvolumes, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, AckSetVolumesAsyncCallback callback) {
+    return delegate_->ackSetVolumesAsync(handle, listvolumes, error, callback);
+}
+/**
+ * The acknowledge of the SinkNotificationConfiguration
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackSinkNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackSinkNotificationConfiguration(handle, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSinkNotificationConfigurationAsyncCallback callback) {
+    return delegate_->ackSinkNotificationConfigurationAsync(handle, error, callback);
+}
+/**
+ * The acknowledge of the SourceNotificationConfiguration
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::ackSourceNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
+    delegate_->ackSourceNotificationConfiguration(handle, error, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSourceNotificationConfigurationAsyncCallback callback) {
+    return delegate_->ackSourceNotificationConfigurationAsync(handle, error, callback);
+}
+/**
+ * is called whenever a notified value needs to be send
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkNotificationDataChange(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) {
+    delegate_->hookSinkNotificationDataChange(sinkID, payload, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkNotificationDataChangeAsync(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback) {
+    return delegate_->hookSinkNotificationDataChangeAsync(sinkID, payload, callback);
+}
+/**
+ * is called whenever a notified value needs to be send
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceNotificationDataChange(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) {
+    delegate_->hookSourceNotificationDataChange(sourceID, payload, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceNotificationDataChangeAsync(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback) {
+    return delegate_->hookSourceNotificationDataChangeAsync(sourceID, payload, callback);
+}
+template <typename ... _AttributeExtensions>
+void RoutingControlObserverProxy<_AttributeExtensions...>::confirmRoutingRundown(const std::string& domainName, CommonAPI::CallStatus& callStatus) {
+    delegate_->confirmRoutingRundown(domainName, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::confirmRoutingRundownAsync(const std::string& domainName, ConfirmRoutingRundownAsyncCallback callback) {
+    return delegate_->confirmRoutingRundownAsync(domainName, callback);
+}
+
+template <typename ... _AttributeExtensions>
+std::string RoutingControlObserverProxy<_AttributeExtensions...>::getAddress() const {
+    return delegate_->getAddress();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& RoutingControlObserverProxy<_AttributeExtensions...>::getDomain() const {
+    return delegate_->getDomain();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& RoutingControlObserverProxy<_AttributeExtensions...>::getServiceId() const {
+    return delegate_->getServiceId();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& RoutingControlObserverProxy<_AttributeExtensions...>::getInstanceId() const {
+    return delegate_->getInstanceId();
+}
+
+template <typename ... _AttributeExtensions>
+bool RoutingControlObserverProxy<_AttributeExtensions...>::isAvailable() const {
+    return delegate_->isAvailable();
+}
+
+template <typename ... _AttributeExtensions>
+bool RoutingControlObserverProxy<_AttributeExtensions...>::isAvailableBlocking() const {
+    return delegate_->isAvailableBlocking();
+}
+
+template <typename ... _AttributeExtensions>
+CommonAPI::ProxyStatusEvent& RoutingControlObserverProxy<_AttributeExtensions...>::getProxyStatusEvent() {
+    return delegate_->getProxyStatusEvent();
+}
+
+template <typename ... _AttributeExtensions>
+CommonAPI::InterfaceVersionAttribute& RoutingControlObserverProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
+    return delegate_->getInterfaceVersionAttribute();
+}
+
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+namespace CommonAPI {
+template<template<typename > class _AttributeExtension>
+struct DefaultAttributeProxyFactoryHelper<org::genivi::am::RoutingControlObserverProxy,
+    _AttributeExtension> {
+    typedef typename org::genivi::am::RoutingControlObserverProxy<
+            org::genivi::am::RoutingControlObserverExtensions::RoutingReadyAttributeExtension<_AttributeExtension>
+    > class_t;
+};
+}
+
+#endif // ORG_GENIVI_AM_Routing_Control_Observer_PROXY_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxyBase.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxyBase.h
new file mode 100644
index 0000000..a1ba9d4
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverProxyBase.h
@@ -0,0 +1,401 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * Routing Receive sendInterface description.
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_Observer_PROXY_BASE_H_
+#define ORG_GENIVI_AM_Routing_Control_Observer_PROXY_BASE_H_
+
+#include "RoutingControlObserver.h"
+
+
+#include <org/genivi/am.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/InputStream.h>
+#include <CommonAPI/OutputStream.h>
+#include <CommonAPI/SerializableStruct.h>
+#include <cstdint>
+#include <string>
+#include <vector>
+
+#include <CommonAPI/Attribute.h>
+#include <CommonAPI/Proxy.h>
+#include <functional>
+#include <future>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+class RoutingControlObserverProxyBase: virtual public CommonAPI::Proxy {
+ public:
+    typedef CommonAPI::ObservableReadonlyAttribute<am_RoutingReady_e> RoutingReadyAttribute;
+
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckConnectAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckDisconnectAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSinkVolumeChangeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSourceVolumeChangeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSourceStateAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSinkSoundPropertiesAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSinkSoundPropertyAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSourceSoundPropertiesAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSourceSoundPropertyAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckCrossFadingAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckSourceVolumeTickAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckSinkVolumeTickAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_domainID_t&, const am_Error_e&)> PeekDomainAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_domainID_t&, const am_Error_e&)> RegisterDomainAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> DeregisterDomainAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_gatewayID_t&, const am_Error_e&)> RegisterGatewayAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_converterID_t&, const am_Error_e&)> RegisterConverterAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> DeregisterGatewayAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> DeregisterConverterAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_sinkID_t&, const am_Error_e&)> PeekSinkAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_sinkID_t&, const am_Error_e&)> RegisterSinkAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> DeregisterSinkAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_sourceID_t&, const am_Error_e&)> PeekSourceAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_sourceID_t&, const am_Error_e&)> RegisterSourceAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> DeregisterSourceAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_crossfaderID_t&, const am_Error_e&)> RegisterCrossfaderAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> DeregisterCrossfaderAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_sourceClass_t&, const am_Error_e&)> PeekSourceClassIDAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_sinkClass_t&, const am_Error_e&)> PeekSinkClassIDAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> HookInterruptStatusChangeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> HookDomainRegistrationCompleteAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> HookSinkAvailablityStatusChangeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> HookSourceAvailablityStatusChangeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> HookDomainStateChangeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> HookTimingInformationChangedAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> SendChangedDataAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> UpdateGatewayAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> UpdateConverterAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> UpdateSinkAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> UpdateSourceAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetVolumesAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckSinkNotificationConfigurationAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AckSourceNotificationConfigurationAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> HookSinkNotificationDataChangeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> HookSourceNotificationDataChangeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> ConfirmRoutingRundownAsyncCallback;
+
+    /**
+     * This attribute signals to the clients the current routing state.
+    A client
+     *  should notify himself to this attribute in order to know the current state and
+     *  act accordingly.
+     */
+    virtual RoutingReadyAttribute& getRoutingReadyAttribute() = 0;
+
+
+    /**
+     * acknowledges a asyncConnect
+     */
+    virtual void ackConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckConnectAsyncCallback callback) = 0;
+    /**
+     * acknowledges a asyncDisconnect
+     */
+    virtual void ackDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckDisconnectAsyncCallback callback) = 0;
+    /**
+     * acknowledges a asyncsetSinkVolume
+     */
+    virtual void ackSetSinkVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackSetSinkVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSinkVolumeChangeAsyncCallback callback) = 0;
+    /**
+     * acknowledges a asyncsetSourceVolume
+     */
+    virtual void ackSetSourceVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackSetSourceVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSourceVolumeChangeAsyncCallback callback) = 0;
+    /**
+     * acknowlegde for asyncSetSourceState
+     */
+    virtual void ackSetSourceState(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackSetSourceStateAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceStateAsyncCallback callback) = 0;
+    /**
+     * acknowledges asyncSetSinkSoundProperties
+     */
+    virtual void ackSetSinkSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertiesAsyncCallback callback) = 0;
+    /**
+     * acknowledges asyncSetSinkSoundProperty
+     */
+    virtual void ackSetSinkSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertyAsyncCallback callback) = 0;
+    /**
+     * acknowledges asyncSetSourceSoundProperties
+     */
+    virtual void ackSetSourceSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertiesAsyncCallback callback) = 0;
+    /**
+     * acknowledges asyncSetSourceSoundProperty
+     */
+    virtual void ackSetSourceSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertyAsyncCallback callback) = 0;
+    /**
+     * acknowledges asyncCrossFade
+     */
+    virtual void ackCrossFading(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackCrossFadingAsync(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, AckCrossFadingAsyncCallback callback) = 0;
+    /**
+     * acknowledges a volume tick. This can be used to display volumechanges during
+     *  ramps
+     */
+    virtual void ackSourceVolumeTick(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackSourceVolumeTickAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback) = 0;
+    /**
+     * acknowledges a volume tick. This can be used to display volumechanges during
+     *  ramps
+     */
+    virtual void ackSinkVolumeTick(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackSinkVolumeTickAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback) = 0;
+    /**
+     * This function returns the ID to the given domainName. If already a domain is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the domain. The other parameters of the domain
+     *  will be overwritten when the domain is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     */
+    virtual void peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback) = 0;
+    /**
+     * registers a domain
+    (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     */
+    virtual void registerDomain(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> registerDomainAsync(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, RegisterDomainAsyncCallback callback) = 0;
+    /**
+     * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+     *  domain will be removed as well.
+    (at)return E_OK on succes, E_NON_EXISTENT if
+     *  not found E_UNKOWN on error
+     */
+    virtual void deregisterDomain(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> deregisterDomainAsync(const am_domainID_t& domainID, DeregisterDomainAsyncCallback callback) = 0;
+    /**
+     * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     */
+    virtual void registerGateway(const am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gatewayID_t& gatewayID, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> registerGatewayAsync(const am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback) = 0;
+    /**
+     * registers a converter. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     */
+    virtual void registerConverter(const am_Converter_s& converterData, CommonAPI::CallStatus& callStatus, am_converterID_t& converterID, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> registerConverterAsync(const am_Converter_s& converterData, RegisterConverterAsyncCallback callback) = 0;
+    /**
+     * deregisters a gateway. Also removes all sinks and sources of the controlling
+     *  domain.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+     *  error
+     */
+    virtual void deregisterGateway(const am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> deregisterGatewayAsync(const am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback) = 0;
+    /**
+     * deregisters a converter. Also removes all sinks and sources of the controlling
+     *  domain.
+     */
+    virtual void deregisterConverter(const am_converterID_t& converterID, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> deregisterConverterAsync(const am_converterID_t& converterID, DeregisterConverterAsyncCallback callback) = 0;
+    /**
+     * This function returns the ID to the given sinkName. If already a sink is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the sink. The other parameters of the sink will
+     *  be overwritten when the sink is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     */
+    virtual void peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback) = 0;
+    /**
+     * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+     *  is copied to the gatewayInformation
+    (at)return E_OK on succes,
+     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+     */
+    virtual void registerSink(const am_Sink_s& sinkData, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> registerSinkAsync(const am_Sink_s& sinkData, RegisterSinkAsyncCallback callback) = 0;
+    /**
+     * deregisters a sink.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found
+     *  E_UNKOWN on error
+     */
+    virtual void deregisterSink(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> deregisterSinkAsync(const am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback) = 0;
+    /**
+     * This function returns the ID to the given sourceName. If already a source is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the source. The other parameters of the source
+     *  will be overwritten when the source is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     */
+    virtual void peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback) = 0;
+    /**
+     * registers a source.  If the source is part of a gateway, the
+     *  listconnectionFormats is copied to the gatewayInformation
+    (at)return E_OK on
+     *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+     *  already exists
+     */
+    virtual void registerSource(const am_Source_s& sourceData, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> registerSourceAsync(const am_Source_s& sourceData, RegisterSourceAsyncCallback callback) = 0;
+    /**
+     * deregisters a source
+    (at)return E_OK on succes, E_NON_EXISTENT if not found
+     *  E_UNKOWN on error
+     */
+    virtual void deregisterSource(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> deregisterSourceAsync(const am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback) = 0;
+    /**
+     * this function registers a crossfader.
+    (at)return E_OK on succes,
+     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+     */
+    virtual void registerCrossfader(const am_Crossfader_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_crossfaderID_t& crossfaderID, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> registerCrossfaderAsync(const am_Crossfader_s& crossfaderData, RegisterCrossfaderAsyncCallback callback) = 0;
+    /**
+     * this function deregisters a crossfader. removes all sources and sinks assiated
+     *  as well.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+     *  error
+     */
+    virtual void deregisterCrossfader(const am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> deregisterCrossfaderAsync(const am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback) = 0;
+    /**
+     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+     *  determine the SinkClassIDs of a sinkClass.
+    (at)return E_OK on succes,
+     *  E_DATABASE_ERROR on error
+     */
+    virtual void peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceClass_t& sourceClassID, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback) = 0;
+    /**
+     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+     *  determine the SinkClassIDs of a sinkClass.
+    (at)return E_OK on succes,
+     *  E_DATABASE_ERROR on error
+     */
+    virtual void peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkClass_t& sinkClassID, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback) = 0;
+    /**
+     * is called when a low level interrupt changes it status.
+     */
+    virtual void hookInterruptStatusChange(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> hookInterruptStatusChangeAsync(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, HookInterruptStatusChangeAsyncCallback callback) = 0;
+    /**
+     * This hook is called when all elements from a domain are registered.
+    Is used by
+     *  the Controller to know when all expected domains are finally registered
+     */
+    virtual void hookDomainRegistrationComplete(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> hookDomainRegistrationCompleteAsync(const am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback) = 0;
+    /**
+     * is called when a sink changes its availability
+     */
+    virtual void hookSinkAvailablityStatusChange(const am_sinkID_t& sinkID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> hookSinkAvailablityStatusChangeAsync(const am_sinkID_t& sinkID, const am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback) = 0;
+    /**
+     * is called when a source changes its availability
+     */
+    virtual void hookSourceAvailablityStatusChange(const am_sourceID_t& sourceID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> hookSourceAvailablityStatusChangeAsync(const am_sourceID_t& sourceID, const am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback) = 0;
+    /**
+     * is called when a domain changes its status. This used for early domains only
+     */
+    virtual void hookDomainStateChange(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> hookDomainStateChangeAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback) = 0;
+    /**
+     * is called when the timinginformation (delay) changed for a connection.
+     */
+    virtual void hookTimingInformationChanged(const am_connectionID_t& connectionID, const am_timeSync_t& delay, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> hookTimingInformationChangedAsync(const am_connectionID_t& connectionID, const am_timeSync_t& delay, HookTimingInformationChangedAsyncCallback callback) = 0;
+    /**
+     * this function is used to send out all data that has been changed in an early
+     *  state.
+    (at)return E_OK on success, E_UNKNOWN on error
+     */
+    virtual void sendChangedData(const am_EarlyData_L& earlyData, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> sendChangedDataAsync(const am_EarlyData_L& earlyData, SendChangedDataAsyncCallback callback) = 0;
+    /**
+     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  gatewayID is not valid.
+     */
+    virtual void updateGateway(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> updateGatewayAsync(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateGatewayAsyncCallback callback) = 0;
+    /**
+     * updates data of an converter. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  converterID is not valid.
+     */
+    virtual void updateConverter(const am_converterID_t& converterID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> updateConverterAsync(const am_converterID_t& converterID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateConverterAsyncCallback callback) = 0;
+    /**
+     * updates data of an sink. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  sinkID is not valid.
+     */
+    virtual void updateSink(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> updateSinkAsync(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback) = 0;
+    /**
+     * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  sourceID in the struct is not valid. 
+    Please note that only the following data
+     *  out of am_Source_s have effect when they are
+     *  changed:
+    sourceClassID,
+    listSoundProperties,
+    listConnectionFormats,
+     * 
+    listMainSoundProperties
+     */
+    virtual void updateSource(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> updateSourceAsync(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback) = 0;
+    /**
+     * acknowledges a asyncSetSinkVolumes
+     */
+    virtual void ackSetVolumes(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, AckSetVolumesAsyncCallback callback) = 0;
+    /**
+     * The acknowledge of the SinkNotificationConfiguration
+     */
+    virtual void ackSinkNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSinkNotificationConfigurationAsyncCallback callback) = 0;
+    /**
+     * The acknowledge of the SourceNotificationConfiguration
+     */
+    virtual void ackSourceNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> ackSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSourceNotificationConfigurationAsyncCallback callback) = 0;
+    /**
+     * is called whenever a notified value needs to be send
+     */
+    virtual void hookSinkNotificationDataChange(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> hookSinkNotificationDataChangeAsync(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback) = 0;
+    /**
+     * is called whenever a notified value needs to be send
+     */
+    virtual void hookSourceNotificationDataChange(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> hookSourceNotificationDataChangeAsync(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback) = 0;
+    virtual void confirmRoutingRundown(const std::string& domainName, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> confirmRoutingRundownAsync(const std::string& domainName, ConfirmRoutingRundownAsyncCallback callback) = 0;
+};
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Routing_Control_Observer_PROXY_BASE_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStub.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStub.h
new file mode 100644
index 0000000..0f2f3ee
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStub.h
@@ -0,0 +1,407 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * Routing Receive sendInterface description.
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_Observer_STUB_H_
+#define ORG_GENIVI_AM_Routing_Control_Observer_STUB_H_
+
+
+
+#include <org/genivi/am.h>
+
+#include "RoutingControlObserver.h"
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/InputStream.h>
+#include <CommonAPI/OutputStream.h>
+#include <CommonAPI/SerializableStruct.h>
+#include <cstdint>
+#include <string>
+#include <vector>
+
+#include <CommonAPI/Stub.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+/**
+ * Receives messages from remote and handles all dispatching of deserialized calls
+ * to a stub for the service RoutingControlObserver. Also provides means to send broadcasts
+ * and attribute-changed-notifications of observable attributes as defined by this service.
+ * An application developer should not need to bother with this class.
+ */
+class RoutingControlObserverStubAdapter: virtual public CommonAPI::StubAdapter, public RoutingControlObserver {
+ public:
+    ///Notifies all remote listeners about a change of value of the attribute RoutingReady.
+    virtual void fireRoutingReadyAttributeChanged(const am_RoutingReady_e& RoutingReady) = 0;
+
+
+
+    virtual void deactivateManagedInstances() = 0;
+protected:
+    /**
+     * Defines properties for storing the ClientIds of clients / proxies that have
+     * subscribed to the selective broadcasts
+     */
+};
+
+
+/**
+ * Defines the necessary callbacks to handle remote set events related to the attributes
+ * defined in the IDL description for RoutingControlObserver.
+ * For each attribute two callbacks are defined:
+ * - a verification callback that allows to verify the requested value and to prevent setting
+ *   e.g. an invalid value ("onRemoteSet<AttributeName>").
+ * - an action callback to do local work after the attribute value has been changed
+ *   ("onRemote<AttributeName>Changed").
+ *
+ * This class and the one below are the ones an application developer needs to have
+ * a look at if he wants to implement a service.
+ */
+class RoutingControlObserverStubRemoteEvent {
+ public:
+    virtual ~RoutingControlObserverStubRemoteEvent() { }
+
+
+};
+
+
+/**
+ * Defines the interface that must be implemented by any class that should provide
+ * the service RoutingControlObserver to remote clients.
+ * This class and the one above are the ones an application developer needs to have
+ * a look at if he wants to implement a service.
+ */
+class RoutingControlObserverStub: public virtual CommonAPI::Stub<RoutingControlObserverStubAdapter, RoutingControlObserverStubRemoteEvent> {
+public:
+    virtual ~RoutingControlObserverStub() { }
+    virtual const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
+
+    /**
+     * This attribute signals to the clients the current routing state.
+    A client
+     *  should notify himself to this attribute in order to know the current state and
+     *  act accordingly.
+     */
+    /// Provides getter access to the attribute RoutingReady
+    virtual const am_RoutingReady_e& getRoutingReadyAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
+
+    /**
+     * acknowledges a asyncConnect
+     */
+    /// This is the method that will be called on remote calls on the method ackConnect.
+    virtual void ackConnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error) = 0;
+    /**
+     * acknowledges a asyncDisconnect
+     */
+    /// This is the method that will be called on remote calls on the method ackDisconnect.
+    virtual void ackDisconnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error) = 0;
+    /**
+     * acknowledges a asyncsetSinkVolume
+     */
+    /// This is the method that will be called on remote calls on the method ackSetSinkVolumeChange.
+    virtual void ackSetSinkVolumeChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_volume_t volume, am_Error_e error) = 0;
+    /**
+     * acknowledges a asyncsetSourceVolume
+     */
+    /// This is the method that will be called on remote calls on the method ackSetSourceVolumeChange.
+    virtual void ackSetSourceVolumeChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_volume_t volume, am_Error_e error) = 0;
+    /**
+     * acknowlegde for asyncSetSourceState
+     */
+    /// This is the method that will be called on remote calls on the method ackSetSourceState.
+    virtual void ackSetSourceState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) = 0;
+    /**
+     * acknowledges asyncSetSinkSoundProperties
+     */
+    /// This is the method that will be called on remote calls on the method ackSetSinkSoundProperties.
+    virtual void ackSetSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) = 0;
+    /**
+     * acknowledges asyncSetSinkSoundProperty
+     */
+    /// This is the method that will be called on remote calls on the method ackSetSinkSoundProperty.
+    virtual void ackSetSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) = 0;
+    /**
+     * acknowledges asyncSetSourceSoundProperties
+     */
+    /// This is the method that will be called on remote calls on the method ackSetSourceSoundProperties.
+    virtual void ackSetSourceSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) = 0;
+    /**
+     * acknowledges asyncSetSourceSoundProperty
+     */
+    /// This is the method that will be called on remote calls on the method ackSetSourceSoundProperty.
+    virtual void ackSetSourceSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) = 0;
+    /**
+     * acknowledges asyncCrossFade
+     */
+    /// This is the method that will be called on remote calls on the method ackCrossFading.
+    virtual void ackCrossFading(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_HotSink_e hotSink, am_Error_e error) = 0;
+    /**
+     * acknowledges a volume tick. This can be used to display volumechanges during
+     *  ramps
+     */
+    /// This is the method that will be called on remote calls on the method ackSourceVolumeTick.
+    virtual void ackSourceVolumeTick(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume) = 0;
+    /**
+     * acknowledges a volume tick. This can be used to display volumechanges during
+     *  ramps
+     */
+    /// This is the method that will be called on remote calls on the method ackSinkVolumeTick.
+    virtual void ackSinkVolumeTick(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume) = 0;
+    /**
+     * This function returns the ID to the given domainName. If already a domain is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the domain. The other parameters of the domain
+     *  will be overwritten when the domain is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method peekDomain.
+    virtual void peekDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_domainID_t& domainID, am_Error_e& error) = 0;
+    /**
+     * registers a domain
+    (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method registerDomain.
+    virtual void registerDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Domain_s domainData, std::string returnBusname, std::string returnInterface, am_domainID_t& domainID, am_Error_e& error) = 0;
+    /**
+     * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+     *  domain will be removed as well.
+    (at)return E_OK on succes, E_NON_EXISTENT if
+     *  not found E_UNKOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method deregisterDomain.
+    virtual void deregisterDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID, am_Error_e& error) = 0;
+    /**
+     * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method registerGateway.
+    virtual void registerGateway(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Gateway_s gatewayData, am_gatewayID_t& gatewayID, am_Error_e& error) = 0;
+    /**
+     * registers a converter. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method registerConverter.
+    virtual void registerConverter(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Converter_s converterData, am_converterID_t& converterID, am_Error_e& error) = 0;
+    /**
+     * deregisters a gateway. Also removes all sinks and sources of the controlling
+     *  domain.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+     *  error
+     */
+    /// This is the method that will be called on remote calls on the method deregisterGateway.
+    virtual void deregisterGateway(const std::shared_ptr<CommonAPI::ClientId> clientId, am_gatewayID_t gatewayID, am_Error_e& error) = 0;
+    /**
+     * deregisters a converter. Also removes all sinks and sources of the controlling
+     *  domain.
+     */
+    /// This is the method that will be called on remote calls on the method deregisterConverter.
+    virtual void deregisterConverter(const std::shared_ptr<CommonAPI::ClientId> clientId, am_converterID_t converterID, am_Error_e& error) = 0;
+    /**
+     * This function returns the ID to the given sinkName. If already a sink is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the sink. The other parameters of the sink will
+     *  be overwritten when the sink is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method peekSink.
+    virtual void peekSink(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sinkID_t& sinkID, am_Error_e& error) = 0;
+    /**
+     * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+     *  is copied to the gatewayInformation
+    (at)return E_OK on succes,
+     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method registerSink.
+    virtual void registerSink(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Sink_s sinkData, am_sinkID_t& sinkID, am_Error_e& error) = 0;
+    /**
+     * deregisters a sink.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found
+     *  E_UNKOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method deregisterSink.
+    virtual void deregisterSink(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_Error_e& error) = 0;
+    /**
+     * This function returns the ID to the given sourceName. If already a source is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the source. The other parameters of the source
+     *  will be overwritten when the source is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method peekSource.
+    virtual void peekSource(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sourceID_t& sourceID, am_Error_e& error) = 0;
+    /**
+     * registers a source.  If the source is part of a gateway, the
+     *  listconnectionFormats is copied to the gatewayInformation
+    (at)return E_OK on
+     *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+     *  already exists
+     */
+    /// This is the method that will be called on remote calls on the method registerSource.
+    virtual void registerSource(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Source_s sourceData, am_sourceID_t& sourceID, am_Error_e& error) = 0;
+    /**
+     * deregisters a source
+    (at)return E_OK on succes, E_NON_EXISTENT if not found
+     *  E_UNKOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method deregisterSource.
+    virtual void deregisterSource(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_Error_e& error) = 0;
+    /**
+     * this function registers a crossfader.
+    (at)return E_OK on succes,
+     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method registerCrossfader.
+    virtual void registerCrossfader(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Crossfader_s crossfaderData, am_crossfaderID_t& crossfaderID, am_Error_e& error) = 0;
+    /**
+     * this function deregisters a crossfader. removes all sources and sinks assiated
+     *  as well.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+     *  error
+     */
+    /// This is the method that will be called on remote calls on the method deregisterCrossfader.
+    virtual void deregisterCrossfader(const std::shared_ptr<CommonAPI::ClientId> clientId, am_crossfaderID_t crossfaderID, am_Error_e& error) = 0;
+    /**
+     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+     *  determine the SinkClassIDs of a sinkClass.
+    (at)return E_OK on succes,
+     *  E_DATABASE_ERROR on error
+     */
+    /// This is the method that will be called on remote calls on the method peekSourceClassID.
+    virtual void peekSourceClassID(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sourceClass_t& sourceClassID, am_Error_e& error) = 0;
+    /**
+     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+     *  determine the SinkClassIDs of a sinkClass.
+    (at)return E_OK on succes,
+     *  E_DATABASE_ERROR on error
+     */
+    /// This is the method that will be called on remote calls on the method peekSinkClassID.
+    virtual void peekSinkClassID(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sinkClass_t& sinkClassID, am_Error_e& error) = 0;
+    /**
+     * is called when a low level interrupt changes it status.
+     */
+    /// This is the method that will be called on remote calls on the method hookInterruptStatusChange.
+    virtual void hookInterruptStatusChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_InterruptState_e interruptState) = 0;
+    /**
+     * This hook is called when all elements from a domain are registered.
+    Is used by
+     *  the Controller to know when all expected domains are finally registered
+     */
+    /// This is the method that will be called on remote calls on the method hookDomainRegistrationComplete.
+    virtual void hookDomainRegistrationComplete(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID) = 0;
+    /**
+     * is called when a sink changes its availability
+     */
+    /// This is the method that will be called on remote calls on the method hookSinkAvailablityStatusChange.
+    virtual void hookSinkAvailablityStatusChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_Availability_s availability) = 0;
+    /**
+     * is called when a source changes its availability
+     */
+    /// This is the method that will be called on remote calls on the method hookSourceAvailablityStatusChange.
+    virtual void hookSourceAvailablityStatusChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_Availability_s availability) = 0;
+    /**
+     * is called when a domain changes its status. This used for early domains only
+     */
+    /// This is the method that will be called on remote calls on the method hookDomainStateChange.
+    virtual void hookDomainStateChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID, am_DomainState_e domainState) = 0;
+    /**
+     * is called when the timinginformation (delay) changed for a connection.
+     */
+    /// This is the method that will be called on remote calls on the method hookTimingInformationChanged.
+    virtual void hookTimingInformationChanged(const std::shared_ptr<CommonAPI::ClientId> clientId, am_connectionID_t connectionID, am_timeSync_t delay) = 0;
+    /**
+     * this function is used to send out all data that has been changed in an early
+     *  state.
+    (at)return E_OK on success, E_UNKNOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method sendChangedData.
+    virtual void sendChangedData(const std::shared_ptr<CommonAPI::ClientId> clientId, am_EarlyData_L earlyData) = 0;
+    /**
+     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  gatewayID is not valid.
+     */
+    /// This is the method that will be called on remote calls on the method updateGateway.
+    virtual void updateGateway(const std::shared_ptr<CommonAPI::ClientId> clientId, am_gatewayID_t gatewayID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error) = 0;
+    /**
+     * updates data of an converter. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  converterID is not valid.
+     */
+    /// This is the method that will be called on remote calls on the method updateConverter.
+    virtual void updateConverter(const std::shared_ptr<CommonAPI::ClientId> clientId, am_converterID_t converterID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error) = 0;
+    /**
+     * updates data of an sink. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  sinkID is not valid.
+     */
+    /// This is the method that will be called on remote calls on the method updateSink.
+    virtual void updateSink(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_sinkClass_t sinkClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error) = 0;
+    /**
+     * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  sourceID in the struct is not valid. 
+    Please note that only the following data
+     *  out of am_Source_s have effect when they are
+     *  changed:
+    sourceClassID,
+    listSoundProperties,
+    listConnectionFormats,
+     * 
+    listMainSoundProperties
+     */
+    /// This is the method that will be called on remote calls on the method updateSource.
+    virtual void updateSource(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_sourceClass_t sourceClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error) = 0;
+    /**
+     * acknowledges a asyncSetSinkVolumes
+     */
+    /// This is the method that will be called on remote calls on the method ackSetVolumes.
+    virtual void ackSetVolumes(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Volumes_L listvolumes, am_Error_e error) = 0;
+    /**
+     * The acknowledge of the SinkNotificationConfiguration
+     */
+    /// This is the method that will be called on remote calls on the method ackSinkNotificationConfiguration.
+    virtual void ackSinkNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) = 0;
+    /**
+     * The acknowledge of the SourceNotificationConfiguration
+     */
+    /// This is the method that will be called on remote calls on the method ackSourceNotificationConfiguration.
+    virtual void ackSourceNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) = 0;
+    /**
+     * is called whenever a notified value needs to be send
+     */
+    /// This is the method that will be called on remote calls on the method hookSinkNotificationDataChange.
+    virtual void hookSinkNotificationDataChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_NotificationPayload_s payload) = 0;
+    /**
+     * is called whenever a notified value needs to be send
+     */
+    /// This is the method that will be called on remote calls on the method hookSourceNotificationDataChange.
+    virtual void hookSourceNotificationDataChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_NotificationPayload_s payload) = 0;
+    /// This is the method that will be called on remote calls on the method confirmRoutingRundown.
+    virtual void confirmRoutingRundown(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string domainName) = 0;
+
+    using CommonAPI::Stub<RoutingControlObserverStubAdapter, RoutingControlObserverStubRemoteEvent>::initStubAdapter;
+    typedef CommonAPI::Stub<RoutingControlObserverStubAdapter, RoutingControlObserverStubRemoteEvent>::StubAdapterType StubAdapterType;
+    typedef CommonAPI::Stub<RoutingControlObserverStubAdapter, RoutingControlObserverStubRemoteEvent>::RemoteEventHandlerType RemoteEventHandlerType;
+    typedef RoutingControlObserverStubRemoteEvent RemoteEventType;
+    typedef RoutingControlObserver StubInterface;
+};
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Routing_Control_Observer_STUB_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.cpp
new file mode 100644
index 0000000..250809f
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.cpp
@@ -0,0 +1,636 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+#include <org/genivi/am/RoutingControlObserverStubDefault.h>
+
+namespace org {
+namespace genivi {
+namespace am {
+
+RoutingControlObserverStubDefault::RoutingControlObserverStubDefault():
+        remoteEventHandler_(this),
+        interfaceVersion_(RoutingControlObserver::getInterfaceVersion()) {
+}
+
+const CommonAPI::Version& RoutingControlObserverStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) {
+    return interfaceVersion_;
+}
+
+RoutingControlObserverStubRemoteEvent* RoutingControlObserverStubDefault::initStubAdapter(const std::shared_ptr<RoutingControlObserverStubAdapter>& stubAdapter) {
+    CommonAPI::Stub<RoutingControlObserverStubAdapter, RoutingControlObserverStubRemoteEvent>::stubAdapter_ = stubAdapter;
+    return &remoteEventHandler_;
+}
+
+const am_RoutingReady_e& RoutingControlObserverStubDefault::getRoutingReadyAttribute() {
+    return routingReadyAttributeValue_;
+}
+
+const am_RoutingReady_e& RoutingControlObserverStubDefault::getRoutingReadyAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId) {
+    return getRoutingReadyAttribute();
+}
+
+void RoutingControlObserverStubDefault::setRoutingReadyAttribute(am_RoutingReady_e value) {
+    const bool valueChanged = trySetRoutingReadyAttribute(std::move(value));
+    if (valueChanged && stubAdapter_ != NULL) {
+        stubAdapter_->fireRoutingReadyAttributeChanged(routingReadyAttributeValue_);
+    }
+}
+
+bool RoutingControlObserverStubDefault::trySetRoutingReadyAttribute(am_RoutingReady_e value) {
+    if (!validateRoutingReadyAttributeRequestedValue(value))
+        return false;
+
+    const bool valueChanged = (routingReadyAttributeValue_ != value);
+    routingReadyAttributeValue_ = std::move(value);
+    return valueChanged;
+}
+
+bool RoutingControlObserverStubDefault::validateRoutingReadyAttributeRequestedValue(const am_RoutingReady_e& value) {
+    return true;
+}
+
+
+
+/**
+ * acknowledges a asyncConnect
+ */
+void RoutingControlObserverStubDefault::ackConnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error) {
+    // Call old style methods in default 
+    ackConnect(handle, connectionID, error);
+}
+void RoutingControlObserverStubDefault::ackConnect(am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * acknowledges a asyncDisconnect
+ */
+void RoutingControlObserverStubDefault::ackDisconnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error) {
+    // Call old style methods in default 
+    ackDisconnect(handle, connectionID, error);
+}
+void RoutingControlObserverStubDefault::ackDisconnect(am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * acknowledges a asyncsetSinkVolume
+ */
+void RoutingControlObserverStubDefault::ackSetSinkVolumeChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_volume_t volume, am_Error_e error) {
+    // Call old style methods in default 
+    ackSetSinkVolumeChange(handle, volume, error);
+}
+void RoutingControlObserverStubDefault::ackSetSinkVolumeChange(am_Handle_s handle, am_volume_t volume, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * acknowledges a asyncsetSourceVolume
+ */
+void RoutingControlObserverStubDefault::ackSetSourceVolumeChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_volume_t volume, am_Error_e error) {
+    // Call old style methods in default 
+    ackSetSourceVolumeChange(handle, volume, error);
+}
+void RoutingControlObserverStubDefault::ackSetSourceVolumeChange(am_Handle_s handle, am_volume_t volume, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * acknowlegde for asyncSetSourceState
+ */
+void RoutingControlObserverStubDefault::ackSetSourceState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) {
+    // Call old style methods in default 
+    ackSetSourceState(handle, error);
+}
+void RoutingControlObserverStubDefault::ackSetSourceState(am_Handle_s handle, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * acknowledges asyncSetSinkSoundProperties
+ */
+void RoutingControlObserverStubDefault::ackSetSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) {
+    // Call old style methods in default 
+    ackSetSinkSoundProperties(handle, error);
+}
+void RoutingControlObserverStubDefault::ackSetSinkSoundProperties(am_Handle_s handle, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * acknowledges asyncSetSinkSoundProperty
+ */
+void RoutingControlObserverStubDefault::ackSetSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) {
+    // Call old style methods in default 
+    ackSetSinkSoundProperty(handle, error);
+}
+void RoutingControlObserverStubDefault::ackSetSinkSoundProperty(am_Handle_s handle, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * acknowledges asyncSetSourceSoundProperties
+ */
+void RoutingControlObserverStubDefault::ackSetSourceSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) {
+    // Call old style methods in default 
+    ackSetSourceSoundProperties(handle, error);
+}
+void RoutingControlObserverStubDefault::ackSetSourceSoundProperties(am_Handle_s handle, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * acknowledges asyncSetSourceSoundProperty
+ */
+void RoutingControlObserverStubDefault::ackSetSourceSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) {
+    // Call old style methods in default 
+    ackSetSourceSoundProperty(handle, error);
+}
+void RoutingControlObserverStubDefault::ackSetSourceSoundProperty(am_Handle_s handle, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * acknowledges asyncCrossFade
+ */
+void RoutingControlObserverStubDefault::ackCrossFading(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_HotSink_e hotSink, am_Error_e error) {
+    // Call old style methods in default 
+    ackCrossFading(handle, hotSink, error);
+}
+void RoutingControlObserverStubDefault::ackCrossFading(am_Handle_s handle, am_HotSink_e hotSink, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * acknowledges a volume tick. This can be used to display volumechanges during
+ *  ramps
+ */
+void RoutingControlObserverStubDefault::ackSourceVolumeTick(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume) {
+    // Call old style methods in default 
+    ackSourceVolumeTick(handle, sourceID, volume);
+}
+void RoutingControlObserverStubDefault::ackSourceVolumeTick(am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume) {
+    // No operation in default
+}
+
+/**
+ * acknowledges a volume tick. This can be used to display volumechanges during
+ *  ramps
+ */
+void RoutingControlObserverStubDefault::ackSinkVolumeTick(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume) {
+    // Call old style methods in default 
+    ackSinkVolumeTick(handle, sinkID, volume);
+}
+void RoutingControlObserverStubDefault::ackSinkVolumeTick(am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume) {
+    // No operation in default
+}
+
+/**
+ * This function returns the ID to the given domainName. If already a domain is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the domain. The other parameters of the domain
+ *  will be overwritten when the domain is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+void RoutingControlObserverStubDefault::peekDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_domainID_t& domainID, am_Error_e& error) {
+    // Call old style methods in default 
+    peekDomain(name, domainID, error);
+}
+void RoutingControlObserverStubDefault::peekDomain(std::string name, am_domainID_t& domainID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * registers a domain
+(at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+void RoutingControlObserverStubDefault::registerDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Domain_s domainData, std::string returnBusname, std::string returnInterface, am_domainID_t& domainID, am_Error_e& error) {
+    // Call old style methods in default 
+    registerDomain(domainData, returnBusname, returnInterface, domainID, error);
+}
+void RoutingControlObserverStubDefault::registerDomain(am_Domain_s domainData, std::string returnBusname, std::string returnInterface, am_domainID_t& domainID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+ *  domain will be removed as well.
+(at)return E_OK on succes, E_NON_EXISTENT if
+ *  not found E_UNKOWN on error
+ */
+void RoutingControlObserverStubDefault::deregisterDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID, am_Error_e& error) {
+    // Call old style methods in default 
+    deregisterDomain(domainID, error);
+}
+void RoutingControlObserverStubDefault::deregisterDomain(am_domainID_t domainID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+void RoutingControlObserverStubDefault::registerGateway(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Gateway_s gatewayData, am_gatewayID_t& gatewayID, am_Error_e& error) {
+    // Call old style methods in default 
+    registerGateway(gatewayData, gatewayID, error);
+}
+void RoutingControlObserverStubDefault::registerGateway(am_Gateway_s gatewayData, am_gatewayID_t& gatewayID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * registers a converter. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+ *  registered E_UNKOWN on error
+ */
+void RoutingControlObserverStubDefault::registerConverter(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Converter_s converterData, am_converterID_t& converterID, am_Error_e& error) {
+    // Call old style methods in default 
+    registerConverter(converterData, converterID, error);
+}
+void RoutingControlObserverStubDefault::registerConverter(am_Converter_s converterData, am_converterID_t& converterID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * deregisters a gateway. Also removes all sinks and sources of the controlling
+ *  domain.
+(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+ *  error
+ */
+void RoutingControlObserverStubDefault::deregisterGateway(const std::shared_ptr<CommonAPI::ClientId> clientId, am_gatewayID_t gatewayID, am_Error_e& error) {
+    // Call old style methods in default 
+    deregisterGateway(gatewayID, error);
+}
+void RoutingControlObserverStubDefault::deregisterGateway(am_gatewayID_t gatewayID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * deregisters a converter. Also removes all sinks and sources of the controlling
+ *  domain.
+ */
+void RoutingControlObserverStubDefault::deregisterConverter(const std::shared_ptr<CommonAPI::ClientId> clientId, am_converterID_t converterID, am_Error_e& error) {
+    // Call old style methods in default 
+    deregisterConverter(converterID, error);
+}
+void RoutingControlObserverStubDefault::deregisterConverter(am_converterID_t converterID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * This function returns the ID to the given sinkName. If already a sink is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the sink. The other parameters of the sink will
+ *  be overwritten when the sink is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+void RoutingControlObserverStubDefault::peekSink(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sinkID_t& sinkID, am_Error_e& error) {
+    // Call old style methods in default 
+    peekSink(name, sinkID, error);
+}
+void RoutingControlObserverStubDefault::peekSink(std::string name, am_sinkID_t& sinkID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+ *  is copied to the gatewayInformation
+(at)return E_OK on succes,
+ *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+ */
+void RoutingControlObserverStubDefault::registerSink(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Sink_s sinkData, am_sinkID_t& sinkID, am_Error_e& error) {
+    // Call old style methods in default 
+    registerSink(sinkData, sinkID, error);
+}
+void RoutingControlObserverStubDefault::registerSink(am_Sink_s sinkData, am_sinkID_t& sinkID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * deregisters a sink.
+(at)return E_OK on succes, E_NON_EXISTENT if not found
+ *  E_UNKOWN on error
+ */
+void RoutingControlObserverStubDefault::deregisterSink(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_Error_e& error) {
+    // Call old style methods in default 
+    deregisterSink(sinkID, error);
+}
+void RoutingControlObserverStubDefault::deregisterSink(am_sinkID_t sinkID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * This function returns the ID to the given sourceName. If already a source is
+ *  registered with this name, it will return the corresponding ID, if not it will
+ *  reserve an ID but not register the source. The other parameters of the source
+ *  will be overwritten when the source is registered.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error
+ */
+void RoutingControlObserverStubDefault::peekSource(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sourceID_t& sourceID, am_Error_e& error) {
+    // Call old style methods in default 
+    peekSource(name, sourceID, error);
+}
+void RoutingControlObserverStubDefault::peekSource(std::string name, am_sourceID_t& sourceID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * registers a source.  If the source is part of a gateway, the
+ *  listconnectionFormats is copied to the gatewayInformation
+(at)return E_OK on
+ *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+ *  already exists
+ */
+void RoutingControlObserverStubDefault::registerSource(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Source_s sourceData, am_sourceID_t& sourceID, am_Error_e& error) {
+    // Call old style methods in default 
+    registerSource(sourceData, sourceID, error);
+}
+void RoutingControlObserverStubDefault::registerSource(am_Source_s sourceData, am_sourceID_t& sourceID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * deregisters a source
+(at)return E_OK on succes, E_NON_EXISTENT if not found
+ *  E_UNKOWN on error
+ */
+void RoutingControlObserverStubDefault::deregisterSource(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_Error_e& error) {
+    // Call old style methods in default 
+    deregisterSource(sourceID, error);
+}
+void RoutingControlObserverStubDefault::deregisterSource(am_sourceID_t sourceID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * this function registers a crossfader.
+(at)return E_OK on succes,
+ *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+ */
+void RoutingControlObserverStubDefault::registerCrossfader(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Crossfader_s crossfaderData, am_crossfaderID_t& crossfaderID, am_Error_e& error) {
+    // Call old style methods in default 
+    registerCrossfader(crossfaderData, crossfaderID, error);
+}
+void RoutingControlObserverStubDefault::registerCrossfader(am_Crossfader_s crossfaderData, am_crossfaderID_t& crossfaderID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * this function deregisters a crossfader. removes all sources and sinks assiated
+ *  as well.
+(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+ *  error
+ */
+void RoutingControlObserverStubDefault::deregisterCrossfader(const std::shared_ptr<CommonAPI::ClientId> clientId, am_crossfaderID_t crossfaderID, am_Error_e& error) {
+    // Call old style methods in default 
+    deregisterCrossfader(crossfaderID, error);
+}
+void RoutingControlObserverStubDefault::deregisterCrossfader(am_crossfaderID_t crossfaderID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+ *  determine the SinkClassIDs of a sinkClass.
+(at)return E_OK on succes,
+ *  E_DATABASE_ERROR on error
+ */
+void RoutingControlObserverStubDefault::peekSourceClassID(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sourceClass_t& sourceClassID, am_Error_e& error) {
+    // Call old style methods in default 
+    peekSourceClassID(name, sourceClassID, error);
+}
+void RoutingControlObserverStubDefault::peekSourceClassID(std::string name, am_sourceClass_t& sourceClassID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+ *  determine the SinkClassIDs of a sinkClass.
+(at)return E_OK on succes,
+ *  E_DATABASE_ERROR on error
+ */
+void RoutingControlObserverStubDefault::peekSinkClassID(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sinkClass_t& sinkClassID, am_Error_e& error) {
+    // Call old style methods in default 
+    peekSinkClassID(name, sinkClassID, error);
+}
+void RoutingControlObserverStubDefault::peekSinkClassID(std::string name, am_sinkClass_t& sinkClassID, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * is called when a low level interrupt changes it status.
+ */
+void RoutingControlObserverStubDefault::hookInterruptStatusChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_InterruptState_e interruptState) {
+    // Call old style methods in default 
+    hookInterruptStatusChange(sourceID, interruptState);
+}
+void RoutingControlObserverStubDefault::hookInterruptStatusChange(am_sourceID_t sourceID, am_InterruptState_e interruptState) {
+    // No operation in default
+}
+
+/**
+ * This hook is called when all elements from a domain are registered.
+Is used by
+ *  the Controller to know when all expected domains are finally registered
+ */
+void RoutingControlObserverStubDefault::hookDomainRegistrationComplete(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID) {
+    // Call old style methods in default 
+    hookDomainRegistrationComplete(domainID);
+}
+void RoutingControlObserverStubDefault::hookDomainRegistrationComplete(am_domainID_t domainID) {
+    // No operation in default
+}
+
+/**
+ * is called when a sink changes its availability
+ */
+void RoutingControlObserverStubDefault::hookSinkAvailablityStatusChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_Availability_s availability) {
+    // Call old style methods in default 
+    hookSinkAvailablityStatusChange(sinkID, availability);
+}
+void RoutingControlObserverStubDefault::hookSinkAvailablityStatusChange(am_sinkID_t sinkID, am_Availability_s availability) {
+    // No operation in default
+}
+
+/**
+ * is called when a source changes its availability
+ */
+void RoutingControlObserverStubDefault::hookSourceAvailablityStatusChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_Availability_s availability) {
+    // Call old style methods in default 
+    hookSourceAvailablityStatusChange(sourceID, availability);
+}
+void RoutingControlObserverStubDefault::hookSourceAvailablityStatusChange(am_sourceID_t sourceID, am_Availability_s availability) {
+    // No operation in default
+}
+
+/**
+ * is called when a domain changes its status. This used for early domains only
+ */
+void RoutingControlObserverStubDefault::hookDomainStateChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID, am_DomainState_e domainState) {
+    // Call old style methods in default 
+    hookDomainStateChange(domainID, domainState);
+}
+void RoutingControlObserverStubDefault::hookDomainStateChange(am_domainID_t domainID, am_DomainState_e domainState) {
+    // No operation in default
+}
+
+/**
+ * is called when the timinginformation (delay) changed for a connection.
+ */
+void RoutingControlObserverStubDefault::hookTimingInformationChanged(const std::shared_ptr<CommonAPI::ClientId> clientId, am_connectionID_t connectionID, am_timeSync_t delay) {
+    // Call old style methods in default 
+    hookTimingInformationChanged(connectionID, delay);
+}
+void RoutingControlObserverStubDefault::hookTimingInformationChanged(am_connectionID_t connectionID, am_timeSync_t delay) {
+    // No operation in default
+}
+
+/**
+ * this function is used to send out all data that has been changed in an early
+ *  state.
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+void RoutingControlObserverStubDefault::sendChangedData(const std::shared_ptr<CommonAPI::ClientId> clientId, am_EarlyData_L earlyData) {
+    // Call old style methods in default 
+    sendChangedData(earlyData);
+}
+void RoutingControlObserverStubDefault::sendChangedData(am_EarlyData_L earlyData) {
+    // No operation in default
+}
+
+/**
+ * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  gatewayID is not valid.
+ */
+void RoutingControlObserverStubDefault::updateGateway(const std::shared_ptr<CommonAPI::ClientId> clientId, am_gatewayID_t gatewayID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error) {
+    // Call old style methods in default 
+    updateGateway(gatewayID, listSourceFormats, listSinkFormats, convertionMatrix, error);
+}
+void RoutingControlObserverStubDefault::updateGateway(am_gatewayID_t gatewayID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * updates data of an converter. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  converterID is not valid.
+ */
+void RoutingControlObserverStubDefault::updateConverter(const std::shared_ptr<CommonAPI::ClientId> clientId, am_converterID_t converterID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error) {
+    // Call old style methods in default 
+    updateConverter(converterID, listSourceFormats, listSinkFormats, convertionMatrix, error);
+}
+void RoutingControlObserverStubDefault::updateConverter(am_converterID_t converterID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * updates data of an sink. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  sinkID is not valid.
+ */
+void RoutingControlObserverStubDefault::updateSink(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_sinkClass_t sinkClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error) {
+    // Call old style methods in default 
+    updateSink(sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, error);
+}
+void RoutingControlObserverStubDefault::updateSink(am_sinkID_t sinkID, am_sinkClass_t sinkClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+ *  sourceID in the struct is not valid. 
+Please note that only the following data
+ *  out of am_Source_s have effect when they are
+ *  changed:
+sourceClassID,
+listSoundProperties,
+listConnectionFormats,
+ * 
+listMainSoundProperties
+ */
+void RoutingControlObserverStubDefault::updateSource(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_sourceClass_t sourceClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error) {
+    // Call old style methods in default 
+    updateSource(sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, error);
+}
+void RoutingControlObserverStubDefault::updateSource(am_sourceID_t sourceID, am_sourceClass_t sourceClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error) {
+    // No operation in default
+}
+
+/**
+ * acknowledges a asyncSetSinkVolumes
+ */
+void RoutingControlObserverStubDefault::ackSetVolumes(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Volumes_L listvolumes, am_Error_e error) {
+    // Call old style methods in default 
+    ackSetVolumes(handle, listvolumes, error);
+}
+void RoutingControlObserverStubDefault::ackSetVolumes(am_Handle_s handle, am_Volumes_L listvolumes, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * The acknowledge of the SinkNotificationConfiguration
+ */
+void RoutingControlObserverStubDefault::ackSinkNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) {
+    // Call old style methods in default 
+    ackSinkNotificationConfiguration(handle, error);
+}
+void RoutingControlObserverStubDefault::ackSinkNotificationConfiguration(am_Handle_s handle, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * The acknowledge of the SourceNotificationConfiguration
+ */
+void RoutingControlObserverStubDefault::ackSourceNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error) {
+    // Call old style methods in default 
+    ackSourceNotificationConfiguration(handle, error);
+}
+void RoutingControlObserverStubDefault::ackSourceNotificationConfiguration(am_Handle_s handle, am_Error_e error) {
+    // No operation in default
+}
+
+/**
+ * is called whenever a notified value needs to be send
+ */
+void RoutingControlObserverStubDefault::hookSinkNotificationDataChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_NotificationPayload_s payload) {
+    // Call old style methods in default 
+    hookSinkNotificationDataChange(sinkID, payload);
+}
+void RoutingControlObserverStubDefault::hookSinkNotificationDataChange(am_sinkID_t sinkID, am_NotificationPayload_s payload) {
+    // No operation in default
+}
+
+/**
+ * is called whenever a notified value needs to be send
+ */
+void RoutingControlObserverStubDefault::hookSourceNotificationDataChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_NotificationPayload_s payload) {
+    // Call old style methods in default 
+    hookSourceNotificationDataChange(sourceID, payload);
+}
+void RoutingControlObserverStubDefault::hookSourceNotificationDataChange(am_sourceID_t sourceID, am_NotificationPayload_s payload) {
+    // No operation in default
+}
+
+void RoutingControlObserverStubDefault::confirmRoutingRundown(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string domainName) {
+    // Call old style methods in default 
+    confirmRoutingRundown(domainName);
+}
+void RoutingControlObserverStubDefault::confirmRoutingRundown(std::string domainName) {
+    // No operation in default
+}
+
+
+
+
+RoutingControlObserverStubDefault::RemoteEventHandler::RemoteEventHandler(RoutingControlObserverStubDefault* defaultStub):
+        defaultStub_(defaultStub) {
+}
+
+} // namespace am
+} // namespace genivi
+} // namespace org
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.h
new file mode 100644
index 0000000..df6f15b
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlObserverStubDefault.h
@@ -0,0 +1,429 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * Routing Receive sendInterface description.
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_Observer_STUB_DEFAULT_H_
+#define ORG_GENIVI_AM_Routing_Control_Observer_STUB_DEFAULT_H_
+
+
+#include <org/genivi/am/RoutingControlObserverStub.h>
+#include <sstream>
+
+namespace org {
+namespace genivi {
+namespace am {
+
+/**
+ * Provides a default implementation for RoutingControlObserverStubRemoteEvent and
+ * RoutingControlObserverStub. Method callbacks have an empty implementation,
+ * remote set calls on attributes will always change the value of the attribute
+ * to the one received.
+ *
+ * Override this stub if you only want to provide a subset of the functionality
+ * that would be defined for this service, and/or if you do not need any non-default
+ * behaviour.
+ */
+class RoutingControlObserverStubDefault : public virtual RoutingControlObserverStub {
+public:
+    RoutingControlObserverStubDefault();
+
+    RoutingControlObserverStubRemoteEvent* initStubAdapter(const std::shared_ptr<RoutingControlObserverStubAdapter>& stubAdapter);
+
+    const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId);
+
+    virtual const am_RoutingReady_e& getRoutingReadyAttribute();
+    virtual const am_RoutingReady_e& getRoutingReadyAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId);
+    virtual void setRoutingReadyAttribute(am_RoutingReady_e value);
+
+    /**
+     * acknowledges a asyncConnect
+     */
+    virtual void ackConnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error);
+    virtual void ackConnect(am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error);
+
+    /**
+     * acknowledges a asyncDisconnect
+     */
+    virtual void ackDisconnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error);
+    virtual void ackDisconnect(am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error);
+
+    /**
+     * acknowledges a asyncsetSinkVolume
+     */
+    virtual void ackSetSinkVolumeChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_volume_t volume, am_Error_e error);
+    virtual void ackSetSinkVolumeChange(am_Handle_s handle, am_volume_t volume, am_Error_e error);
+
+    /**
+     * acknowledges a asyncsetSourceVolume
+     */
+    virtual void ackSetSourceVolumeChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_volume_t volume, am_Error_e error);
+    virtual void ackSetSourceVolumeChange(am_Handle_s handle, am_volume_t volume, am_Error_e error);
+
+    /**
+     * acknowlegde for asyncSetSourceState
+     */
+    virtual void ackSetSourceState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
+    virtual void ackSetSourceState(am_Handle_s handle, am_Error_e error);
+
+    /**
+     * acknowledges asyncSetSinkSoundProperties
+     */
+    virtual void ackSetSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
+    virtual void ackSetSinkSoundProperties(am_Handle_s handle, am_Error_e error);
+
+    /**
+     * acknowledges asyncSetSinkSoundProperty
+     */
+    virtual void ackSetSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
+    virtual void ackSetSinkSoundProperty(am_Handle_s handle, am_Error_e error);
+
+    /**
+     * acknowledges asyncSetSourceSoundProperties
+     */
+    virtual void ackSetSourceSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
+    virtual void ackSetSourceSoundProperties(am_Handle_s handle, am_Error_e error);
+
+    /**
+     * acknowledges asyncSetSourceSoundProperty
+     */
+    virtual void ackSetSourceSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
+    virtual void ackSetSourceSoundProperty(am_Handle_s handle, am_Error_e error);
+
+    /**
+     * acknowledges asyncCrossFade
+     */
+    virtual void ackCrossFading(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_HotSink_e hotSink, am_Error_e error);
+    virtual void ackCrossFading(am_Handle_s handle, am_HotSink_e hotSink, am_Error_e error);
+
+    /**
+     * acknowledges a volume tick. This can be used to display volumechanges during
+     *  ramps
+     */
+    virtual void ackSourceVolumeTick(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume);
+    virtual void ackSourceVolumeTick(am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume);
+
+    /**
+     * acknowledges a volume tick. This can be used to display volumechanges during
+     *  ramps
+     */
+    virtual void ackSinkVolumeTick(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume);
+    virtual void ackSinkVolumeTick(am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume);
+
+    /**
+     * This function returns the ID to the given domainName. If already a domain is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the domain. The other parameters of the domain
+     *  will be overwritten when the domain is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     */
+    virtual void peekDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_domainID_t& domainID, am_Error_e& error);
+    virtual void peekDomain(std::string name, am_domainID_t& domainID, am_Error_e& error);
+
+    /**
+     * registers a domain
+    (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     */
+    virtual void registerDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Domain_s domainData, std::string returnBusname, std::string returnInterface, am_domainID_t& domainID, am_Error_e& error);
+    virtual void registerDomain(am_Domain_s domainData, std::string returnBusname, std::string returnInterface, am_domainID_t& domainID, am_Error_e& error);
+
+    /**
+     * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+     *  domain will be removed as well.
+    (at)return E_OK on succes, E_NON_EXISTENT if
+     *  not found E_UNKOWN on error
+     */
+    virtual void deregisterDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID, am_Error_e& error);
+    virtual void deregisterDomain(am_domainID_t domainID, am_Error_e& error);
+
+    /**
+     * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     */
+    virtual void registerGateway(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Gateway_s gatewayData, am_gatewayID_t& gatewayID, am_Error_e& error);
+    virtual void registerGateway(am_Gateway_s gatewayData, am_gatewayID_t& gatewayID, am_Error_e& error);
+
+    /**
+     * registers a converter. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
+     *  registered E_UNKOWN on error
+     */
+    virtual void registerConverter(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Converter_s converterData, am_converterID_t& converterID, am_Error_e& error);
+    virtual void registerConverter(am_Converter_s converterData, am_converterID_t& converterID, am_Error_e& error);
+
+    /**
+     * deregisters a gateway. Also removes all sinks and sources of the controlling
+     *  domain.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+     *  error
+     */
+    virtual void deregisterGateway(const std::shared_ptr<CommonAPI::ClientId> clientId, am_gatewayID_t gatewayID, am_Error_e& error);
+    virtual void deregisterGateway(am_gatewayID_t gatewayID, am_Error_e& error);
+
+    /**
+     * deregisters a converter. Also removes all sinks and sources of the controlling
+     *  domain.
+     */
+    virtual void deregisterConverter(const std::shared_ptr<CommonAPI::ClientId> clientId, am_converterID_t converterID, am_Error_e& error);
+    virtual void deregisterConverter(am_converterID_t converterID, am_Error_e& error);
+
+    /**
+     * This function returns the ID to the given sinkName. If already a sink is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the sink. The other parameters of the sink will
+     *  be overwritten when the sink is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     */
+    virtual void peekSink(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sinkID_t& sinkID, am_Error_e& error);
+    virtual void peekSink(std::string name, am_sinkID_t& sinkID, am_Error_e& error);
+
+    /**
+     * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+     *  is copied to the gatewayInformation
+    (at)return E_OK on succes,
+     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+     */
+    virtual void registerSink(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Sink_s sinkData, am_sinkID_t& sinkID, am_Error_e& error);
+    virtual void registerSink(am_Sink_s sinkData, am_sinkID_t& sinkID, am_Error_e& error);
+
+    /**
+     * deregisters a sink.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found
+     *  E_UNKOWN on error
+     */
+    virtual void deregisterSink(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_Error_e& error);
+    virtual void deregisterSink(am_sinkID_t sinkID, am_Error_e& error);
+
+    /**
+     * This function returns the ID to the given sourceName. If already a source is
+     *  registered with this name, it will return the corresponding ID, if not it will
+     *  reserve an ID but not register the source. The other parameters of the source
+     *  will be overwritten when the source is registered.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error
+     */
+    virtual void peekSource(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sourceID_t& sourceID, am_Error_e& error);
+    virtual void peekSource(std::string name, am_sourceID_t& sourceID, am_Error_e& error);
+
+    /**
+     * registers a source.  If the source is part of a gateway, the
+     *  listconnectionFormats is copied to the gatewayInformation
+    (at)return E_OK on
+     *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
+     *  already exists
+     */
+    virtual void registerSource(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Source_s sourceData, am_sourceID_t& sourceID, am_Error_e& error);
+    virtual void registerSource(am_Source_s sourceData, am_sourceID_t& sourceID, am_Error_e& error);
+
+    /**
+     * deregisters a source
+    (at)return E_OK on succes, E_NON_EXISTENT if not found
+     *  E_UNKOWN on error
+     */
+    virtual void deregisterSource(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_Error_e& error);
+    virtual void deregisterSource(am_sourceID_t sourceID, am_Error_e& error);
+
+    /**
+     * this function registers a crossfader.
+    (at)return E_OK on succes,
+     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
+     */
+    virtual void registerCrossfader(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Crossfader_s crossfaderData, am_crossfaderID_t& crossfaderID, am_Error_e& error);
+    virtual void registerCrossfader(am_Crossfader_s crossfaderData, am_crossfaderID_t& crossfaderID, am_Error_e& error);
+
+    /**
+     * this function deregisters a crossfader. removes all sources and sinks assiated
+     *  as well.
+    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
+     *  error
+     */
+    virtual void deregisterCrossfader(const std::shared_ptr<CommonAPI::ClientId> clientId, am_crossfaderID_t crossfaderID, am_Error_e& error);
+    virtual void deregisterCrossfader(am_crossfaderID_t crossfaderID, am_Error_e& error);
+
+    /**
+     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+     *  determine the SinkClassIDs of a sinkClass.
+    (at)return E_OK on succes,
+     *  E_DATABASE_ERROR on error
+     */
+    virtual void peekSourceClassID(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sourceClass_t& sourceClassID, am_Error_e& error);
+    virtual void peekSourceClassID(std::string name, am_sourceClass_t& sourceClassID, am_Error_e& error);
+
+    /**
+     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+     *  determine the SinkClassIDs of a sinkClass.
+    (at)return E_OK on succes,
+     *  E_DATABASE_ERROR on error
+     */
+    virtual void peekSinkClassID(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sinkClass_t& sinkClassID, am_Error_e& error);
+    virtual void peekSinkClassID(std::string name, am_sinkClass_t& sinkClassID, am_Error_e& error);
+
+    /**
+     * is called when a low level interrupt changes it status.
+     */
+    virtual void hookInterruptStatusChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_InterruptState_e interruptState);
+    virtual void hookInterruptStatusChange(am_sourceID_t sourceID, am_InterruptState_e interruptState);
+
+    /**
+     * This hook is called when all elements from a domain are registered.
+    Is used by
+     *  the Controller to know when all expected domains are finally registered
+     */
+    virtual void hookDomainRegistrationComplete(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID);
+    virtual void hookDomainRegistrationComplete(am_domainID_t domainID);
+
+    /**
+     * is called when a sink changes its availability
+     */
+    virtual void hookSinkAvailablityStatusChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_Availability_s availability);
+    virtual void hookSinkAvailablityStatusChange(am_sinkID_t sinkID, am_Availability_s availability);
+
+    /**
+     * is called when a source changes its availability
+     */
+    virtual void hookSourceAvailablityStatusChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_Availability_s availability);
+    virtual void hookSourceAvailablityStatusChange(am_sourceID_t sourceID, am_Availability_s availability);
+
+    /**
+     * is called when a domain changes its status. This used for early domains only
+     */
+    virtual void hookDomainStateChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID, am_DomainState_e domainState);
+    virtual void hookDomainStateChange(am_domainID_t domainID, am_DomainState_e domainState);
+
+    /**
+     * is called when the timinginformation (delay) changed for a connection.
+     */
+    virtual void hookTimingInformationChanged(const std::shared_ptr<CommonAPI::ClientId> clientId, am_connectionID_t connectionID, am_timeSync_t delay);
+    virtual void hookTimingInformationChanged(am_connectionID_t connectionID, am_timeSync_t delay);
+
+    /**
+     * this function is used to send out all data that has been changed in an early
+     *  state.
+    (at)return E_OK on success, E_UNKNOWN on error
+     */
+    virtual void sendChangedData(const std::shared_ptr<CommonAPI::ClientId> clientId, am_EarlyData_L earlyData);
+    virtual void sendChangedData(am_EarlyData_L earlyData);
+
+    /**
+     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  gatewayID is not valid.
+     */
+    virtual void updateGateway(const std::shared_ptr<CommonAPI::ClientId> clientId, am_gatewayID_t gatewayID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error);
+    virtual void updateGateway(am_gatewayID_t gatewayID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error);
+
+    /**
+     * updates data of an converter. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  converterID is not valid.
+     */
+    virtual void updateConverter(const std::shared_ptr<CommonAPI::ClientId> clientId, am_converterID_t converterID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error);
+    virtual void updateConverter(am_converterID_t converterID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error);
+
+    /**
+     * updates data of an sink. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  sinkID is not valid.
+     */
+    virtual void updateSink(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_sinkClass_t sinkClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error);
+    virtual void updateSink(am_sinkID_t sinkID, am_sinkClass_t sinkClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error);
+
+    /**
+     * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
+     *  sourceID in the struct is not valid. 
+    Please note that only the following data
+     *  out of am_Source_s have effect when they are
+     *  changed:
+    sourceClassID,
+    listSoundProperties,
+    listConnectionFormats,
+     * 
+    listMainSoundProperties
+     */
+    virtual void updateSource(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_sourceClass_t sourceClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error);
+    virtual void updateSource(am_sourceID_t sourceID, am_sourceClass_t sourceClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error);
+
+    /**
+     * acknowledges a asyncSetSinkVolumes
+     */
+    virtual void ackSetVolumes(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Volumes_L listvolumes, am_Error_e error);
+    virtual void ackSetVolumes(am_Handle_s handle, am_Volumes_L listvolumes, am_Error_e error);
+
+    /**
+     * The acknowledge of the SinkNotificationConfiguration
+     */
+    virtual void ackSinkNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
+    virtual void ackSinkNotificationConfiguration(am_Handle_s handle, am_Error_e error);
+
+    /**
+     * The acknowledge of the SourceNotificationConfiguration
+     */
+    virtual void ackSourceNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
+    virtual void ackSourceNotificationConfiguration(am_Handle_s handle, am_Error_e error);
+
+    /**
+     * is called whenever a notified value needs to be send
+     */
+    virtual void hookSinkNotificationDataChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_NotificationPayload_s payload);
+    virtual void hookSinkNotificationDataChange(am_sinkID_t sinkID, am_NotificationPayload_s payload);
+
+    /**
+     * is called whenever a notified value needs to be send
+     */
+    virtual void hookSourceNotificationDataChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_NotificationPayload_s payload);
+    virtual void hookSourceNotificationDataChange(am_sourceID_t sourceID, am_NotificationPayload_s payload);
+
+    virtual void confirmRoutingRundown(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string domainName);
+    virtual void confirmRoutingRundown(std::string domainName);
+
+
+
+
+protected:
+    /**
+     * This attribute signals to the clients the current routing state.
+    A client
+     *  should notify himself to this attribute in order to know the current state and
+     *  act accordingly.
+     */
+    virtual bool trySetRoutingReadyAttribute(am_RoutingReady_e value);
+    virtual bool validateRoutingReadyAttributeRequestedValue(const am_RoutingReady_e& value);
+    class RemoteEventHandler: public virtual RoutingControlObserverStubRemoteEvent {
+     public:
+        RemoteEventHandler(RoutingControlObserverStubDefault* defaultStub);
+
+        /**
+         * This attribute signals to the clients the current routing state.
+        A client
+         *  should notify himself to this attribute in order to know the current state and
+         *  act accordingly.
+         */
+
+
+     private:
+        RoutingControlObserverStubDefault* defaultStub_;
+    };
+private:
+    RoutingControlObserverStubDefault::RemoteEventHandler remoteEventHandler_;
+
+    /**
+     * This attribute signals to the clients the current routing state.
+    A client
+     *  should notify himself to this attribute in order to know the current state and
+     *  act accordingly.
+     */
+    am_RoutingReady_e routingReadyAttributeValue_;
+
+    CommonAPI::Version interfaceVersion_;
+};
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Routing_Control_Observer_STUB_DEFAULT_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxy.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxy.h
new file mode 100644
index 0000000..76f5a8e
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxy.h
@@ -0,0 +1,712 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * This class implements everything from Audiomanager -&gt; RoutingAdapter
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_PROXY_H_
+#define ORG_GENIVI_AM_Routing_Control_PROXY_H_
+
+#include "RoutingControlProxyBase.h"
+
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+template <typename ... _AttributeExtensions>
+class RoutingControlProxy: virtual public RoutingControl, virtual public RoutingControlProxyBase
+, public _AttributeExtensions... {
+public:
+    RoutingControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
+    ~RoutingControlProxy();
+
+    typedef RoutingControl InterfaceType;
+
+
+
+
+    /**
+     * aborts an asynchronous action.
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_NON_EXISTENT if handle was not found
+     * 
+     * Calls asyncAbort with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncAbort(const am_Handle_s& handle, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncAbort with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncAbortAsync(const am_Handle_s& handle, AsyncAbortAsyncCallback callback);
+    /**
+     * connects a source to a sink
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+     * 
+     * Calls asyncConnect with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncConnect with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, AsyncConnectAsyncCallback callback);
+    /**
+     * disconnect a connection with given connectionID
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+     * 
+     * Calls asyncDisconnect with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncDisconnect with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, AsyncDisconnectAsyncCallback callback);
+    /**
+     * this method is used to set the volume of a sink. This function is used to drive
+     *  ramps, to mute or unmute or directly set the value. The difference is made
+     *  through the ramptype.
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_OUT_OF_RANGE if new volume is out of range
+     * 
+     * Calls asyncSetSinkVolume with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncSetSinkVolume(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncSetSinkVolume with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncSetSinkVolumeAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, AsyncSetSinkVolumeAsyncCallback callback);
+    /**
+     * sets the volume of a source. This method is used to set the volume of a sink.
+     *  This function is used to drive ramps, to mute or unmute or directly set the
+     *  value. The difference is made through the ramptype.
+    (at)return E_OK on
+     *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+     *  range.
+    triggers the acknowledge ackSourceVolumeChange
+     * 
+     * Calls asyncSetSourceVolume with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncSetSourceVolume(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncSetSourceVolume with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceVolumeAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, AsyncSetSourceVolumeAsyncCallback callback);
+    /**
+     * This function is used to set the source state of a particular
+     *  source.
+    (at)return E_OK on success, E_UNKNOWN on error
+     * 
+     * Calls asyncSetSourceState with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncSetSourceState(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncSetSourceState with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback);
+    /**
+     * this function sets the sinksoundproperty.
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+     * 
+     * Calls asyncSetSinkSoundProperties with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncSetSinkSoundProperties with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback);
+    /**
+     * this function sets the sinksoundproperty.
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+     * 
+     * Calls asyncSetSinkSoundProperty with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncSetSinkSoundProperty with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, AsyncSetSinkSoundPropertyAsyncCallback callback);
+    /**
+     * this function sets the sourcesoundproperty.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+     * 
+     * Calls asyncSetSourceSoundProperties with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncSetSourceSoundProperties(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncSetSourceSoundProperties with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, AsyncSetSourceSoundPropertiesAsyncCallback callback);
+    /**
+     * this function sets the sourcesoundproperty.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+     * 
+     * Calls asyncSetSourceSoundProperty with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncSetSourceSoundProperty(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncSetSourceSoundProperty with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, AsyncSetSourceSoundPropertyAsyncCallback callback);
+    /**
+     * this function triggers crossfading.
+    (at)return E_OK on success, E_UNKNOWN on
+     *  error
+     * 
+     * Calls asyncCrossFade with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncCrossFade(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_CustomRampType_t& rampType, const am_time_t& time, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncCrossFade with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncCrossFadeAsync(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_CustomRampType_t& rampType, const am_time_t& time, AsyncCrossFadeAsyncCallback callback);
+    /**
+     * this function is used for early and late audio functions to set the domain
+     *  state
+    (at)return E_OK on success, E_UNKNOWN on error
+     * 
+     * Calls setDomainState with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+    * All non-const parameters will be filled with the returned values.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void setDomainState(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus, am_Error_e& error);
+    /**
+     * Calls setDomainState with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> setDomainStateAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, SetDomainStateAsyncCallback callback);
+    /**
+     * Calls asyncSetVolumes with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncSetVolumes(const am_Handle_s& handle, const am_Volumes_L& volumes, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncSetVolumes with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& volumes, AsyncSetVolumesAsyncCallback callback);
+    /**
+     * Calls asyncSetSinkNotificationConfiguration with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncSetSinkNotificationConfiguration(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncSetSinkNotificationConfiguration with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncSetSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSinkNotificationConfigurationAsyncCallback callback);
+    /**
+     * Calls asyncSetSourceNotificationConfiguration with synchronous semantics.
+     * 
+    * All const parameters are input parameters to this method.
+     * The CallStatus will be filled when the method returns and indicate either
+     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
+     * will be set.
+     */
+    virtual void asyncSetSourceNotificationConfiguration(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus);
+    /**
+     * Calls asyncSetSourceNotificationConfiguration with asynchronous semantics.
+     * 
+     * The provided callback will be called when the reply to this call arrives or
+     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
+     * or which type of error has occurred. In case of any error, ONLY the CallStatus
+     * will have a defined value.
+     * The std::future returned by this method will be fulfilled at arrival of the reply.
+     * It will provide the same value for CallStatus as will be handed to the callback.
+     */
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSourceNotificationConfigurationAsyncCallback callback);
+
+
+    /**
+     * Returns the CommonAPI address of the remote partner this proxy communicates with.
+     */
+    virtual std::string getAddress() const;
+
+    /**
+     * Returns the domain of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getDomain() const;
+
+    /** 
+     * Returns the service ID of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getServiceId() const;
+
+    /**
+     * Returns the instance ID of the remote partner this proxy communicates with.
+     */
+    virtual const std::string& getInstanceId() const;
+
+    /**
+     * Returns true if the remote partner for this proxy is currently known to be available.
+     */
+    virtual bool isAvailable() const;
+
+    /**
+     * Returns true if the remote partner for this proxy is available.
+     */
+    virtual bool isAvailableBlocking() const;
+
+    /**
+     * Returns the wrapper class that is used to (de-)register for notifications about
+     * the availability of the remote partner of this proxy.
+     */
+    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();
+
+    /**
+     * Returns the wrapper class that is used to access version information of the remote
+     * partner of this proxy.
+     */
+    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();
+
+ private:
+    std::shared_ptr<RoutingControlProxyBase> delegate_;
+};
+
+#ifdef WIN32
+    typedef RoutingControlProxy<CommonAPI::WINDummyAttributeExtension<CommonAPI::WINDummyAttribute>> RoutingControlProxyDefault;
+#else
+    typedef RoutingControlProxy<> RoutingControlProxyDefault;
+#endif
+
+
+//
+// RoutingControlProxy Implementation
+//
+template <typename ... _AttributeExtensions>
+RoutingControlProxy<_AttributeExtensions...>::RoutingControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
+        _AttributeExtensions(*(std::dynamic_pointer_cast<RoutingControlProxyBase>(delegate)))...,
+        delegate_(std::dynamic_pointer_cast<RoutingControlProxyBase>(delegate)) {
+}
+
+template <typename ... _AttributeExtensions>
+RoutingControlProxy<_AttributeExtensions...>::~RoutingControlProxy() {
+}
+
+/**
+ * aborts an asynchronous action.
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_NON_EXISTENT if handle was not found
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncAbort(const am_Handle_s& handle, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncAbort(handle, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncAbortAsync(const am_Handle_s& handle, AsyncAbortAsyncCallback callback) {
+    return delegate_->asyncAbortAsync(handle, callback);
+}
+/**
+ * connects a source to a sink
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncConnect(handle, connectionID, sourceID, sinkID, connectionFormat, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, AsyncConnectAsyncCallback callback) {
+    return delegate_->asyncConnectAsync(handle, connectionID, sourceID, sinkID, connectionFormat, callback);
+}
+/**
+ * disconnect a connection with given connectionID
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncDisconnect(handle, connectionID, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, AsyncDisconnectAsyncCallback callback) {
+    return delegate_->asyncDisconnectAsync(handle, connectionID, callback);
+}
+/**
+ * this method is used to set the volume of a sink. This function is used to drive
+ *  ramps, to mute or unmute or directly set the value. The difference is made
+ *  through the ramptype.
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_OUT_OF_RANGE if new volume is out of range
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkVolume(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncSetSinkVolume(handle, sinkID, volume, ramp, time, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkVolumeAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, AsyncSetSinkVolumeAsyncCallback callback) {
+    return delegate_->asyncSetSinkVolumeAsync(handle, sinkID, volume, ramp, time, callback);
+}
+/**
+ * sets the volume of a source. This method is used to set the volume of a sink.
+ *  This function is used to drive ramps, to mute or unmute or directly set the
+ *  value. The difference is made through the ramptype.
+(at)return E_OK on
+ *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+ *  range.
+triggers the acknowledge ackSourceVolumeChange
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceVolume(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncSetSourceVolume(handle, sourceID, volume, ramp, time, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceVolumeAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, AsyncSetSourceVolumeAsyncCallback callback) {
+    return delegate_->asyncSetSourceVolumeAsync(handle, sourceID, volume, ramp, time, callback);
+}
+/**
+ * This function is used to set the source state of a particular
+ *  source.
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceState(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncSetSourceState(handle, sourceID, state, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback) {
+    return delegate_->asyncSetSourceStateAsync(handle, sourceID, state, callback);
+}
+/**
+ * this function sets the sinksoundproperty.
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncSetSinkSoundProperties(handle, sinkID, listSoundProperties, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback) {
+    return delegate_->asyncSetSinkSoundPropertiesAsync(handle, sinkID, listSoundProperties, callback);
+}
+/**
+ * this function sets the sinksoundproperty.
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncSetSinkSoundProperty(handle, sinkID, soundProperty, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, AsyncSetSinkSoundPropertyAsyncCallback callback) {
+    return delegate_->asyncSetSinkSoundPropertyAsync(handle, sinkID, soundProperty, callback);
+}
+/**
+ * this function sets the sourcesoundproperty.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceSoundProperties(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncSetSourceSoundProperties(handle, sourceID, listSoundProperties, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, AsyncSetSourceSoundPropertiesAsyncCallback callback) {
+    return delegate_->asyncSetSourceSoundPropertiesAsync(handle, sourceID, listSoundProperties, callback);
+}
+/**
+ * this function sets the sourcesoundproperty.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceSoundProperty(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncSetSourceSoundProperty(handle, sourceID, soundProperty, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, AsyncSetSourceSoundPropertyAsyncCallback callback) {
+    return delegate_->asyncSetSourceSoundPropertyAsync(handle, sourceID, soundProperty, callback);
+}
+/**
+ * this function triggers crossfading.
+(at)return E_OK on success, E_UNKNOWN on
+ *  error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncCrossFade(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_CustomRampType_t& rampType, const am_time_t& time, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncCrossFade(handle, crossfaderID, hotSink, rampType, time, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncCrossFadeAsync(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_CustomRampType_t& rampType, const am_time_t& time, AsyncCrossFadeAsyncCallback callback) {
+    return delegate_->asyncCrossFadeAsync(handle, crossfaderID, hotSink, rampType, time, callback);
+}
+/**
+ * this function is used for early and late audio functions to set the domain
+ *  state
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::setDomainState(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
+    delegate_->setDomainState(domainID, domainState, callStatus, error);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::setDomainStateAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, SetDomainStateAsyncCallback callback) {
+    return delegate_->setDomainStateAsync(domainID, domainState, callback);
+}
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncSetVolumes(const am_Handle_s& handle, const am_Volumes_L& volumes, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncSetVolumes(handle, volumes, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& volumes, AsyncSetVolumesAsyncCallback callback) {
+    return delegate_->asyncSetVolumesAsync(handle, volumes, callback);
+}
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkNotificationConfiguration(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncSetSinkNotificationConfiguration(handle, sinkID, notificationConfiguration, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSinkNotificationConfigurationAsyncCallback callback) {
+    return delegate_->asyncSetSinkNotificationConfigurationAsync(handle, sinkID, notificationConfiguration, callback);
+}
+template <typename ... _AttributeExtensions>
+void RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceNotificationConfiguration(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus) {
+    delegate_->asyncSetSourceNotificationConfiguration(handle, sourceID, notificationConfiguration, callStatus);
+}
+
+template <typename ... _AttributeExtensions>
+std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSourceNotificationConfigurationAsyncCallback callback) {
+    return delegate_->asyncSetSourceNotificationConfigurationAsync(handle, sourceID, notificationConfiguration, callback);
+}
+
+template <typename ... _AttributeExtensions>
+std::string RoutingControlProxy<_AttributeExtensions...>::getAddress() const {
+    return delegate_->getAddress();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& RoutingControlProxy<_AttributeExtensions...>::getDomain() const {
+    return delegate_->getDomain();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& RoutingControlProxy<_AttributeExtensions...>::getServiceId() const {
+    return delegate_->getServiceId();
+}
+
+template <typename ... _AttributeExtensions>
+const std::string& RoutingControlProxy<_AttributeExtensions...>::getInstanceId() const {
+    return delegate_->getInstanceId();
+}
+
+template <typename ... _AttributeExtensions>
+bool RoutingControlProxy<_AttributeExtensions...>::isAvailable() const {
+    return delegate_->isAvailable();
+}
+
+template <typename ... _AttributeExtensions>
+bool RoutingControlProxy<_AttributeExtensions...>::isAvailableBlocking() const {
+    return delegate_->isAvailableBlocking();
+}
+
+template <typename ... _AttributeExtensions>
+CommonAPI::ProxyStatusEvent& RoutingControlProxy<_AttributeExtensions...>::getProxyStatusEvent() {
+    return delegate_->getProxyStatusEvent();
+}
+
+template <typename ... _AttributeExtensions>
+CommonAPI::InterfaceVersionAttribute& RoutingControlProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
+    return delegate_->getInterfaceVersionAttribute();
+}
+
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+
+#endif // ORG_GENIVI_AM_Routing_Control_PROXY_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxyBase.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxyBase.h
new file mode 100644
index 0000000..dd14bde
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlProxyBase.h
@@ -0,0 +1,163 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * This class implements everything from Audiomanager -&gt; RoutingAdapter
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_PROXY_BASE_H_
+#define ORG_GENIVI_AM_Routing_Control_PROXY_BASE_H_
+
+#include "RoutingControl.h"
+
+
+#include <org/genivi/am.h>
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/InputStream.h>
+#include <CommonAPI/OutputStream.h>
+#include <CommonAPI/SerializableStruct.h>
+#include <cstdint>
+#include <vector>
+
+#include <CommonAPI/Proxy.h>
+#include <functional>
+#include <future>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+class RoutingControlProxyBase: virtual public CommonAPI::Proxy {
+ public:
+
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncAbortAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncConnectAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncDisconnectAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSinkVolumeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSourceVolumeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSourceStateAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSinkSoundPropertiesAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSinkSoundPropertyAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSourceSoundPropertiesAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSourceSoundPropertyAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncCrossFadeAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> SetDomainStateAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetVolumesAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSinkNotificationConfigurationAsyncCallback;
+    typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSourceNotificationConfigurationAsyncCallback;
+
+
+
+    /**
+     * aborts an asynchronous action.
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_NON_EXISTENT if handle was not found
+     */
+    virtual void asyncAbort(const am_Handle_s& handle, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncAbortAsync(const am_Handle_s& handle, AsyncAbortAsyncCallback callback) = 0;
+    /**
+     * connects a source to a sink
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+     */
+    virtual void asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, AsyncConnectAsyncCallback callback) = 0;
+    /**
+     * disconnect a connection with given connectionID
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+     */
+    virtual void asyncDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, AsyncDisconnectAsyncCallback callback) = 0;
+    /**
+     * this method is used to set the volume of a sink. This function is used to drive
+     *  ramps, to mute or unmute or directly set the value. The difference is made
+     *  through the ramptype.
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_OUT_OF_RANGE if new volume is out of range
+     */
+    virtual void asyncSetSinkVolume(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncSetSinkVolumeAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, AsyncSetSinkVolumeAsyncCallback callback) = 0;
+    /**
+     * sets the volume of a source. This method is used to set the volume of a sink.
+     *  This function is used to drive ramps, to mute or unmute or directly set the
+     *  value. The difference is made through the ramptype.
+    (at)return E_OK on
+     *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+     *  range.
+    triggers the acknowledge ackSourceVolumeChange
+     */
+    virtual void asyncSetSourceVolume(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceVolumeAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, AsyncSetSourceVolumeAsyncCallback callback) = 0;
+    /**
+     * This function is used to set the source state of a particular
+     *  source.
+    (at)return E_OK on success, E_UNKNOWN on error
+     */
+    virtual void asyncSetSourceState(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback) = 0;
+    /**
+     * this function sets the sinksoundproperty.
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    virtual void asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback) = 0;
+    /**
+     * this function sets the sinksoundproperty.
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    virtual void asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, AsyncSetSinkSoundPropertyAsyncCallback callback) = 0;
+    /**
+     * this function sets the sourcesoundproperty.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    virtual void asyncSetSourceSoundProperties(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, AsyncSetSourceSoundPropertiesAsyncCallback callback) = 0;
+    /**
+     * this function sets the sourcesoundproperty.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    virtual void asyncSetSourceSoundProperty(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, AsyncSetSourceSoundPropertyAsyncCallback callback) = 0;
+    /**
+     * this function triggers crossfading.
+    (at)return E_OK on success, E_UNKNOWN on
+     *  error
+     */
+    virtual void asyncCrossFade(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_CustomRampType_t& rampType, const am_time_t& time, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncCrossFadeAsync(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_CustomRampType_t& rampType, const am_time_t& time, AsyncCrossFadeAsyncCallback callback) = 0;
+    /**
+     * this function is used for early and late audio functions to set the domain
+     *  state
+    (at)return E_OK on success, E_UNKNOWN on error
+     */
+    virtual void setDomainState(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
+    virtual std::future<CommonAPI::CallStatus> setDomainStateAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, SetDomainStateAsyncCallback callback) = 0;
+    virtual void asyncSetVolumes(const am_Handle_s& handle, const am_Volumes_L& volumes, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& volumes, AsyncSetVolumesAsyncCallback callback) = 0;
+    virtual void asyncSetSinkNotificationConfiguration(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncSetSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSinkNotificationConfigurationAsyncCallback callback) = 0;
+    virtual void asyncSetSourceNotificationConfiguration(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus) = 0;
+    virtual std::future<CommonAPI::CallStatus> asyncSetSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSourceNotificationConfigurationAsyncCallback callback) = 0;
+};
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Routing_Control_PROXY_BASE_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStub.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStub.h
new file mode 100644
index 0000000..069fa88
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStub.h
@@ -0,0 +1,198 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * This class implements everything from Audiomanager -&gt; RoutingAdapter
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_STUB_H_
+#define ORG_GENIVI_AM_Routing_Control_STUB_H_
+
+
+
+#include <org/genivi/am.h>
+
+#include "RoutingControl.h"
+
+#if !defined (COMMONAPI_INTERNAL_COMPILATION)
+#define COMMONAPI_INTERNAL_COMPILATION
+#endif
+
+#include <CommonAPI/InputStream.h>
+#include <CommonAPI/OutputStream.h>
+#include <CommonAPI/SerializableStruct.h>
+#include <cstdint>
+#include <vector>
+
+#include <CommonAPI/Stub.h>
+
+#undef COMMONAPI_INTERNAL_COMPILATION
+
+namespace org {
+namespace genivi {
+namespace am {
+
+/**
+ * Receives messages from remote and handles all dispatching of deserialized calls
+ * to a stub for the service RoutingControl. Also provides means to send broadcasts
+ * and attribute-changed-notifications of observable attributes as defined by this service.
+ * An application developer should not need to bother with this class.
+ */
+class RoutingControlStubAdapter: virtual public CommonAPI::StubAdapter, public RoutingControl {
+ public:
+
+
+
+    virtual void deactivateManagedInstances() = 0;
+protected:
+    /**
+     * Defines properties for storing the ClientIds of clients / proxies that have
+     * subscribed to the selective broadcasts
+     */
+};
+
+
+/**
+ * Defines the necessary callbacks to handle remote set events related to the attributes
+ * defined in the IDL description for RoutingControl.
+ * For each attribute two callbacks are defined:
+ * - a verification callback that allows to verify the requested value and to prevent setting
+ *   e.g. an invalid value ("onRemoteSet<AttributeName>").
+ * - an action callback to do local work after the attribute value has been changed
+ *   ("onRemote<AttributeName>Changed").
+ *
+ * This class and the one below are the ones an application developer needs to have
+ * a look at if he wants to implement a service.
+ */
+class RoutingControlStubRemoteEvent {
+ public:
+    virtual ~RoutingControlStubRemoteEvent() { }
+
+};
+
+
+/**
+ * Defines the interface that must be implemented by any class that should provide
+ * the service RoutingControl to remote clients.
+ * This class and the one above are the ones an application developer needs to have
+ * a look at if he wants to implement a service.
+ */
+class RoutingControlStub: public virtual CommonAPI::Stub<RoutingControlStubAdapter, RoutingControlStubRemoteEvent> {
+public:
+    virtual ~RoutingControlStub() { }
+    virtual const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) = 0;
+
+
+    /**
+     * aborts an asynchronous action.
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_NON_EXISTENT if handle was not found
+     */
+    /// This is the method that will be called on remote calls on the method asyncAbort.
+    virtual void asyncAbort(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle) = 0;
+    /**
+     * connects a source to a sink
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+     */
+    /// This is the method that will be called on remote calls on the method asyncConnect.
+    virtual void asyncConnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_sourceID_t sourceID, am_sinkID_t sinkID, am_CustomConnectionFormat_t connectionFormat) = 0;
+    /**
+     * disconnect a connection with given connectionID
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+     */
+    /// This is the method that will be called on remote calls on the method asyncDisconnect.
+    virtual void asyncDisconnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID) = 0;
+    /**
+     * this method is used to set the volume of a sink. This function is used to drive
+     *  ramps, to mute or unmute or directly set the value. The difference is made
+     *  through the ramptype.
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_OUT_OF_RANGE if new volume is out of range
+     */
+    /// This is the method that will be called on remote calls on the method asyncSetSinkVolume.
+    virtual void asyncSetSinkVolume(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time) = 0;
+    /**
+     * sets the volume of a source. This method is used to set the volume of a sink.
+     *  This function is used to drive ramps, to mute or unmute or directly set the
+     *  value. The difference is made through the ramptype.
+    (at)return E_OK on
+     *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+     *  range.
+    triggers the acknowledge ackSourceVolumeChange
+     */
+    /// This is the method that will be called on remote calls on the method asyncSetSourceVolume.
+    virtual void asyncSetSourceVolume(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time) = 0;
+    /**
+     * This function is used to set the source state of a particular
+     *  source.
+    (at)return E_OK on success, E_UNKNOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method asyncSetSourceState.
+    virtual void asyncSetSourceState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SourceState_e state) = 0;
+    /**
+     * this function sets the sinksoundproperty.
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    /// This is the method that will be called on remote calls on the method asyncSetSinkSoundProperties.
+    virtual void asyncSetSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_L listSoundProperties) = 0;
+    /**
+     * this function sets the sinksoundproperty.
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    /// This is the method that will be called on remote calls on the method asyncSetSinkSoundProperty.
+    virtual void asyncSetSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_s soundProperty) = 0;
+    /**
+     * this function sets the sourcesoundproperty.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    /// This is the method that will be called on remote calls on the method asyncSetSourceSoundProperties.
+    virtual void asyncSetSourceSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_L listSoundProperties) = 0;
+    /**
+     * this function sets the sourcesoundproperty.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    /// This is the method that will be called on remote calls on the method asyncSetSourceSoundProperty.
+    virtual void asyncSetSourceSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_s soundProperty) = 0;
+    /**
+     * this function triggers crossfading.
+    (at)return E_OK on success, E_UNKNOWN on
+     *  error
+     */
+    /// This is the method that will be called on remote calls on the method asyncCrossFade.
+    virtual void asyncCrossFade(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_crossfaderID_t crossfaderID, am_HotSink_e hotSink, am_CustomRampType_t rampType, am_time_t time) = 0;
+    /**
+     * this function is used for early and late audio functions to set the domain
+     *  state
+    (at)return E_OK on success, E_UNKNOWN on error
+     */
+    /// This is the method that will be called on remote calls on the method setDomainState.
+    virtual void setDomainState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID, am_DomainState_e domainState, am_Error_e& error) = 0;
+    /// This is the method that will be called on remote calls on the method asyncSetVolumes.
+    virtual void asyncSetVolumes(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Volumes_L volumes) = 0;
+    /// This is the method that will be called on remote calls on the method asyncSetSinkNotificationConfiguration.
+    virtual void asyncSetSinkNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_NotificationConfiguration_s notificationConfiguration) = 0;
+    /// This is the method that will be called on remote calls on the method asyncSetSourceNotificationConfiguration.
+    virtual void asyncSetSourceNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_NotificationConfiguration_s notificationConfiguration) = 0;
+
+    using CommonAPI::Stub<RoutingControlStubAdapter, RoutingControlStubRemoteEvent>::initStubAdapter;
+    typedef CommonAPI::Stub<RoutingControlStubAdapter, RoutingControlStubRemoteEvent>::StubAdapterType StubAdapterType;
+    typedef CommonAPI::Stub<RoutingControlStubAdapter, RoutingControlStubRemoteEvent>::RemoteEventHandlerType RemoteEventHandlerType;
+    typedef RoutingControlStubRemoteEvent RemoteEventType;
+    typedef RoutingControl StubInterface;
+};
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Routing_Control_STUB_H_
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.cpp b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.cpp
new file mode 100644
index 0000000..64423a9
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.cpp
@@ -0,0 +1,224 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+#include <org/genivi/am/RoutingControlStubDefault.h>
+
+namespace org {
+namespace genivi {
+namespace am {
+
+RoutingControlStubDefault::RoutingControlStubDefault():
+        remoteEventHandler_(this),
+        interfaceVersion_(RoutingControl::getInterfaceVersion()) {
+}
+
+const CommonAPI::Version& RoutingControlStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId) {
+    return interfaceVersion_;
+}
+
+RoutingControlStubRemoteEvent* RoutingControlStubDefault::initStubAdapter(const std::shared_ptr<RoutingControlStubAdapter>& stubAdapter) {
+    CommonAPI::Stub<RoutingControlStubAdapter, RoutingControlStubRemoteEvent>::stubAdapter_ = stubAdapter;
+    return &remoteEventHandler_;
+}
+
+
+/**
+ * aborts an asynchronous action.
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_NON_EXISTENT if handle was not found
+ */
+void RoutingControlStubDefault::asyncAbort(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle) {
+    // Call old style methods in default 
+    asyncAbort(handle);
+}
+void RoutingControlStubDefault::asyncAbort(am_Handle_s handle) {
+    // No operation in default
+}
+
+/**
+ * connects a source to a sink
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+ */
+void RoutingControlStubDefault::asyncConnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_sourceID_t sourceID, am_sinkID_t sinkID, am_CustomConnectionFormat_t connectionFormat) {
+    // Call old style methods in default 
+    asyncConnect(handle, connectionID, sourceID, sinkID, connectionFormat);
+}
+void RoutingControlStubDefault::asyncConnect(am_Handle_s handle, am_connectionID_t connectionID, am_sourceID_t sourceID, am_sinkID_t sinkID, am_CustomConnectionFormat_t connectionFormat) {
+    // No operation in default
+}
+
+/**
+ * disconnect a connection with given connectionID
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+ */
+void RoutingControlStubDefault::asyncDisconnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID) {
+    // Call old style methods in default 
+    asyncDisconnect(handle, connectionID);
+}
+void RoutingControlStubDefault::asyncDisconnect(am_Handle_s handle, am_connectionID_t connectionID) {
+    // No operation in default
+}
+
+/**
+ * this method is used to set the volume of a sink. This function is used to drive
+ *  ramps, to mute or unmute or directly set the value. The difference is made
+ *  through the ramptype.
+(at)return E_OK on success, E_UNKNOWN on error,
+ *  E_OUT_OF_RANGE if new volume is out of range
+ */
+void RoutingControlStubDefault::asyncSetSinkVolume(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time) {
+    // Call old style methods in default 
+    asyncSetSinkVolume(handle, sinkID, volume, ramp, time);
+}
+void RoutingControlStubDefault::asyncSetSinkVolume(am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time) {
+    // No operation in default
+}
+
+/**
+ * sets the volume of a source. This method is used to set the volume of a sink.
+ *  This function is used to drive ramps, to mute or unmute or directly set the
+ *  value. The difference is made through the ramptype.
+(at)return E_OK on
+ *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+ *  range.
+triggers the acknowledge ackSourceVolumeChange
+ */
+void RoutingControlStubDefault::asyncSetSourceVolume(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time) {
+    // Call old style methods in default 
+    asyncSetSourceVolume(handle, sourceID, volume, ramp, time);
+}
+void RoutingControlStubDefault::asyncSetSourceVolume(am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time) {
+    // No operation in default
+}
+
+/**
+ * This function is used to set the source state of a particular
+ *  source.
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+void RoutingControlStubDefault::asyncSetSourceState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SourceState_e state) {
+    // Call old style methods in default 
+    asyncSetSourceState(handle, sourceID, state);
+}
+void RoutingControlStubDefault::asyncSetSourceState(am_Handle_s handle, am_sourceID_t sourceID, am_SourceState_e state) {
+    // No operation in default
+}
+
+/**
+ * this function sets the sinksoundproperty.
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+void RoutingControlStubDefault::asyncSetSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_L listSoundProperties) {
+    // Call old style methods in default 
+    asyncSetSinkSoundProperties(handle, sinkID, listSoundProperties);
+}
+void RoutingControlStubDefault::asyncSetSinkSoundProperties(am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_L listSoundProperties) {
+    // No operation in default
+}
+
+/**
+ * this function sets the sinksoundproperty.
+(at)return E_OK on success, E_UNKNOWN
+ *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+void RoutingControlStubDefault::asyncSetSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_s soundProperty) {
+    // Call old style methods in default 
+    asyncSetSinkSoundProperty(handle, sinkID, soundProperty);
+}
+void RoutingControlStubDefault::asyncSetSinkSoundProperty(am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_s soundProperty) {
+    // No operation in default
+}
+
+/**
+ * this function sets the sourcesoundproperty.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+void RoutingControlStubDefault::asyncSetSourceSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_L listSoundProperties) {
+    // Call old style methods in default 
+    asyncSetSourceSoundProperties(handle, sourceID, listSoundProperties);
+}
+void RoutingControlStubDefault::asyncSetSourceSoundProperties(am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_L listSoundProperties) {
+    // No operation in default
+}
+
+/**
+ * this function sets the sourcesoundproperty.
+(at)return E_OK on success,
+ *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+ */
+void RoutingControlStubDefault::asyncSetSourceSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_s soundProperty) {
+    // Call old style methods in default 
+    asyncSetSourceSoundProperty(handle, sourceID, soundProperty);
+}
+void RoutingControlStubDefault::asyncSetSourceSoundProperty(am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_s soundProperty) {
+    // No operation in default
+}
+
+/**
+ * this function triggers crossfading.
+(at)return E_OK on success, E_UNKNOWN on
+ *  error
+ */
+void RoutingControlStubDefault::asyncCrossFade(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_crossfaderID_t crossfaderID, am_HotSink_e hotSink, am_CustomRampType_t rampType, am_time_t time) {
+    // Call old style methods in default 
+    asyncCrossFade(handle, crossfaderID, hotSink, rampType, time);
+}
+void RoutingControlStubDefault::asyncCrossFade(am_Handle_s handle, am_crossfaderID_t crossfaderID, am_HotSink_e hotSink, am_CustomRampType_t rampType, am_time_t time) {
+    // No operation in default
+}
+
+/**
+ * this function is used for early and late audio functions to set the domain
+ *  state
+(at)return E_OK on success, E_UNKNOWN on error
+ */
+void RoutingControlStubDefault::setDomainState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID, am_DomainState_e domainState, am_Error_e& error) {
+    // Call old style methods in default 
+    setDomainState(domainID, domainState, error);
+}
+void RoutingControlStubDefault::setDomainState(am_domainID_t domainID, am_DomainState_e domainState, am_Error_e& error) {
+    // No operation in default
+}
+
+void RoutingControlStubDefault::asyncSetVolumes(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Volumes_L volumes) {
+    // Call old style methods in default 
+    asyncSetVolumes(handle, volumes);
+}
+void RoutingControlStubDefault::asyncSetVolumes(am_Handle_s handle, am_Volumes_L volumes) {
+    // No operation in default
+}
+
+void RoutingControlStubDefault::asyncSetSinkNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_NotificationConfiguration_s notificationConfiguration) {
+    // Call old style methods in default 
+    asyncSetSinkNotificationConfiguration(handle, sinkID, notificationConfiguration);
+}
+void RoutingControlStubDefault::asyncSetSinkNotificationConfiguration(am_Handle_s handle, am_sinkID_t sinkID, am_NotificationConfiguration_s notificationConfiguration) {
+    // No operation in default
+}
+
+void RoutingControlStubDefault::asyncSetSourceNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_NotificationConfiguration_s notificationConfiguration) {
+    // Call old style methods in default 
+    asyncSetSourceNotificationConfiguration(handle, sourceID, notificationConfiguration);
+}
+void RoutingControlStubDefault::asyncSetSourceNotificationConfiguration(am_Handle_s handle, am_sourceID_t sourceID, am_NotificationConfiguration_s notificationConfiguration) {
+    // No operation in default
+}
+
+
+
+
+RoutingControlStubDefault::RemoteEventHandler::RemoteEventHandler(RoutingControlStubDefault* defaultStub):
+        defaultStub_(defaultStub) {
+}
+
+} // namespace am
+} // namespace genivi
+} // namespace org
diff --git a/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.h b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.h
new file mode 100644
index 0000000..f92a46f
--- /dev/null
+++ b/PluginRoutingInterfaceCAPI/src-gen/org/genivi/am/RoutingControlStubDefault.h
@@ -0,0 +1,176 @@
+/*
+* This file was generated by the CommonAPI Generators.
+* Used org.genivi.commonapi.core 2.1.6.v20150127.
+* Used org.franca.core 0.8.10.201309262002.
+*
+* 
+*/
+/**
+ * This class implements everything from Audiomanager -&gt; RoutingAdapter
+ * @author Christian Mueller
+ */
+#ifndef ORG_GENIVI_AM_Routing_Control_STUB_DEFAULT_H_
+#define ORG_GENIVI_AM_Routing_Control_STUB_DEFAULT_H_
+
+
+#include <org/genivi/am/RoutingControlStub.h>
+#include <sstream>
+
+namespace org {
+namespace genivi {
+namespace am {
+
+/**
+ * Provides a default implementation for RoutingControlStubRemoteEvent and
+ * RoutingControlStub. Method callbacks have an empty implementation,
+ * remote set calls on attributes will always change the value of the attribute
+ * to the one received.
+ *
+ * Override this stub if you only want to provide a subset of the functionality
+ * that would be defined for this service, and/or if you do not need any non-default
+ * behaviour.
+ */
+class RoutingControlStubDefault : public virtual RoutingControlStub {
+public:
+    RoutingControlStubDefault();
+
+    RoutingControlStubRemoteEvent* initStubAdapter(const std::shared_ptr<RoutingControlStubAdapter>& stubAdapter);
+
+    const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId);
+
+
+    /**
+     * aborts an asynchronous action.
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_NON_EXISTENT if handle was not found
+     */
+    virtual void asyncAbort(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle);
+    virtual void asyncAbort(am_Handle_s handle);
+
+    /**
+     * connects a source to a sink
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
+     */
+    virtual void asyncConnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_sourceID_t sourceID, am_sinkID_t sinkID, am_CustomConnectionFormat_t connectionFormat);
+    virtual void asyncConnect(am_Handle_s handle, am_connectionID_t connectionID, am_sourceID_t sourceID, am_sinkID_t sinkID, am_CustomConnectionFormat_t connectionFormat);
+
+    /**
+     * disconnect a connection with given connectionID
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
+     */
+    virtual void asyncDisconnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID);
+    virtual void asyncDisconnect(am_Handle_s handle, am_connectionID_t connectionID);
+
+    /**
+     * this method is used to set the volume of a sink. This function is used to drive
+     *  ramps, to mute or unmute or directly set the value. The difference is made
+     *  through the ramptype.
+    (at)return E_OK on success, E_UNKNOWN on error,
+     *  E_OUT_OF_RANGE if new volume is out of range
+     */
+    virtual void asyncSetSinkVolume(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time);
+    virtual void asyncSetSinkVolume(am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time);
+
+    /**
+     * sets the volume of a source. This method is used to set the volume of a sink.
+     *  This function is used to drive ramps, to mute or unmute or directly set the
+     *  value. The difference is made through the ramptype.
+    (at)return E_OK on
+     *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+     *  range.
+    triggers the acknowledge ackSourceVolumeChange
+     */
+    virtual void asyncSetSourceVolume(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time);
+    virtual void asyncSetSourceVolume(am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time);
+
+    /**
+     * This function is used to set the source state of a particular
+     *  source.
+    (at)return E_OK on success, E_UNKNOWN on error
+     */
+    virtual void asyncSetSourceState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SourceState_e state);
+    virtual void asyncSetSourceState(am_Handle_s handle, am_sourceID_t sourceID, am_SourceState_e state);
+
+    /**
+     * this function sets the sinksoundproperty.
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    virtual void asyncSetSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_L listSoundProperties);
+    virtual void asyncSetSinkSoundProperties(am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_L listSoundProperties);
+
+    /**
+     * this function sets the sinksoundproperty.
+    (at)return E_OK on success, E_UNKNOWN
+     *  on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    virtual void asyncSetSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_s soundProperty);
+    virtual void asyncSetSinkSoundProperty(am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_s soundProperty);
+
+    /**
+     * this function sets the sourcesoundproperty.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    virtual void asyncSetSourceSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_L listSoundProperties);
+    virtual void asyncSetSourceSoundProperties(am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_L listSoundProperties);
+
+    /**
+     * this function sets the sourcesoundproperty.
+    (at)return E_OK on success,
+     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
+     */
+    virtual void asyncSetSourceSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_s soundProperty);
+    virtual void asyncSetSourceSoundProperty(am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_s soundProperty);
+
+    /**
+     * this function triggers crossfading.
+    (at)return E_OK on success, E_UNKNOWN on
+     *  error
+     */
+    virtual void asyncCrossFade(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_crossfaderID_t crossfaderID, am_HotSink_e hotSink, am_CustomRampType_t rampType, am_time_t time);
+    virtual void asyncCrossFade(am_Handle_s handle, am_crossfaderID_t crossfaderID, am_HotSink_e hotSink, am_CustomRampType_t rampType, am_time_t time);
+
+    /**
+     * this function is used for early and late audio functions to set the domain
+     *  state
+    (at)return E_OK on success, E_UNKNOWN on error
+     */
+    virtual void setDomainState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID, am_DomainState_e domainState, am_Error_e& error);
+    virtual void setDomainState(am_domainID_t domainID, am_DomainState_e domainState, am_Error_e& error);
+
+    virtual void asyncSetVolumes(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Volumes_L volumes);
+    virtual void asyncSetVolumes(am_Handle_s handle, am_Volumes_L volumes);
+
+    virtual void asyncSetSinkNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_NotificationConfiguration_s notificationConfiguration);
+    virtual void asyncSetSinkNotificationConfiguration(am_Handle_s handle, am_sinkID_t sinkID, am_NotificationConfiguration_s notificationConfiguration);
+
+    virtual void asyncSetSourceNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_NotificationConfiguration_s notificationConfiguration);
+    virtual void asyncSetSourceNotificationConfiguration(am_Handle_s handle, am_sourceID_t sourceID, am_NotificationConfiguration_s notificationConfiguration);
+
+
+
+
+protected:
+    class RemoteEventHandler: public virtual RoutingControlStubRemoteEvent {
+     public:
+        RemoteEventHandler(RoutingControlStubDefault* defaultStub);
+
+
+     private:
+        RoutingControlStubDefault* defaultStub_;
+    };
+private:
+    RoutingControlStubDefault::RemoteEventHandler remoteEventHandler_;
+
+
+    CommonAPI::Version interfaceVersion_;
+};
+
+} // namespace am
+} // namespace genivi
+} // namespace org
+
+#endif // ORG_GENIVI_AM_Routing_Control_STUB_DEFAULT_H_
-- 
2.1.0

